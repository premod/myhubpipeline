
global proc xtools()
{ // defining globals - starting UI 
 // setting global paths
  global string $prefsPath;  
  global string $iconPath;
  $prefsPath = "//mayaserver/CustomScripts/Scripts/Modeling/";
  $iconPath = $prefsPath + "icons/xtools_icons/";
  global string $shelfPath;
  $shelfPath = `internalVar -userShelfDir`;
  global string $scriptPath;
  $scriptPath = `internalVar -userScriptDir`;
 // open startup window 
  xtoolsStartupWindow; // - open startup window
  text -e -l "Version 3.9.6 by Andrew Osiow"  xsAuthor; 
  text -e -l "X-Tools"  xsName;   
  if (`window -ex xToolsWindow`)
    text -e -l "Restarting X-Tools." xsText;
  else 
    text -e -l "Starting X-Tools." xsText;
  progressBar -edit -step 1 xsProgressControl; 
 // check for version number and adding global boolean if it higher than 7.0 
  string $currentMayaVersion;
  $currentMayaVersion = `about -v`;
  global int $isMaya8Plus;
  global int $isMaya85Plus;
  global int $isMaya2008Plus;  
 // assumes Maya is a 2008 or higher version 
  $isMaya8Plus = 1;
  $isMaya85Plus = 1;    
  $isMaya2008Plus = 0;      
  if ((strcmp($currentMayaVersion,"8.0")<0)&&(strcmp($currentMayaVersion,"6.0")>0)) // for versions 7.0
  {
    $isMaya8Plus = 0;
    $isMaya85Plus = 0; 
  }
  if ((strcmp($currentMayaVersion,"8.5")<0)&&(strcmp($currentMayaVersion,"7.0")>0)) // for versions 8.0
    $isMaya85Plus = 0;
  if ($isMaya85Plus)
    if ((strcmp($currentMayaVersion,"2007")>0)&&(strcmp($currentMayaVersion,"2999")<0))
      $isMaya2008Plus = 1;    
 // UI Globals - set in buildXUI
  global int $xtoolRestart;
  global int $hotkeysOn;
  global int $shelfSet;     // 1 = poly only, 2 = nurb only, 3 = General only (old Default - remove version 3.9.6)
  global int $shelfOn;  
  global int $toolMessages;
  global int $alignToSelection;
  global int $keepFacesTogether;
  global int $polyInterActive;
  global int $nurbInterActive;
  global string $lastSelectedComp;
  global int $loopSpacing;
  global int $loopOffset;
  global int $helpOn;
  global int $extractOn;
  global string $lastSculptMode;
  global string $lastSymMode;
  global int $contrainDisplacement;
  $xtoolRestart = false;
  $extractOn = false; 
  $seletionChanged = false;
  $alignToSelection = true;
  $keepFacesTogether = `optionVar -q polyKeepFacetsGrouped`;
  $polyInterActive = `optionVar -q createPolyPrimitiveAsTool`;
  $nurbInterActive = `optionVar -q createNurbsPrimitiveAsTool`;
  $toolMessages = true;
  $lastSelectedComp = "";
  $loopSpacing = 0;
  $loopOffset = 1;
  $helpOn = false;
  $lastSculptMode = "";
  $lastSymMode = "";  
  $contrainDisplacement = false;
  global float $lastPivotPostion[];
 // setting keep Original flags to off 
  turnOffKeepOriginal;
 //making backup copy of userHotKeys
  string $hotKeySource = ($prefsPath+"userHotkeys.mel");
  string $hotKeyDest = ($prefsPath+"xToolHotkeyBackUp.mel");
  sysFile -copy $hotKeyDest $hotKeySource;
 // creating monitor tasks
  global int $shutDownScript; 
  global int $newSelectionScript; 
  global int $newToolScript;  
  if (!`window -ex xToolsWindow`) 
  { //only start jobs if xtools isn't running
    $shutDownScript = `scriptJob -runOnce true -e "quitApplication" shutDownXtools`;  // quiting Maya with Xtools running 
    $newSelectionScript = `scriptJob -runOnce true -e "SelectionChanged" newSelectionXtools`; // run once when a new selection is made
    $newToolScript = `scriptJob -runOnce true -e "ToolChanged" newToolXtools`; // run once when a new tool is changed
  }
 // build X-Tools 
  buildXUI ();
  deleteUI xsWindow;
}  


global proc xtoolsStartupWindow()
{ // opens up Startup window while X-Tools initializes
  // setting global paths
  global string $prefsPath;  
  global string $iconPath;
  $prefsPath = "//mayaserver/CustomScripts/Scripts/Modeling/";
  $iconPath = $prefsPath + "icons/xtools_icons/";
  global string $shelfPath;
  $shelfPath = `internalVar -userShelfDir`;
  global string $scriptPath;
  $scriptPath = `internalVar -userScriptDir`;
 // open startup progress window
  if (`windowPref -ex xsWindow`) windowPref -remove xsWindow; // delete Window Pref
  string $xsWin = `window 
    -w 220 -h 100// a small window will stretch to fit gadgets in layout mode
    -title "X-Tools StartUp"
    -tlb 1 -rtf 1 -s 0 // no resize - no sizing gadget
    xsWindow`;
  formLayout -numberOfDivisions 100 xsLayout;  // create a Form Layout with a 100 grid point
  text -w 160 -h 16 xsAuthor;
  text -w 64 -h 32  xsName; 
  progressBar -maxValue 34 -w 200 -h 16 xsProgressControl;
  text -w 160 -h 16 xsText;
  formLayout -edit
    -af xsAuthor          "top" 6
    -af xsAuthor          "right" 4
    -af xsAuthor          "left" 80   
    -af xsText            "top" 28
    -af xsText            "left" 80 
    -af xsName           "top" 16
    -af xsName           "left" 16     
    -ac xsProgressControl "top"  8 xsName  
    -af xsProgressControl "left" 4
    -af xsProgressControl "right" 4
    -af xsProgressControl "bottom" 4    
  xsLayout;
  showWindow $xsWin;
}


global proc newToolXtools()
{ // script run when Tool changes
  // it automatically update xtools to the appropiate display
  global int $newToolScript;
  global string $previousTool;
  string $currentTool = `currentCtx`; 
  if ($currentTool!=$previousTool )
  {
    switch ($previousTool)
    {
      case "artSelectContext":
        paintSelectOverlay(0);
        break;
      case "artPuttyContext":
        sculptOverlay(0);
        break;
      case "softModContext":
        softModOverlay(0);     
        break;
    }
    switch ($currentTool)
    {
      case "artSelectContext":
        paintSelectMode;
        break;
      case "artPuttyContext":
        sculptTweek;
        break;
      case "softModContext":
        softModTweek;     
        break;
    }
  }
 // Remembers  last tool 
  $previousTool = $currentTool;
 // reset changed tool script   
  $newToolScript = `scriptJob -runOnce true -e "ToolChanged" newToolXtools`; 
}


global proc newSelectionXtools()
{ // script run when selection changes
  // it resets various flags to intial states and changes many button icons
  global string $iconPath;
  global int $previousSelection;
  global int $alignToSelection;
  global int $pivotShape;
  global int $newSelectionScript;
  global string $currentSelection[];
  $currentSelection = `ls -sl -fl`;
  global string $oldSelection[];
  global int $didLoopSelect;
  global int $ringSelection;
  global int $extractOn;
  global int $shelfSet;
  global int $isMaya8Plus;  
 // reset loop button back to select loop
  if ($shelfSet==1)
  {
    if (`shelfButton -ex xbutton2`)
      if (`gmatch $currentSelection[0] "*.e*"`)
        if (($ringSelection)||(!$didLoopSelect))    
        {
          shelfButton -e -ann "Select Loop or Border" -image ($iconPath + "selectloopbrd.xpm") xbutton2;
          shelfButton -e -image ($iconPath + "selectloopbrd.xpm") slSwapButton;          
        }  
        else;
      else if (!`gmatch $currentSelection[0] "*.*"`)
        shelfButton -e -ann "Select Loop or Border" -image ($iconPath + "selectloopbrd.xpm") xbutton2;
   // testing to see if poly ungroup Icon should change to extract face   
    if ((`shelfButton -ex xbutton14`)&&($shelfSet==1))   
      if (size($currentSelection)>1)
      {
         shelfButton -e -image ($iconPath + "quickcombine.xpm")
           -ann "Combine Plus" -command "uberCombine" xbutton14;    
         menuItem -e -label "Mirror Geometry" -command "setdirectiontoMirror; directionButtonOverlay(1);" xmenu14s; 
      }
      else
      {
        shelfButton -e -image ($iconPath + "mirrorpoly.xpm") 
          -ann "Mirror Geometry" -command "setdirectiontoMirror; directionButtonOverlay(1)" xbutton14;
        menuItem -e -label "Combine Plus" -command "uberCombine" xmenu14s;       
      }
    if ((`shelfButton -ex xbutton15`)&&($shelfSet==1))
      if (`gmatch $currentSelection[0] "*.f*"`)
      {
        $extractOn = true;
        shelfButton -e -ann "Extract Plus" -image ($iconPath + "uberextract.xpm") xbutton15; 
        menuItem -e -label "Extract Duplicates" -command "quickExtract(true)" xmenu15s;
      }
      else
      {
        $extractOn = false;
        shelfButton -e -ann "Ungroup" -image ($iconPath + "xungroup.xpm") xbutton15;
        menuItem -e -label "Separate" 
          -command "SeparatePolygon; DeleteHistory; pickWalk -d up; ungroup;" xmenu15s;            
      }
   // testing to see if create poly should be turned into fill hole, bevel edge or chamfer  
    if (`shelfButton -ex xbutton8`)
    {
      if (`gmatch $currentSelection[0] "*.e*"`)
      {
        if (isBorderEdge($currentSelection[0]))
        {               
          int $edgeTotal = size($currentSelection);
          switch ($edgeTotal)
          {
            case 1:
              shelfButton -e 
                -image ($iconPath + "fillholeopt.xpm") -ann "Fill Hole" xbutton8;     
              break;
            case 2:
              if ($isMaya8Plus)
                shelfButton -e 
                  -image ($iconPath + "xbridgeopt.xpm") -ann "Bridge" xbutton8;     
              break;   
            default: 
              shelfButton -e 
                -image ($iconPath + "appendpoly.xpm") -ann "Append to Polygon" xbutton8;     
              break;
          } 
        }
        else   
          shelfButton -e 
            -image ($iconPath + "beveledgeopt.xpm") -ann "Bevel Edge" xbutton8;        
      }
      if (`gmatch $currentSelection[0] "*.v*"`) 
        shelfButton -e 
          -image ($iconPath + "chamferopt.xpm") -ann "Chamfer Vertex" xbutton8;
      if (`gmatch $currentSelection[0] "*.f*"`) 
        shelfButton -e 
          -image ($iconPath + "poke.xpm") -ann "Poke Face" xbutton8;    
      if ((size($currentSelection)>0)&&(!`gmatch $currentSelection[0] "*.*"`))
        shelfButton -e 
	  -image ($iconPath + "appendpoly.xpm") -ann "Append to Polygon" xbutton8; 
      if (size($currentSelection)==0)
        shelfButton -e 
          -image ($iconPath + "createpoly.xpm") -ann "Create New Polygon" xbutton8; 
    }
  }  
 // testing to see if nurb ungroup Icon should change to detach
  if ($shelfSet==2)
    if (`shelfButton -ex xbutton15`)
      if ((`gmatch $currentSelection[0] "*.u*"`)||(`gmatch $currentSelection[0] "*.v*"`))
        shelfButton -e -ann "Detach" -image ($iconPath + "uberdetach.xpm") xbutton15; 
      else
        shelfButton -e -ann "UnGroup" -image ($iconPath + "xungroup.xpm") xbutton15;               
  if ($currentSelection[0]!=$oldSelection[0])
  {// the selection has really changed 
    $alignToSelection = true;
    $makeSoft = true;
    $pivotShape = true;
   // resetting center pivot for both nurb and polys 
    if (`shelfButton -ex xbutton19`)
      shelfButton -e -ann "Center Pivot on Selection" -image ($iconPath + "centerpivot.xpm") xbutton19;
   // resetting align button back to align to component 
    if ((`shelfButton -ex xbutton6`)&&($shelfSet==1))
      shelfButton -e -ann "Align Move Manipulator to Component" -image ($iconPath + "aligntoface.xpm") xbutton6;
  }
  if (size($currentSelection)>0) 
    $oldSelection = $currentSelection;
  $didLoopSelect = false; 
 // reset changed selection script   
  $newSelectionScript = `scriptJob -runOnce true -e "SelectionChanged" newSelectionXtools`; 
}


global proc updateTogetherFlags()
{ //matches  x-tools flag to Maya's
  global int $keepFacesTogether;
  $keepFacesTogether = `optionVar -q polyKeepFacetsGrouped`;
  if (`menuItem -ex xmenu13n`)    
    menuItem -e -cb $keepFacesTogether xmenu13n;
  if (`menuItem -ex xmenu15n`)        
    menuItem -e -cb $keepFacesTogether xmenu15n;
}


global proc updateCurrentInteractiveFlag()
{ //updates either poly or nurb interactive settings based on which tool set is on
  global int $polyInterActive;
  global int $nurbInterActive;
  global int $shelfSet;
  if ($shelfSet==2)
    toggleCreateNurbsPrimitiveAsTool;
  else 
    toggleCreatePolyPrimitiveAsTool;
  updateInteractiveFlags;
}


global proc updateInteractiveFlags()
{ //matches  x-tools flag to Maya's
  global int $polyInterActive;
  global int $nurbInterActive;
  global int $shelfSet;
  $polyInterActive = `optionVar -q createPolyPrimitiveAsTool`;
  $nurbInterActive = `optionVar -q createNurbsPrimitiveAsTool`;
  if (`menuItem -ex xmenu16m1`)  
  {
    if ($shelfSet==1)
    {
      menuItem -e -cb $polyInterActive xmenu16m1;
      menuItem -e -cb $polyInterActive xInteractive;       
    }
    if ($shelfSet==2) 
    {
      menuItem -e -cb $nurbInterActive xmenu16m1; 
      menuItem -e -cb $nurbInterActive xInteractive; 
    }
  }
}


global proc closeXtools()
{ // activated when the xTools window is closed - given a different name to separate it on the job list
  shutDownXtools;
}


global proc shutDownXtools()
{ // run right before maya quits or when the xtools window is closed
  global int $xtoolRestart;
  global int $shutDownScript; 
  global int $newSelectionScript;
  global int $newToolScript; 
  global int $xToolboxShutdown;
  global int $shelfOn;  
  global int $hotkeysOn;
  global int $isMaya8Plus;
  global int $closeOn;
  if (!$xtoolRestart) 
    print ("\nShutting X-Tools down.\n");
  if ($hotkeysOn) releaseXHotKeys;   //  clean-up temp hot keys before quiting.
 // reset sculpt and select scripts to nothing   
 // kill all script jobs started by x-tools remove after rebuilding is no longer necessary
  print ("deleting X-Tool Script Jobs.\n");
  if (!`window -ex xToolsWindow`)
  {
    scriptJob -kill $newSelectionScript;
    scriptJob -kill $newToolScript;
  }
  if (!`window -ex xToolsWindow`) scriptJob -kill $shutDownScript;   
  saveXPrefs;
  if ($xtoolRestart) 
    print ("X-Tools has restarted.\n");
  else print ("X-Tools has closed.\n"); 
  $xtoolRestart = false;
}

 
global proc turnOffKeepOriginal()
{ // turns off Keep Original for most functions
  optionVar -iv attachCrvKeepOriginal 0;
  optionVar -iv attachKeepOriginal 0;
  optionVar -iv closeKeepOriginal 0;  
  optionVar -iv closeSurfaceKeepOriginal 0;
  optionVar -iv cutCurveKeepOriginal 0;
  optionVar -iv insertIsoKeepOriginal 0;
  optionVar -iv insertKnotKeepOriginal 0;
  optionVar -iv rebuildCurveKeepOriginal 0;
  optionVar -iv rebuildSurfaceKeepOriginal 0;
  optionVar -iv reverseKeepOriginal 0;
  optionVar -iv reverseCurveKeepOriginal 0;
  optionVar -iv reverseSurfaceKeepOriginal 0;  
  optionVar -iv subdKeepOriginal 0;           
}


global proc buildXCommands ()
{ // build command object in preperation for assign hot keys
  global string $XHotKeyFunction[];
  $XHotKeyFunction = {"brushSelectMode", "selectLoopRing", "toggleWos",  "toggleComp",        "togglePolyNormals",
                      "alignToSelection","uberSplitEdge","uberNewFace","toggleEdgeHardness","conformPolyNormals", 
                      "mergePolyVertices","uberTweek",    "uberExtrude","uberCombine",       "breakOfFace",
                      "subdpolytoggle",  "smoothPolyMesh","freezeTransformNode","reCenterPivot","deleteShapeHistory"};
  int $index = 0;
  for ($function in $XHotKeyFunction)  // creates a nameCommand for each function by add the suffix "Com"
    nameCommand -d 1 -ann $function -c $function ($function+"Com");
  // add one command for iconify toggle
  nameCommand -d 1 -ann "iconifyToggle" -c "iconifyToggle" ("iconifyToggleCom");
  text -e -l "Creating Hotkeys." xsText;
  progressBar -edit -step 1 xsProgressControl;
}


global proc setXHotKeys ()
{ // sets a the list of hotkeys but stores the any previous hotkey settings
  global string $XHotKeyList[];
  global string $XHotKeyFunction[];
  global string $OrignalHotKeyFunctionPress[];
  global string $OrignalHotKeyFunctionRelease[];
  $XHotKeyList = {"A","L","V","O","N", 
                  "R","E","G","H","C",
                  "M","T","X","J","B",
                  "U","S","F","P","D"};
  $index=0;
  hotkey -as 0;
  for ($key in $XHotKeyList)
  { // stores info on current hotkey in global array before resetting hotkey
//  need to copy user hotkeys as a backup 

    hotkey -k $XHotKeyList[$index]  -name ($XHotKeyFunction[$index]+"Com") -pcr true;
    hotkey -k $XHotKeyList[$index]  -releaseName "";    
    $index++;
  }
  // add Shift I as and Iconify toggle
  hotkey -k "I" -name "iconifyToggleCom" -pcr true;
  hotkey -k "I" -releaseName "";
  print ("X-Tools HotKeys have been set.  Uncheck HotKeys in the Prefs Menu to restore Default and User HotKeys.\n");
}


global proc releaseXHotKeys ()
{ // restores hotkeys to their original value before been overwritten by setXHotKeys
  global string $prefsPath;  
  global string $XHotKeyList[];
  global string $XHotKeyFunction[];
  hotkey -as 1; //turn auto save on
  hotkey -fs;  // restore factory settings
  hotkey -suh;  // need to refresh user hotkeys
  hotkey -as 0; // turn auto save off
// copy backup hotkey back to userhotkeys
  string $hotKeyDest = ($prefsPath+"userHotkeys.mel");
  string $hotKeySource = ($prefsPath+"xToolHotkeyBackUp.mel");
  sysFile -copy $hotKeyDest $hotKeySource;  
  sysFile -del $hotKeySource;
  print ("X-Tools HotKeys have been released.  Default and User HotKeys have been restored.\n");
}


global proc buildPolyCreaseOverlay()
{ // builds gui and for PolyCrease value
  floatField -vis 0 -h 20 -w 40 -minValue 0.00 -maxValue 10 -value 2.50 -precision 2 -step .05 pCreaseFloat;
  popupMenu -p pCreaseFloat;
    menuItem -rp "N"  -label "Full" -c "floatField -e -v 10.0 pCreaseFloat" fullCreaseMenu; 
    menuItem -rp "E"  -label "1.0" -c "floatField -e -v 1.0 pCreaseFloat" creaseVMenu;         
    menuItem -rp "W"  -label "2.5" -c "floatField -e -v 2.5 pCreaseFloat" creaseV25Menu;     
    menuItem -rp "S"  -label "None" -c "floatField -e -v 0.0 pCreaseFloat" noCreaseMenu;
  setParent toolXOver; 
  button -vis 0 -l "Crease" -w 60 -h 20  -c "polyCrease -value `floatField -q -v pCreaseFloat`; creaseButtonOverlay(0)" polyCreaseGoButton; 
  button -vis 0 -l "Cancel" -w 60 -h 20 -c "creaseButtonOverlay(0)" polyCreaseCancelButton;
 // layout for Direction overlay 
 formLayout -e
   -af pCreaseFloat "top" 50   -af pCreaseFloat "left" 64 
   -af polyCreaseGoButton "top" 104  -af polyCreaseGoButton "left" 4 
   -af polyCreaseCancelButton "top" 104  -af polyCreaseCancelButton "left" 96
 toolXOver; 
 print ("done");
}


global proc buildDirectionButtonOverlay()
{ // builds buttons and for chosen a cardinal direction
  global string $iconPath;
  button -vis 0 -l "X+" -w 32 -h 32 -c "" xPosButton;
  button -vis 0 -l "X-" -w 32 -h 32 -c "" xNegButton;
  button -vis 0 -l "Y+" -w 32 -h 32 -c "" yPosButton;
  button -vis 0 -l "Y-" -w 32 -h 32 -c "" yNegButton;
  button -vis 0 -l "Z+" -w 32 -h 32 -c "" zPosButton;
  button -vis 0 -l "Z-" -w 32 -h 32 -c "" zNegButton;  
  button -vis 0 -l "Cancel" -w 60 -h 20 -c "directionButtonOverlay(0)" dCancelButton;
 // layout for Direction overlay 
  formLayout -e              
    -af xPosButton "top" 16	-af xPosButton "left" 32
    -af xNegButton "top" 48     -af xNegButton "left" 32
    -af yPosButton "top" 16	-af yPosButton "left" 64
    -af yNegButton "top" 48     -af yNegButton "left" 64
    -af zPosButton "top" 16	-af zPosButton "left" 96
    -af zNegButton "top" 48     -af zNegButton "left" 96
    -af dCancelButton "top" 104  -af dCancelButton "left" 50
  toolXOver;    
}


global proc buildSelectLoopOverlay()
{ // display loop spacing and offset globals to adjust repeating loop seletion
  // Interface Begins
  global string $iconPath;
  text -vis 0 -l "Space" slSpacingLabel;
  intField -vis 0 -h 20 -w 40 -minValue 0 -maxValue 100 -s 1 -v 0 -cc "selectLoopRing(0,0,0)" slSpacingFloat;
  button -vis 0 -l "-1" -h 20 -w 20 -ann "Loop Spacing -1" -c "intField -e -v (`intField -q -v slSpacingFloat`-1) slSpacingFloat; selectLoopRing(0,0,0);" slSpacingDownButton;
  button -vis 0 -l "+1" -h 20 -w 20 -ann "Loop Spacing +1" -c "intField -e -v (`intField -q -v slSpacingFloat`+1) slSpacingFloat; selectLoopRing(0,0,0);" slSpacingUpButton;
  text -vis 0 -l "Offset" slOffsetLabel;
  intField -vis 0 -h 20 -w 40 -minValue 0 -maxValue 100 -s 1 -v 0 -cc "setLoopOptions; selectLoopRing(0,0)" slOffsetFloat;
  button -vis 0 -l "-1" -h 20 -w 20 -ann "Offset Loop -1" -c "intField -e -v (`intField -q -v slOffsetFloat`-1) slOffsetFloat; selectLoopRing(0,0,0);" slOffsetDownButton;
  button -vis 0 -l "+1" -h 20 -w 20 -ann "Offset Loop +1" -c "intField -e -v (`intField -q -v slOffsetFloat`+1) slOffsetFloat; selectLoopRing(0,0,0);" slOffsetUpButton;  
  shelfButton -vis 0 -width 32 -height 32 -image ($iconPath+"selectloopbrd.xpm") -ann "Loop/Ring" -command "selectLoopRing(1,0,0);" slSwapButton;   
  shelfButton -vis 0 -width 32 -height 32 -image ($iconPath+"growloop.xpm") -ann "Grow Loop/Ring" -command "intField -e -v 0 slSpacingFloat; intField -e -v 0 slOffsetFloat; selectLoopRing(1,1,0);" slGrowButton; 
  button -vis 0 -l "Cancel" -w 60 -h 20 -c "selectLoopOverlay(0); intField -e -v 0 slSpacingFloat; intField -e -v 0 slOffsetFloat;" slCancelButton;
 // layout for loop selection overlay 
  formLayout -e     
      -af slSpacingLabel "top" 18	-af slSpacingLabel "left" 0   
      -af slSpacingDownButton "top" 16	-af slSpacingDownButton "left" 38 
      -af slSpacingFloat "top" 17	-af slSpacingFloat "left" 58
      -af slSpacingUpButton "top" 16	-af slSpacingUpButton "left" 98
      -af slOffsetLabel "top" 42	-af slOffsetLabel "left" 0        
      -af slOffsetDownButton "top" 40	-af slOffsetDownButton "left" 38 
      -af slOffsetFloat "top" 41	-af slOffsetFloat "left" 58
      -af slOffsetUpButton "top" 40	-af slOffsetUpButton "left" 98
      -af slSwapButton "top" 66	    -af slSwapButton "left" 48
      -af slGrowButton "top" 66     -af slGrowButton "left" 80
      -af slCancelButton "top" 104  -af slCancelButton "left" 50
  toolXOver;   
}



global proc selectHardSoft(int $hardEdge)
{ // uses the constrait slect tool to select hard or soft edges
   string $shapeBuffer[];
   if ($hardEdge)
     polySelectConstraint -m 3 -t 0x8000 -sm 1;
   else
     polySelectConstraint -m 3 -t 0x8000 -sm 2;  
   string $selectedEdges[] = `ls -sl -fl`;  
   polySelectConstraint -sm 0;
  // get object Name 
   tokenize($selectedEdges[0],".",$shapeBuffer);
  //select shape and go to right mode 
   string $shapeName = $shapeBuffer[0];
   hilite $shapeName;
   selectMode -component; 
   selectType -allComponents 0 -polymeshEdge 1; //set select type to edges
  // select edges
   select -r $selectedEdges;  
}



global proc setAltToggleEdgeOverlay (int $altOn)
{// set or returns Toggle Edge Overlay to or from hard/soft selection - or making hard/soft edges
  if ($altOn)
  {
    button -e -c "selectHardSoft(0); toggleEdgeOverlay(0)" teSoftButton;
    button -e -c "selectHardSoft(1); toggleEdgeOverlay(0)" teHardButton;
  }  
  else
  {
    button -e -c "polySoftEdge -a 180; select -cl; toggleEdgeOverlay(0)" teSoftButton;
    button -e -c "polySoftEdge -a 0;   select -cl; toggleEdgeOverlay(0)" teHardButton;
  }
}


global proc buildToggleEdgeOverlay()
{ //builds buttons for overlay when edge toggle select is over 1000
  button -vis 0 -l "Soft" -w 40 -h 20 -c "polySoftEdge -a 180; select -cl; toggleEdgeOverlay(0)" teSoftButton;
  button -vis 0 -l "Hard" -w 40 -h 20 -c "polySoftEdge -a 0; select -cl; toggleEdgeOverlay(0)" teHardButton;
  button -vis 0 -l "Cancel" -w 60 -h 20 -c "toggleEdgeOverlay(0);" teCancelButton;
 // layout for Direction overlay 
  formLayout -e      
    -af teSoftButton   "top" 20  -af teSoftButton "left" 70
    -af teHardButton   "top" 40  -af teHardButton "left" 70
    -af teCancelButton "top" 104 -af teCancelButton "left" 60
  toolXOver;     
}


global proc reverseGeometry() 
{//reverses geometry whether nurb, poly or SubDiv
  string $selObjects[] = `ls -sl`;
  for ($obj in $selObjects)
  {// get shape Node
    string $shapes[] = `listRelatives -s $obj`;
    string $shapeType = `nodeType $shapes[0]`;
   // reverse command based on type
    switch ($shapeType)
    {
      case "nurbsSurface":  reverseNurb;   break;
      case "nurbsCurve":    reverseNurb;   break;     
      case "mesh":          ReversePolygonNormals; select -r $selObjects; break; 
      case "subdiv":        ReversePolygonNormals; select -r $selObjects; break;       
    }
  }
}


global proc buildMirrorDuplicateOverlay()
{ // builds mirror Duplicate Overlay 
  text   -vis 0 -l "Copy" mirrorCopyLabel;
  button -vis 0 -l "X" -w 32 -h 32 -c "duplicate -rr; scale -r -1 1 1; FreezeTransformations; reverseGeometry; mirrorDuplicateOverlay(0)" xMirrorCopyButton;
  button -vis 0 -l "Y" -w 32 -h 32 -c "duplicate -rr; scale -r 1 -1 1; FreezeTransformations; reverseGeometry; mirrorDuplicateOverlay(0)" yMirrorCopyButton;
  button -vis 0 -l "Z" -w 32 -h 32 -c "duplicate -rr; scale -r 1 1 -1; FreezeTransformations; reverseGeometry; mirrorDuplicateOverlay(0)" zMirrorCopyButton;
  text   -vis 0 -l "Inst" mirrorInstLabel;  
  button -vis 0 -l "X" -w 32 -h 32 -c "instance; scale -r -1 1 1; mirrorDuplicateOverlay(0)" xMirrorInstButton;
  button -vis 0 -l "Y" -w 32 -h 32 -c "instance; scale -r 1 -1 1; mirrorDuplicateOverlay(0)" yMirrorInstButton;
  button -vis 0 -l "Z" -w 32 -h 32 -c "instance; scale -r 1 1 -1; mirrorDuplicateOverlay(0)" zMirrorInstButton;
  button -vis 0 -l "Cancel" -w 60 -h 20 -c "mirrorDuplicateOverlay(0)" mdCancelButton;  
 // layout for Direction overlay 
  formLayout -e      
    -af mirrorCopyLabel  "top"  20 -af mirrorCopyLabel   "left" 2
    -af xMirrorCopyButton "top" 16 -af xMirrorCopyButton "left" 32
    -af yMirrorCopyButton "top" 16 -af yMirrorCopyButton "left" 64
    -af zMirrorCopyButton "top" 16 -af zMirrorCopyButton "left" 96
    -af mirrorInstLabel  "top"  52 -af mirrorInstLabel   "left" 2    
    -af xMirrorInstButton "top" 48 -af xMirrorInstButton "left" 32
    -af yMirrorInstButton "top" 48 -af yMirrorInstButton "left" 64
    -af zMirrorInstButton "top" 48 -af zMirrorInstButton "left" 96
    -af mdCancelButton "top" 104  -af mdCancelButton "left" 50
  toolXOver;   
}


global proc string moveString()
{ // return the right move center command for both component and object selections
  string $currentSelection[] = `ls -sl`;
  if (`gmatch $currentSelection[0] "*.*"`) // Is it a shape?
    return "move ";
  else
    return "move -rpr ";
}


global proc buildCenterButtonOverlay()
{ // builds buttons and for chosen a cardinal direction

  button -vis 0 -l "X" -w 32 -h 32 -c "eval (moveString() + \" -x 0\"); centerButtonOverlay(0)" xCenButton;
  button -vis 0 -l "Y" -w 32 -h 32 -c "eval (moveString() + \" -y 0\"); centerButtonOverlay(0)" yCenButton;
  button -vis 0 -l "Z" -w 32 -h 32 -c "eval (moveString() + \" -z 0\"); centerButtonOverlay(0)" zCenButton;
  button -vis 0 -l "XY" -w 32 -h 32 -c "eval (moveString() + \" -x -y 0\"); centerButtonOverlay(0)" xyCenButton;
  button -vis 0 -l "YZ" -w 32 -h 32 -c "eval (moveString() + \" -x -z 0\"); centerButtonOverlay(0)" yzCenButton;
  button -vis 0 -l "ZX" -w 32 -h 32 -c "eval (moveString() + \" -y -z 0\"); centerButtonOverlay(0)" zxCenButton;
  button -vis 0 -l "Origin" -w 60 -h 20 -c "eval (moveString() + \" 0 0 0\"); centerButtonOverlay(0)" originCenButton;  
  button -vis 0 -l "Cancel" -w 60 -h 20 -c "centerButtonOverlay(0)" cCancelButton;
 // layout for Direction overlay 
  formLayout -e              
    -af xCenButton "top" 16	-af xCenButton "left" 32
    -af yCenButton "top" 16     -af yCenButton "left" 64
    -af zCenButton "top" 16	-af zCenButton "left" 96
    -af xyCenButton "top" 48     -af xyCenButton "left" 32
    -af yzCenButton "top" 48	-af yzCenButton "left" 64
    -af zxCenButton "top" 48     -af zxCenButton "left" 96
    -af originCenButton "top" 82  -af originCenButton "left" 50 
    -af cCancelButton "top" 104  -af cCancelButton "left" 50
  toolXOver;    
}


global proc buildNormalDisplayOverlay()
{// builds buttons and slider for adjusting normal display
  global string $iconPath; 
  float $currentLength[] = `polyOptions -q -sn`;
  floatSlider -vis 0 -w 124 -h 20 -min 0 -max 1 -value $currentLength[0] -step 0.05 -dc changeNormalValue nLengthSlider;  
  shelfButton -vis 0 -image ($iconPath + "togglenormal.xpm") -h 32 -w 32 -ann "Toggle Normal Display" -c "ToggleFaceNormals" nDisplayButton; 
  button -vis 0 -l "Done" -w 64 -h 20 -c "normalDisplayOverlay(0)" nDoneButton;
 // layout for Normal overlay 
  formLayout -e              
    -af nLengthSlider "top" 6	-af nLengthSlider "left" 0
    -af nDisplayButton "top" 0  -af nDisplayButton "left" 128 
    -af nDoneButton "top" 32  -af nDoneButton "left" 32
  toolXOver;    
}


global proc buildRandomSelectOverlay()
{ // builds Random Selection button overlay 
  floatSlider -vis 0 -w 160 -h 20 -min 0.00 -max 1.00 -value 0.35 -step 0.01 -dc selectRadPoly rValueSlider;  
  button -vis 0 -l "Done" -w 40 -h 20 -c "randomSelectOverlay(0)" rDoneButton;
  formLayout -e              
    -af rValueSlider "top" 6  -af rValueSlider "left" 0
    -af rDoneButton "top" 32  -af rDoneButton "left" 70
  toolXOver;  
}


global proc resetXButtons()
{ //return buttons out of highlighted state 
  global int $shelfSet;
  for ($xbutton=1;$xbutton<21;$xbutton++)
    shelfButton -e -en 1 ("xbutton"+$xbutton);    
  switch ($shelfSet)
  {
     case 1: setPolyTools; break;
     case 2: setNurbTools; break;
     case 3: setGeneralTools; break;
  }
}


global proc hightLightXButton(int $button)
{ // disables all buttons except the highted one
  // Highlighted button has one function - to return a normal mode after been selected
  window -e -t "Click to Continue" xToolsWindow;
  for ($xbutton=1;$xbutton<21;$xbutton++)
  {
    if ($xbutton==$button)
      shelfButton -e -c "resetXButtons" ("xbutton"+$xbutton);      
    else 
      shelfButton -e -en 0 ("xbutton"+$xbutton);   
  }
}


global proc xFindButton (int $funcIndex)
{ // selects the appropiate shelf and highlights the appropiate button - a click ends the function
 // allow displays help on the button via the xHelpButton
 //find functions match shelf/ui and button number
  global int $shelfSet;
  int $matchingUI =  xFindUI($funcIndex);
  int $matchingNum = xFindNumber($funcIndex);
  print ($matchingUI+" "+$matchingNum+"\n");
 // switch shelf is necessary to match button
 if ($matchingUI<10) // button is only on one shelf
   if ($matchingUI!= $shelfSet)
     switch ($matchingUI)
     {
       case 1: setPolyTools; break;
       case 2: setNurbTools; break;
       case 3: setGeneralTools; break;
     }
    else; // dummy Else
  else if (($matchingUI==30)&&($shelfSet==3)) // if current UI is general and button is not then default to polyTools
    setPolyTools;
  hightLightXButton($matchingNum); 
 // display for match button is the script area
  if ($matchingUI > 9) // if number indicates that button is available on multiply shelfs then default to 1 
    $matchingUI = 1;
  print (($matchingUI-1)*20+$matchingNum);
  xHelpButton(($matchingUI-1)*20+$matchingNum,1);
}


global proc buildHelplistOverlay()
{ // builds Help List button overlay 
    string $commandList[] = 
                   {"Active Rigid     ", "Add Emmiter,Fluid", "Affect Selected  ", "Aim Constraint   ",                    
                    "Align to Object  ", "Align to Sel.    ", "Align to World   ", "All Hard (Edges) ", 
                    "All Soft (Edges) ", "Ambient Light    ", "Ansiotrophic Shdr", "Append to Polygon",
                    "Area Light       ", "Attach Curve     ", "Attach Surface   ", "Average Vertices ",
                    "BackFaces Display", "Bend Deformer    ", "Bevel Edge       ", "Birail 1,2 & 3   ",
                    "Bind Skin        ", "Blinn Shader     ", "Border Edge Disp ", "Border Edges (N )",
                    "Border Edges (P )", "Boundary         ", "Break Light Links", "Cam/ImagePln. Dis",
                    "Center Selection ", "Center Pivot     ", "Chamfer Vertex   ", "Close Curve      ",
                    "Collapse         ", "Collide, Fluid   ", "Collide, Particle", "Collision Event  ",
                    "Combine          ", "Component Editor ", "Comp 2 Comp Const", "Conform Normals  ",
                    "Convert to Curve ", "Convert to Face  ", "Convert FacePath ", "Convert to Poly,N",
                    "Convert to Poly,B", "Convert to Vert. ", "Copy Skin Weights", "Crease Edge      ", 
                    "Create Circle    ", "Create Curve     ", "Create Fluid 2D  ", "Create Fluid 3D  ", 
                    "Create Nurb Shape", "Create Poly.     ", "Create Poly. Shp.", "Cur. Brush Settin", 
                    "Curve Display    ", "CV Display       ", "CV Curve Tool    ", "Cylinder Map     ", 
                    "Delete All Hist. ", "Delete Edge      ", "Delete Empty Grp ", "Delete Half      ",                  
                    "Delete History   ", "Delete Hist. Shp.", "Delete ImagePlane", "Delete Loop      ",                
                    "Del. Unused Shdrs", "Detach Curve     ", "Detach Surface   ", "Detach Skin      ",
                    "Directional Light", "Display Modes    ", "Draw Joints      ", "Duplicate        ",                  
                    "Duplicate Special", "Dyn. Relationship", "Emit from Shape  ", "EP Curve Tool    ",
                    "Extract Face     ", "Extract Dup. Face", "Extrude Face/Edge", "Exturde on Cur(P)", 
                    "Extrude on Cur(N)", "Face Centers Disp", "Flare Deformer   ", "Flip Edge        ", 
                    "Flip Normal      ", "Fluid Shape      ", "Freeze Transforms", "Fur Description  ", 
                    "Geom. Constraint ", "Go to Bind Pose  ", "Goal, Particle   ", "Gravity Field    ",
                    "Group            ", "Grow Loop/Ring   ", "Hair System      ", "Hinge Constraint ",
                    "Hull Display     ", "HyperShader      ", "IK Handle        ", "IK Spline Handle ",	
                    "Insert Loop Tool ", "Insert Joint     ", "Insert Knot      ", "Insert Iso-Parm  ",
                    "Joint Radius  set", "Lasso Tool       ", "Lambert Shader   ", "Layered Shader   ",
                    "Link Editor Light", "Local Axles Disp.", "Loft             ", "Make Curve Dyn.  ",
                    "Make Links Lights", "Make Paintable   ", "Merge Vertice    ", "Merge to Center  ",
                    "Merge Edge Tool  ", "Mirror Duplicate ", "Mirror Geometry  ", "Mirror Joints    ",
                    "Mirror Skin Wghts", "N-Cloth          ", "N_Rigid/Passive  ", "Nail Constraint  ",
                    "Newton Field     ", "Normal Constraint", "Normal Length    ", "Normal Dis.(Nurb)",
                    "Normal Dis.(Poly)", "Object Display   ", "Orient Contraint ", "Orient Joint     ",
                    "Paint Follicles  ", "Paint Fluid Attr.", "Paint Fur        ", "Paint N-Cloth Att",
                    "Paint Select     ", "Paint SoftBody W.", "Particle Emitter ", "Particle Instance",
                    "Particle Tool    ", "Parent           ", "Parent Constraint", "Passive Rigid    ",
                    "Phong Shader     ", "Phong E Shader   ", "Pin Constraint   ", "Planar Map       ",
                    "Prefix Joints    ", "Point Constraint ", "Point Light      ", "Point to Surface ", 
                    "Pune Skin Weights", "Radial Field     ", "Reverse Edge     ", "Rigid Body       ",
                    "Rigid Bind       ", "Search/Replace   ", "Sel. All Edges(N)", "Sel. Brdr Edge  N",
                    "Sel. Brdr Edge  P", "Sel. Border Edges", "Sel. Border Vert.", "Sel. Border      ",                  
                    "Sel. Border Path ", "Sel. Border Patt.", "Sel. Border Vert.", "Sel. Flipped Norm",
                    "Sel. Half        ", "Sel. Hard/Soft   ", "Sel. Lamina Faces", "Sel. Loop        ",
                    "Sel. Loop Path   ", "Sel. Loop Pattern", "Sel. Non-Tri Face", "Sel. N-Gon Faces ",                
                    "Sel. Poles       ", "Sel. Quad Faces  ", "Sel. Random Faces", "Sel. Ring        ",
                    "Sel. Ring Path   ", "Sel. Ring Patern ", "Sel. Stars       ", "Sel. Tri. Faces  ", 
                    "Sel. UnMerged Edg", "Sel. Winged Int V", "Sel. Winged Vert.", "Sine Deformer    ", 
                    "Smooth Bind      ", "Soft Body        ", "Soft Edge Disp.  ", "Spin Edge        ", 
                    "Spherical Map    ", "Split Edge (Half)", "Split Ring Tool  ", "Spring Constraint", 
                    "Springs          ", "Spot Light       ", "Squash Deformer  ", "Stand on Grid    ", 
                    "Surface Display  ", "Surface Patch Dis", "Trans. Constraint", "Turbulence Field ", 
                    "Twist Deformer   ", "Uniform Field    ", "UV Editor        ", "Vertice Display  ",
                    "Visor Editor     ", "Volume Axis Field", "Volume Light     ", "Wave Deformer    ",                 
                    "Wireframe Display", "WholeFace Select ", "X-ray Display    "
                    };
                    
  textScrollList -vis 0 -w 90 -h 100
    -numberOfRows 6 -allowMultiSelection false 
    -showIndexedItem 1 helpList;
 // build list
  for ($command in $commandList)
    textScrollList -e -append $command helpList;
  button -vis 0 -width 60 -height 20 -label "Find" -align "center"
    -command "helpListOverlay(0); int $listIndex[] = `textScrollList -q -sii helpList`; xFindButton($listIndex[0]);" findButton;  // finds matching help
  button -vis 0 -width 60 -height 20 -label "Done" 
    -command "helpListOverlay(0)" helpCloseButton;   // closes interface
  formLayout -e              
  	-af "helpList" "left" 2 
  	-af "helpList" "top" 2
        -ac "findButton" "top" 2 "helpList"  	
  	-af "findButton" "left" 2 
  	-ac "helpCloseButton" "top" 2 "helpList"  
	-af "helpCloseButton" "right" 2	
  toolXOver;  
}


global proc buildFaceSelectOverlay()
{ // builds Face Selection button overlay 
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "faceSelectOverlay(0)" fSelectCancelButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "select3face" + ".xpm") 
    -ann "Select Triangles" -command "selectSpecialFaces(1); faceSelectOverlay(0)" fTriButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "select4face" + ".xpm")  
    -ann "Select Quads" -command "selectSpecialFaces(2); faceSelectOverlay(0)" fQuadButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "select4plusface" + ".xpm")  
    -ann "Select N-Gons" -command "selectSpecialFaces(3); faceSelectOverlay(0)" fNgonButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "nontriangle" + ".xpm") 
    -ann "Select Untriangulatable" -command "selectSpecialFaces(4); faceSelectOverlay(0)" fUntriButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "laminaface" + ".xpm") 
    -ann "Lamina Faces" -command "selectSpecialFaces(5); faceSelectOverlay(0)" fLaminaButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "randompoly" + ".xpm") 
    -ann "Random Face" -command "faceSelectOverlay(0); randomSelectOverlay(1)" fRandomButton;      
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "borderedges.xpm")     
    -ann "Border Edges" -c "selectSpecialEdges(1); faceSelectOverlay(0)" bEdgeButton;     
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "unsharededges.xpm")     
    -ann "Unshared Edges" -c "select2EdgedBrdr; faceSelectOverlay(0)" unSharedEdgeButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "unsharedverts.xpm")     
    -ann "Unmerged Vertices" -c "selectUnMergedVerts; faceSelectOverlay(0)" unSharedVertButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "borderverts.xpm")     
    -ann "Border Vertices" -c "selectSpecialVertice(0,0); faceSelectOverlay(0)" bVertButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "nonborderverts.xpm")     
    -ann "Internal Vertices" -c "selectSpecialVertice(1,0); faceSelectOverlay(0)" inVertButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "cornerverts.xpm")     
    -ann "Corner Vertices" -c "selectSpecialVertice(2,1); faceSelectOverlay(0)" cVertButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "select2verts.xpm")     
    -ann "Winged Vertices" -c "selectSpecialVertice(2,0); faceSelectOverlay(0)" wVertButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "select3verts.xpm")     
    -ann "Tri Pole Vertices" -c "selectSpecialVertice(3,0); faceSelectOverlay(0)" pVertButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "select5verts.xpm")     
    -ann "5 Star Vertices" -c "selectSpecialVertice(5,0); faceSelectOverlay(0)" sVertButton;    
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "select6plusverts.xpm")     
    -ann "N Star Vertices" -c "selectSpecialVertice(6,0); faceSelectOverlay(0)" nsVertButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "selecthardsoft.xpm")     
    -ann "Hard or Soft Edges" -c "setAltToggleEdgeOverlay(1); faceSelectOverlay(0); toggleEdgeOverlay(1);" hardsoftSelectButton;               
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "selectunflippededges.xpm")  
    -ann "Unflipped Edges" -c "selectFlippedEdge; faceSelectOverlay(0);" unflippedButton;               
    
 // layout for special Component overlay
   formLayout -e       
    // cancel button
     -af fSelectCancelButton "top" 104 -af fSelectCancelButton "left" 110 
     -af fTriButton "top" 0 	-af fTriButton "left" 0 
     -af fQuadButton "top" 0	-af fQuadButton "left" 32 
     -af fNgonButton "top" 0 	-af fNgonButton"left" 64 
     -af fUntriButton "top" 0   -af fUntriButton "left" 96 
     -af fLaminaButton "top" 0	-af fLaminaButton "left" 128 
     -af fRandomButton "top" 32 -af fRandomButton "left" 0      
     -af bEdgeButton "top" 32   -af bEdgeButton "left" 32           
     -af unSharedEdgeButton "top" 32   -af unSharedEdgeButton "left" 64  
     -af unSharedVertButton "top" 32   -af unSharedVertButton "left" 96           
     -af bVertButton "top" 32   -af bVertButton "left" 128      
     -af inVertButton "top" 64  -af inVertButton "left" 0  
     -af cVertButton "top" 64   -af cVertButton "left" 32  
     -af wVertButton "top" 64   -af wVertButton "left" 64
     -af pVertButton "top" 64   -af pVertButton "left" 96
     -af sVertButton "top" 64   -af sVertButton "left" 128  
     -af nsVertButton "top" 96  -af nsVertButton "left" 0      
     -af hardsoftSelectButton "top" 96  -af hardsoftSelectButton "left" 32      
     -af unflippedButton "top" 96  -af unflippedButton "left" 64        
  toolXOver;  
}


global proc buildPolyShapeOverlay()
{ // builds poly shape button overlay 
  global int $isMaya8Plus; 
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "polyShapeOverlay(0)" pShapeCancelButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "pcube" + ".xpm") 
    -ann "Poly Cube" -command "CreatePolygonCube; copyShelfButton(\"pCubeButton\",\"xbutton16\"); polyShapeOverlay(0)" pCubeButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "pplane" + ".xpm")  
    -ann "Poly Plane" -command "CreatePolygonPlane; copyShelfButton(\"pPlaneButton\",\"xbutton16\"); polyShapeOverlay(0)" pPlaneButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "psphere" + ".xpm")  
    -ann "Poly Sphere"-command "CreatePolygonSphere; copyShelfButton(\"pSphereButton\",\"xbutton16\"); polyShapeOverlay(0)" pSphereButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "pcylinder" + ".xpm") 
    -ann "Poly Cylinder" -command "CreatePolygonCylinder; copyShelfButton(\"pCylinderButton\",\"xbutton16\"); polyShapeOverlay(0)" pCylinderButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "pcone" + ".xpm") 
    -ann "Poly Cone" -command "CreatePolygonCone; copyShelfButton(\"pConeButton\",\"xbutton16\"); polyShapeOverlay(0)" pConeButton; 
  if ($isMaya8Plus)
    shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "psoccerball" + ".xpm") 
      -ann "Poly Soccer Ball" -command "CreatePolygonSoccerBall; copyShelfButton(\"pSoccerButton\",\"xbutton16\"); polyShapeOverlay(0)" pSoccerButton;  
  else 
    shelfButton -vis 0 -h 32 -w 32 -image ""
      -ann "" -command "" pSoccerButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "ptorus" + ".xpm") 
    -ann "Poly Torus" -command "CreatePolygonTorus; copyShelfButton(\"pTorusButton\",\"xbutton16\"); polyShapeOverlay(0)" pTorusButton;      
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "ppyramid" + ".xpm") 
     -ann "Poly Pyramid" -command "CreatePolygonPyramid; copyShelfButton(\"pPyramidButton\",\"xbutton16\"); polyShapeOverlay(0)" pPyramidButton;         
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "ppipe" + ".xpm") 
    -ann "Poly Pipe" -command "CreatePolygonPipe; copyShelfButton(\"pPipeButton\",\"xbutton16\"); polyShapeOverlay(0)" pPipeButton; 
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "phelix" + ".xpm") 
     -ann "Poly Helix" -command "CreatePolygonHelix; copyShelfButton(\"pHelixButton\",\"xbutton16\"); polyShapeOverlay(0)" pHelixButton;    
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "sculptprim" + ".xpm") 
     -ann "Sculpt Primitive" -command "createSculptPrimitive; copyShelfButton(\"sculptPrimButton\",\"xbutton16\"); polyShapeOverlay(0)" sculptPrimButton;  
  if ($isMaya8Plus)    
    shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "pplatonic" + ".xpm") 
      -ann "Platonic Solids ..." -command "CreatePlatonicSolidOptions; copyShelfButton(\"pPlatonicButton\",\"xbutton16\"); polyShapeOverlay(0)" pPlatonicButton;  
  else 
    shelfButton -vis 0 -h 32 -w 32 -image ""
      -ann "" -command "" pPlatonicButton;  
 // layout for poly Shape overlay 
  formLayout -e       
   // cancel button
    -af pShapeCancelButton "top" 104	-af pShapeCancelButton "left" 70 
    -af pCubeButton "top" 0 	-af pCubeButton "left" 0 
    -af pPlaneButton "top" 0	-af pPlaneButton "left" 32 
    -af pSphereButton "top" 0 	-af pSphereButton "left" 64 
    -af pCylinderButton "top" 0	-af pCylinderButton "left" 96 
    -af pConeButton "top" 0	-af pConeButton "left" 128 
    -af pTorusButton "top" 32 	-af pTorusButton "left" 0 
    -af pPyramidButton "top" 32	-af pPyramidButton "left" 32 
    -af pPipeButton "top" 32 	-af pPipeButton "left" 64 
    -af pHelixButton "top" 32   -af pHelixButton "left" 96 
    -af sculptPrimButton "top" 32 -af sculptPrimButton "left" 128
    -af pSoccerButton "top" 64 	-af pSoccerButton "left" 0 
    -af pPlatonicButton "top" 64 -af pPlatonicButton "left" 32     
  toolXOver;  
}


global proc buildEdgeToolOverlay()
{ // builds Face Selection button overlay 
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "edgeToolOverlay(0)" eToolCancelButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "splitpoly" + ".xpm") 
    -ann "Split Polygon" -command "SplitPolygonTool; copyShelfButton(\"ePolyButton\",\"xbutton7\"); edgeToolOverlay(0)" ePolyButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "splitedgering" + ".xpm")  
    -ann "Insert Edge" -command "uberSplitEdge; copyShelfButton(\"eInsertButton\",\"xbutton7\"); edgeToolOverlay(0)" eInsertButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "offsetedge" + ".xpm")  
    -ann "Offset Edge" -command "DuplicateEdges; copyShelfButton(\"eOffsetButton\",\"xbutton7\"); edgeToolOverlay(0)" eOffsetButton; 
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "radialsplit" + ".xpm")  
    -ann "Radial Split" -command "turnOffToolMessages; radialEdgeSplit; restoreToolMessagesSettings; copyShelfButton(\"eRadialButton\",\"xbutton7\"); edgeToolOverlay(0)" eRadialButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "cutfaces" + ".xpm") 
    -ann "Cut Face" -command "CutPolygon; copyShelfButton(\"eCutButton\",\"xbutton7\"); edgeToolOverlay(0)" eCutButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "flipedge" + ".xpm") 
    -ann "Flip Edge" -command "polyFlipEdge; copyShelfButton(\"eFlipButton\",\"xbutton7\"); edgeToolOverlay(0)" eFlipButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "spinedge" + ".xpm") 
    -ann "Spin Edge" -command "xSpinChoser; copyShelfButton(\"eSpinButton\",\"xbutton7\"); edgeToolOverlay(0);" eSpinButton;         
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "beveledge" + ".xpm") 
    -ann "Bevel Edge" -command "polyBevel; copyShelfButton(\"eBevelButton\",\"xbutton7\"); edgeToolOverlay(0)" eBevelButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "quadfrom35" + ".xpm") 
    -ann "3 5 to Quad" -command "quadsFrom35Edge; copyShelfButton(\"e35QuadButton\",\"xbutton7\"); edgeToolOverlay(0);" e35QuadButton;  
 // layout for edge tool overlay
   formLayout -e       
    // cancel button
     -af eToolCancelButton "top" 104 -af eToolCancelButton "left" 70 
     -af ePolyButton "top" 0 	-af ePolyButton "left" 0 
     -af eInsertButton "top" 0	-af eInsertButton "left" 32 
     -af eOffsetButton "top" 0	-af eOffsetButton "left" 64      
     -af eRadialButton "top" 0 	-af eRadialButton "left" 96 
     -af eCutButton "top" 0 -af eCutButton "left" 128 
     -af eFlipButton "top" 32 -af eFlipButton "left" 0 
     -af eSpinButton "top" 32 -af eSpinButton "left" 32
     -af eBevelButton "top" 32 -af eBevelButton "left" 64      
     -af e35QuadButton "top" 32 -af e35QuadButton "left" 96      
  toolXOver;  
}


global proc buildFaceToolOverlay()
{ // builds Face Selection button overlay 
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "faceToolOverlay(0)" fToolCancelButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "fillhole" + ".xpm") 
    -ann "Fill Hole" -command "FillHole; faceToolOverlay(0)" fHoleButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xbridge" + ".xpm")  
    -ann "Bridge" -command "BridgeEdge; faceToolOverlay(0)" fBridgeButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "poke" + ".xpm")  
    -ann "Poke Face" -command "PokePolygon; faceToolOverlay(0)" fPokeButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "trilate" + ".xpm") 
    -ann "Trilate" -command "Triangulate; faceToolOverlay(0)" fTrilateButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "quadlate" + ".xpm") 
    -ann "Quadilate" -command "Quadrangulate; faceToolOverlay(0)" fQuadlateButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "wedge" + ".xpm") 
    -ann "Wedge" -command "WedgePolygon; faceToolOverlay(0);" fWedgeButton;         
 // layout for special Component overlay
   formLayout -e       
    // cancel button
     -af fToolCancelButton "top" 104 -af fToolCancelButton "left" 70 
     -af fHoleButton "top" 0 	-af fHoleButton "left" 0 
     -af fBridgeButton "top" 0	-af fBridgeButton "left" 32 
     -af fPokeButton"top" 0 	-af fPokeButton"left" 64 
     -af fTrilateButton "top" 0 -af fTrilateButton "left" 96 
     -af fQuadlateButton "top" 0 -af fQuadlateButton "left" 128 
     -af fWedgeButton "top" 32 -af fWedgeButton "left" 0 
  toolXOver;  
}


global proc buildCurveToolOverlay()
{ // builds Curve Tool button overlay 
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "curveToolOverlay(0)" cToolCancelButton; 
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "newcurve.xpm") 
    -ann "New Curve" -command "uberNewCurve; copyShelfButton(\"cNewCurve\",\"xbutton9\"); curveToolOverlay(0)" -doubleClickCommand "EPCurveToolOptions;" cNewCurve;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xepcurve" + ".xpm") 
    -ann "EP Curve" -command "EPCurveTool; copyShelfButton(\"cEPcurveButton\",\"xbutton9\"); curveToolOverlay(0)" cEPcurveButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xcvcurve" + ".xpm")  
    -ann "CV Curve" -command "CVCurveTool; copyShelfButton(\"cCVcurveButton\",\"xbutton9\"); curveToolOverlay(0)" cCVcurveButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xpencil" + ".xpm")  
    -ann "Pencil Tool" -command "PencilCurveTool; copyShelfButton(\"cPencilButton\",\"xbutton9\"); curveToolOverlay(0)" cPencilButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "x2ptarc" + ".xpm") 
    -ann "2 Point Arc" -command "TwoPointArcTool; copyShelfButton(\"c2PtArcButton\",\"xbutton9\"); curveToolOverlay(0)" c2PtArcButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "x3ptarc" + ".xpm") 
    -ann "3 Point Arc" -command "ThreePointArcTool; copyShelfButton(\"c3PtArcButton\",\"xbutton9\"); curveToolOverlay(0)" c3PtArcButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "circle" + ".xpm") 
    -ann "Circle" -command "CreateNURBSCircle; copyShelfButton(\"cCircleButton\",\"xbutton9\"); curveToolOverlay(0);" cCircleButton;
 // layout for Curve overlay
   formLayout -e       
    // cancel button
     -af cToolCancelButton "top" 104 -af cToolCancelButton "left" 70 
     -af cNewCurve "top" 0 -af cNewCurve "left" 0 
     -af cEPcurveButton "top" 0 -af cEPcurveButton "left" 32 
     -af cCVcurveButton "top" 0	-af cCVcurveButton "left" 64 
     -af cPencilButton "top" 0 -af cPencilButton "left" 96 
     -af c2PtArcButton "top" 0 -af c2PtArcButton "left" 128 
     -af c3PtArcButton "top" 32 -af c3PtArcButton "left" 0 
     -af cCircleButton "top" 32 -af cCircleButton  "left" 32
  toolXOver;  
}     


global proc buildNurbToolOverlay()
{ // builds Nurb Tool button overlay 
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "nurbToolOverlay(0)" nToolCancelButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xloft" + ".xpm") 
    -ann "Loft" -command "Loft; copyShelfButton(\"nLoftButton\",\"xbutton8\"); nurbToolOverlay(0)" nLoftButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xextrude" + ".xpm")  
    -ann "Extrude" -command "Extrude; copyShelfButton(\"nExtrudeButton\",\"xbutton8\"); nurbToolOverlay(0)" nExtrudeButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xrevolve" + ".xpm")  
    -ann "Revolve" -command "Revolve; copyShelfButton(\"nRevolveButton\",\"xbutton8\"); nurbToolOverlay(0)" nRevolveButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xboundary" + ".xpm") 
    -ann "Boundary" -command "Boundary; copyShelfButton(\"nBoundaryButton\",\"xbutton8\"); nurbToolOverlay(0)" nBoundaryButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xsquare" + ".xpm") 
    -ann "Square" -command "SquareSurface; copyShelfButton(\"nSquareButton\",\"xbutton8\"); nurbToolOverlay(0)" nSquareButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xbirail1" + ".xpm") 
    -ann "Birail 1" -command "Birail1; copyShelfButton(\"nBirail1Button\",\"xbutton8\"); nurbToolOverlay(0);" nBirail1Button;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xbirail2" + ".xpm") 
    -ann "Birail 2" -command "Birail2; copyShelfButton(\"nBirail2Button\",\"xbutton8\"); nurbToolOverlay(0);" nBirail2Button;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xbirail3" + ".xpm") 
    -ann "Birail 3" -command "Birail3; copyShelfButton(\"nBirail3Button\",\"xbutton8\"); nurbToolOverlay(0);" nBirail3Button;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xplanar" + ".xpm") 
    -ann "Planar" -command "Planar; copyShelfButton(\"nPlanarButton\",\"xbutton8\"); nurbToolOverlay(0);" nPlanarButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "bevelplus" + ".xpm") 
    -ann "Bevel Plus" -command "BevelPlus; copyShelfButton(\"nBevelPlusButton\",\"xbutton8\"); nurbToolOverlay(0);" nBevelPlusButton;
 // layout for Nurb overlay
   formLayout -e       
    // cancel button
     -af nToolCancelButton "top" 104 -af nToolCancelButton "left" 70 
     -af nLoftButton "top" 0 	-af nLoftButton "left" 0 
     -af nExtrudeButton "top" 0	-af nExtrudeButton "left" 32 
     -af nRevolveButton "top" 0 -af nRevolveButton "left" 64 
     -af nBoundaryButton "top" 0 -af nBoundaryButton "left" 96 
     -af nSquareButton "top" 0 -af nSquareButton "left" 128 
     -af nBirail1Button "top" 32 -af nBirail1Button "left" 0
     -af nBirail2Button "top" 32 -af nBirail2Button "left" 32
     -af nBirail3Button "top" 32 -af nBirail3Button "left" 64
     -af nPlanarButton "top" 32 -af nPlanarButton "left" 96
     -af nBevelPlusButton "top" 32 -af nBevelPlusButton "left" 128     
  toolXOver;  
}          


global proc buildNurbShapeOverlay()
{ // builds nurb shape button overlay 
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "nurbShapeOverlay(0)" nShapeCancelButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "nplane" + ".xpm") 
    -ann "Plane" -command "CreateNURBSPlane; copyShelfButton(\"nPlaneButton\",\"xbutton16\"); nurbShapeOverlay(0)" nPlaneButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "nsphere" + ".xpm")  
    -ann "Sphere" -command "CreateNURBSSphere; copyShelfButton(\"nSphereButton\",\"xbutton16\"); nurbShapeOverlay(0)" nSphereButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "ncube" + ".xpm")  
    -ann "Cube" -command "CreateNURBSCube; copyShelfButton(\"nCubeButton\",\"xbutton16\"); nurbShapeOverlay(0)" nCubeButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "cylinder" + ".xpm") 
    -ann "Cylinder" -command "CreateNURBSCylinder; copyShelfButton(\"nCylinderButton\",\"xbutton16\"); nurbShapeOverlay(0)" nCylinderButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "cone" + ".xpm") 
    -ann "Cone" -command "CreateNURBSCone; copyShelfButton(\"nConeButton\",\"xbutton16\"); nurbShapeOverlay(0)" nConeButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "torus" + ".xpm") 
    -ann "Torus" -command "CreateNURBSTorus; copyShelfButton(\"nTorusButton\",\"xbutton16\"); nurbShapeOverlay(0)" nTorusButton;      
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "circle" + ".xpm") 
    -ann "Circle" -command "CreateNURBSCircle; copyShelfButton(\"nCircleButton\",\"xbutton16\"); nurbShapeOverlay(0)" nCircleButton;         
 // layout for poly Shape overlay 
  formLayout -e       
   // cancel button
    -af nShapeCancelButton "top" 104 -af nShapeCancelButton "left" 70 
    -af nCubeButton "top" 0 	-af nCubeButton "left" 0 
    -af nPlaneButton "top" 0	-af nPlaneButton "left" 32 
    -af nSphereButton "top" 0 	-af nSphereButton "left" 64 
    -af nCylinderButton "top" 0	-af nCylinderButton "left" 96 
    -af nConeButton "top" 0	-af nConeButton "left" 128 
    -af nTorusButton "top" 32 	-af nTorusButton "left" 0 
    -af nCircleButton "top" 32	-af nCircleButton "left" 32 
  toolXOver;  
}


global proc buildPolyDisplayOverlay()
{ // builds nurb shape button overlay 
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "polyDisplayOverlay(0)" pDisplayCancelButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglewosnoop" + ".xpm") 
    -ann "Wire on Shaded" -command "toggleWos; copyShelfButton(\"pwosButton\",\"xbutton3\"); polyDisplayOverlay(0)" pwosButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglexray" + ".xpm")  
    -ann "X-Ray" -command "toggleXray; copyShelfButton(\"pxrayButton\",\"xbutton3\"); polyDisplayOverlay(0)" pxrayButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "toggle_is" + ".xpm")  
    -ann "Isolate Selection" -command "isolateSelection; copyShelfButton(\"pisButton\",\"xbutton3\"); polyDisplayOverlay(0)" pisButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "toggle_wholeface" + ".xpm") 
    -ann "Wholeface Selection" -command "toggleFaceSelect; copyShelfButton(\"pwfaceButton\",\"xbutton3\"); polyDisplayOverlay(0)" pwfaceButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "toggle_backface" + ".xpm") 
    -ann "Backface Culling" -command "toggleBFCull; copyShelfButton(\"pbfaceButton\",\"xbutton3\"); polyDisplayOverlay(0)" pbfaceButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglecamera" + ".xpm") 
    -ann "Cameras and ImagePlanes" -command "toggleCamDisplay; copyShelfButton(\"pcamDisplayButton\",\"xbutton3\"); polyDisplayOverlay(0)" pcamDisplayButton;      
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglepolyinfo" + ".xpm") 
    -ann "Poly Info HUD" -command "TogglePolyCount; copyShelfButton(\"pInfoButton\",\"xbutton3\"); polyDisplayOverlay(0)" pInfoButton;         
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "toggleactivexray" + ".xpm") 
    -ann "Xray Active Component" -command "toggleXrayComp; copyShelfButton(\"pActxrayButton\",\"xbutton3\"); polyDisplayOverlay(0)" pActxrayButton;         
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglexrayjoint" + ".xpm") 
    -ann "Xray Joint" -command "ToggleXrayJoint; copyShelfButton(\"pJointxrayButton\",\"xbutton3\"); polyDisplayOverlay(0)" pJointxrayButton;         
 // layout for poly Shape overlay 
  formLayout -e       
   // cancel button
    -af pDisplayCancelButton "top" 104 -af pDisplayCancelButton "left" 70 
    -af pwosButton "top" 0 	-af pwosButton "left" 0 
    -af pxrayButton "top" 0	-af pxrayButton "left" 32 
    -af pisButton "top" 0 	-af pisButton "left" 64 
    -af pwfaceButton "top" 0	-af pwfaceButton "left" 96 
    -af pbfaceButton "top" 0	-af pbfaceButton "left" 128 
    -af pcamDisplayButton "top" 32 -af pcamDisplayButton "left" 0 
    -af pInfoButton "top" 32 -af pInfoButton "left" 32 
    -af pActxrayButton "top" 32 -af pActxrayButton "left" 64     
    -af pJointxrayButton "top" 32 -af pJointxrayButton "left" 96     
  toolXOver;  
}


global proc buildNurbDisplayOverlay()
{ // builds nurb shape button overlay 
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "nurbDisplayOverlay(0)" nDisplayCancelButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglewosnoop" + ".xpm") 
    -ann "Wire on Shaded" -command "toggleWos; copyShelfButton(\"nwosButton\",\"xbutton3\"); nurbDisplayOverlay(0)" nwosButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglexray" + ".xpm")  
    -ann "X-Ray" -command "toggleXray; copyShelfButton(\"nxrayButton\",\"xbutton3\"); nurbDisplayOverlay(0)" nxrayButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglenormals" + ".xpm")  
    -ann "Normals" -command "ToggleNormals; copyShelfButton(\"nnormalsButton\",\"xbutton3\"); nurbDisplayOverlay(0)" nnormalsButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglecv" + ".xpm") 
    -ann "Control Vertices" -command "ToggleCVs; copyShelfButton(\"cvButton\",\"xbutton3\"); nurbDisplayOverlay(0)" cvButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "toggleep" + ".xpm") 
    -ann "Edit Points" -command "ToggleEditPoints; copyShelfButton(\"epButton\",\"xbutton3\"); nurbDisplayOverlay(0)" epButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "toggle_surfacecenter" + ".xpm") 
    -ann "Patch Centers" -command "ToggleSurfaceFaceCenters; copyShelfButton(\"scenterButton\",\"xbutton3\"); nurbDisplayOverlay(0)" scenterButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglecurve" + ".xpm") 
    -ann "Curve Visibility" -command "toggleCurveDisplay; copyShelfButton(\"cDispButton\",\"xbutton3\"); nurbDisplayOverlay(0)" cDispButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglesurface" + ".xpm") 
    -ann "Surface Visibility" -command "toggleSurfaceDisplay; copyShelfButton(\"sDispButton\",\"xbutton3\"); nurbDisplayOverlay(0)" sDispButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglecamera" + ".xpm") 
    -ann "Cameras and ImagePlanes" -command "toggleCamDisplay; copyShelfButton(\"ncamDisplayButton\",\"xbutton3\"); nurbDisplayOverlay(0)" ncamDisplayButton;      
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "togglehull" + ".xpm") 
    -ann "Hulls" -command "ToggleHulls; copyShelfButton(\"hullButton\",\"xbutton3\"); nurbDisplayOverlay(0)" hullButton;         
 // layout for poly Shape overlay 
  formLayout -e       
   // cancel button
    -af nDisplayCancelButton "top" 104 -af nDisplayCancelButton "left" 70 
    -af nwosButton "top" 0 	-af nwosButton "left" 0 
    -af nxrayButton "top" 0	-af nxrayButton "left" 32 
    -af nnormalsButton "top" 0 	-af nnormalsButton "left" 64 
    -af cvButton "top" 0	-af cvButton "left" 96 
    -af epButton "top" 0	-af epButton "left" 128 
    -af hullButton "top" 32 -af hullButton "left" 0 
    -af cDispButton "top" 32 -af cDispButton "left" 32 
    -af sDispButton "top" 32 -af sDispButton "left" 64 
    -af ncamDisplayButton "top" 32 -af ncamDisplayButton "left" 96 
  toolXOver;  
}


global proc buildDeformerOverlay()
{ // builds buttons and gadgets for the deformer
  global string $iconPath;
  button -vis 0 -l "Cancel" -w 40 -h 20 -c "deformerOverlay(0)" deformerCancelButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "bend" + ".xpm") 
    -ann "Bend" -command "Bend; copyShelfButton(\"dBendButton\",\"xbutton12\"); deformerOverlay(0)" dBendButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "flare" + ".xpm")  
    -ann "Flare" -command "Flare; copyShelfButton(\"dFlareButton\",\"xbutton12\"); deformerOverlay(0)" dFlareButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "sine" + ".xpm")  
    -ann "Sine" -command "Sine; copyShelfButton(\"dSineButton\",\"xbutton12\"); deformerOverlay(0)" dSineButton;  
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "sqwash" + ".xpm") 
    -ann "Sqwash" -command "Sqwash; copyShelfButton(\"dSquashButton\",\"xbutton12\"); deformerOverlay(0)" dSquashButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "twist" + ".xpm") 
    -ann "Twist" -command "Twist; copyShelfButton(\"dTwistButton\",\"xbutton12\"); deformerOverlay(0)" dTwistButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "wave" + ".xpm") 
    -ann "Wave" -command "Wave; copyShelfButton(\"dWaveButton\",\"xbutton12\"); deformerOverlay(0)" dWaveButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xcluster" + ".xpm") 
    -ann "Cluster" -command "CreateCluster; copyShelfButton(\"dClusterButton\",\"xbutton12\"); deformerOverlay(0)" dClusterButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xlattice" + ".xpm") 
    -ann "Lattice" -command "CreateLattice; copyShelfButton(\"dLatticeButton\",\"xbutton12\"); deformerOverlay(0)" dLatticeButton;   
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xwrap" + ".xpm") 
    -ann "Wrap" -command "CreateWrap; copyShelfButton(\"dWrapButton\",\"xbutton12\"); deformerOverlay(0)" dWrapButton;      
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "ubertweek" + ".xpm") 
    -ann "Sculpt" -command "deformerOverlay(0); sculptTweek;" -dcc "sculptTweekOptions;" dSculptButton;
  shelfButton -vis 0 -h 32 -w 32 -image ($iconPath + "xsoftmod" + ".xpm") 
    -ann "Soft Mod" -command "deformerOverlay(0); softModTweek;" -dcc "softModTweekOptions;" dSoftmodButton;
 // layout for deformer overlay 
  formLayout -e
    -af deformerCancelButton "top" 104 -af deformerCancelButton "left" 70 
    -af dBendButton "top" 0 	-af dBendButton "left" 0 
    -af dFlareButton "top" 0	-af dFlareButton "left" 32 
    -af dSineButton "top" 0 	-af dSineButton "left" 64 
    -af dSquashButton "top" 0	-af dSquashButton "left" 96 
    -af dTwistButton "top" 0	-af dTwistButton "left" 128 
    -af dWaveButton "top" 32 -af dWaveButton "left" 0 
    -af dClusterButton "top" 32 -af dClusterButton "left" 32 
    -af dLatticeButton "top" 32 -af dLatticeButton "left" 64 
    -af dWrapButton "top" 32 -af dWrapButton "left" 96 
    -af dSculptButton "top" 32 -af dSculptButton "left" 128 
    -af dSoftmodButton "top" 64 -af dSoftmodButton "left" 0 
  toolXOver;        
}
 

global proc buildPaintSelectionOverlay()
{ // builds buttons and gadgets for the paint selection Overlay
  global string $iconPath;
  shelfButton -vis 0 -image ($iconPath + "brushoption.xpm") -h 20 -w 20 -ann "Paint Selection Options" -c "paintSelectOptions" paintSOptions;
  button -vis 0 -l "Done" -w 40 -h 20 -c "paintSelectOverlay(0); setToolTo selectSuperContext;" paintSReturnButton;
 // symmetry controls  
  shelfButton -vis 0 -image ($iconPath + "nosym.xpm") -h 20 -w 20 -ann "No Sculpt Symmetry" -c "setSymMode(\"no\")"   psymno; 
  shelfButton -vis 0 -image ($iconPath + "xsym.xpm")  -h 20 -w 20 -ann "X Sculpt Symmetry" -c "setSymMode(\"x\")"    psymx;  
  shelfButton -vis 0 -image ($iconPath + "ysym.xpm")  -h 20 -w 20 -ann "Y Sculpt Symmetry" -c "setSymMode(\"y\")"    psymy; 
  shelfButton -vis 0 -image ($iconPath + "zsym.xpm")  -h 20 -w 20 -ann "Z Sculpt Symmetry" -c "setSymMode(\"z\")"    psymz;
 // radius controls
  floatField  -vis 0 -h 20 -w 40 -minValue 0.01 -maxValue 50 -value 0.5 -precision 3 -step .01 -cc "updateBrushRadius" -ec "updateBrushRadius" pRadFloat;
  shelfButton -vis 0 -image ($iconPath + "halfradius.xpm") -h 20 -w 20 -ann "Half Radius" -c "setBrushSize (0.5)" pRadHalf;
  shelfButton -vis 0 -image ($iconPath + "doubleradius.xpm") -h 20 -w 20 -ann "Double Radius" -c "setBrushSize (2.0)" pRadDouble;
  shelfButton -vis 0 -image ($iconPath + "brushautoset.xpm") -h 20 -w 20 -ann "Automatic Settings" -c "autoSetBrushSize" pAutoset;   
 // layout for sculpt overlay 
  formLayout -e
   // return to X-Tools Previous Shelf and tool option button           
    -af paintSReturnButton "top" 104	-af paintSReturnButton "left" 70 
    -af paintSOptions "top" 104	-af paintSOptions "left" 46    
   // sculpt Symetry Modes             
    -af psymno "top" 62	        -af psymno "left" 38                   
    -af psymx "top" 62		-af psymx "left" 58   
    -af psymy "top" 62		-af psymy "left" 78
    -af psymz "top" 62		-af psymz "left" 98
   // sculpt Radius Slider
    -af pRadHalf "top" 34	-af pRadHalf "left" 38 
    -af pRadFloat "top" 35	-af pRadFloat "left" 58
    -af pRadDouble "top" 34	-af pRadDouble "left" 98
    -af pAutoset "top" 48	-af pAutoset "left" 124        
  toolXOver;    
}


global proc buildSoftModOverlay()
{// builds buttons and gadgets for the sculpt Overlay
  global string $iconPath;
  global int $isMaya8Plus;
  global int $isMaya85Plus;
 //grab the current softmod settings
  float $softModRadius = `optionVar -q softModFalloffRadius`; 
  int $snapOn = true;
  floatField  -vis 0 -h 20 -w 40 -minValue 0.01 -maxValue 50 -value 0.5 -precision 3 -step .01 -cc "updateSoftModRadius" -ec "updateSoftModRadius" smRadFloat;
  shelfButton -vis 0 -image ($iconPath + "halfsoftmod.xpm") -h 20 -w 20 -ann "Half SoftMod Radius" -c "setSoftModSize (0.5)" smRadHalf;
  shelfButton -vis 0 -image ($iconPath + "doublesoftmod.xpm") -h 20 -w 20 -ann "Double SoftMod Radius" -c "setSoftModSize (2.0)" smRadDouble;
  button -vis 0 -l "Done" -w 40 -h 20 -c "softModOverlay(0); setToolTo selectSuperContext;" softModReturnButton;
  shelfButton -vis 0 -image ($iconPath + "brushoption.xpm") -h 20 -w 20 -ann "SoftMod Tool Options" -c "softModTweekOptions" softModOptions;
 // layout for sculpt overlay 
  formLayout -e    
 // return to X-Tools Previous Shelf and tool option button           
    -af softModReturnButton "top" 104	-af softModReturnButton "left" 116 
    -af softModOptions "top" 104	-af softModOptions "left" 92    
 // softMod Radius Slider
    -af smRadHalf "top" 44	-af smRadHalf "left" 42 
    -af smRadFloat "top" 45	-af smRadFloat "left" 62
    -af smRadDouble "top" 44	-af smRadDouble "left" 102   
  toolXOver;   
}    


global proc buildSculptOverlay()
{ // builds buttons and gadgets for the sculpt Overlay
  global string $iconPath;
  shelfButton -vis 0 -h 32 -w 32
    -image ($iconPath + "pushbrush.xpm") -ann "Push Brush"
    -command "setBrushMode(\"push\")"  pushBButton; 
  shelfButton -vis 0 -h 32 -w 32
    -image ($iconPath + "pullbrush.xpm") -ann "Pull Brush"
    -command "setBrushMode(\"pull\")"  pullBButton;           
  shelfButton -vis 0 -h 32 -w 32
    -image ($iconPath + "smoothbrush.xpm") -ann "Smooth Brush"
    -command "setBrushMode(\"smooth\")"  smoothBButton;           
  shelfButton -vis 0 -h 32 -w 32
    -image ($iconPath + "relaxbrush.xpm") -ann "Relax Brush"
    -command "setBrushMode(\"relax\")"  relaxBButton;
  shelfButton -vis 0 -h 32 -w 32
    -image ($iconPath + "erasebrush.xpm") -ann "Erase Brush"
    -command "setBrushMode(\"erase\")"  eraseBButton;  
  shelfButton -vis 0 -image ($iconPath + "brushoption.xpm") -h 20 -w 20 -ann "Brush Tool Options" -c "sculptTweekOptions" brushOptions;
  button -vis 0 -l "Done" -w 40 -h 20 -c "sculptOverlay(0); setToolTo selectSuperContext;" sculptReturnButton;
 // symmetry controls  
  shelfButton -vis 0 -image ($iconPath + "nosym.xpm") -h 20 -w 20 -ann "No Sculpt Symmetry" -c "setSymMode(\"no\")"   bsymno; 
  shelfButton -vis 0 -image ($iconPath + "xsym.xpm")  -h 20 -w 20 -ann "X Sculpt Symmetry" -c "setSymMode(\"x\")"    bsymx;  
  shelfButton -vis 0 -image ($iconPath + "ysym.xpm")  -h 20 -w 20 -ann "Y Sculpt Symmetry" -c "setSymMode(\"y\")"    bsymy; 
  shelfButton -vis 0 -image ($iconPath + "zsym.xpm")  -h 20 -w 20 -ann "Z Sculpt Symmetry" -c "setSymMode(\"z\")"    bsymz;
 // radius controls
  floatField  -vis 0 -h 20 -w 40 -minValue 0.01 -maxValue 50 -value 0.5 -precision 3 -step .01 -cc "updateBrushRadius" -ec "updateBrushRadius" bRadFloat;
  popupMenu -p bRadFloat;
    menuItem -rp "N"  -label "Auto Resize" -c "autoSetBrushSize" autoRadResizeMenu;    
    menuItem -rp "E"  -label "Contrain Max Disp" -c "constrainDispToggle" toggleDispConstraintMenu;     
    menuItem -rp "S"  -label "Set 1:1 Ratio" -c "setBrushSize1to1" setRadRatioMenu;
  setParent toolXOver;
  shelfButton -vis 0 -image ($iconPath + "halfradius.xpm") -h 20 -w 20 -ann "Half Radius" -c "setBrushSize (0.5)" bRadHalf;
  shelfButton -vis 0 -image ($iconPath + "doubleradius.xpm") -h 20 -w 20 -ann "Double Radius" -c "setBrushSize (2.0)" bRadDouble;
 // Max disp controls
  floatField  -vis 0 -h 20 -w 40 -minValue 0.01 -maxValue 50 -value 0.5 -precision 3 -step .01 -cc "updateBrushDisp" -ec "updateBrushDisp" bDispFloat;
  popupMenu -p bDispFloat;
    menuItem -rp "N"  -label "Auto Resize"   -c "autoSetBrushSize"   autoDispResizeMenu;      
    menuItem -rp "S"  -label "Set 1:1 Ratio" -c "setBrushSize1to1" setDispRatioMenu;    
  setParent toolXOver;
  shelfButton -vis 0 -image ($iconPath + "halfdisp.xpm") -h 20 -w 20 -ann "Half Displacement" -c "setBrushDisp (0.5)" bDisHalf;
  shelfButton -vis 0 -image ($iconPath + "doubledisp.xpm") -h 20 -w 20 -ann "Double Displacement" -c "setBrushDisp (2.0)" bDisDouble; 
 // opacity controls
  floatField  -vis 0 -h 20 -w 40 -minValue 0.00 -maxValue 1 -value 0.5 -precision 3 -step .01 -cc "updateBrushOpac" -ec "updateBrushOpac" bOpacFloat;  
  shelfButton -vis 0 -image ($iconPath + "halfopac.xpm") -h 20 -w 20 -ann "Half Opacity" -c "setBrushOpac (0.5)" bOpacHalf;
  shelfButton -vis 0 -image ($iconPath + "doubleopac.xpm") -h 20 -w 20 -ann "Double Opacity" -c "setBrushOpac (2.0)" bOpacDouble;
 // smooth controls
  intField    -vis 0 -h 20 -w 30 -minValue 0 -maxValue 10 -value 1 -step 1 -cc "changeBrushSmoothingValue" -ec "changeBrushSmoothingValue" bSmthInt;  
  shelfButton -vis 0 -image ($iconPath + "lessthan.xpm") -h 20 -w 20 -ann "Less Smooth" -c "setBrushSmoothing (-1)" bSmthLess;
  shelfButton -vis 0 -image ($iconPath + "greaterthan.xpm") -h 20 -w 20 -ann "More Smooth" -c "setBrushSmoothing (1)" bSmthMore; 
 // toggle wire frame control button
  shelfButton -vis 0 -image ($iconPath + "togglebrushwire.xpm") -h 20 -w 20 -ann "Toggle Wireframe" -c "toggleWireframeforBrush" tglWireBrushDisp;
 // brush reference vector
  string $directionOption = `optionMenu -vis 0 -cc setDirOp directionField`;  
    menuItem -label "N";
    menuItem -label "V";  
    menuItem -label "FN"; 
    menuItem -label "X";
    menuItem -label "Y";
    menuItem -label "Z";  
  setParent toolXOver;
 // layout for sculpt overlay 
  formLayout -e
 // sculpt Mode Buttons           
    -af pushBButton "top" 0 	-af pushBButton "left" 0 
    -af pullBButton "top" 0	-af pullBButton "left" 32 
    -af smoothBButton "top" 0 	-af smoothBButton "left" 64 
    -af relaxBButton "top" 0	-af relaxBButton "left" 96 
    -af eraseBButton "top" 0	-af eraseBButton "left" 128 
   // return to X-Tools Previous Shelf and tool option button           
    -af sculptReturnButton "top" 104	-af sculptReturnButton "left" 116 
    -af brushOptions "top" 104	-af brushOptions "left" 92    
   // sculpt Symetry Modes             
    -af bsymno "top" 104	-af bsymno "left" 8                   
    -af bsymx "top" 104		-af bsymx "left" 28   
    -af bsymy "top" 104		-af bsymy "left" 48
    -af bsymz "top" 104		-af bsymz "left" 68
   // sculpt Radius Slider
    -af bRadHalf "top" 34	-af bRadHalf "left" 2 
    -af bRadFloat "top" 35	-af bRadFloat "left" 22
    -af bRadDouble "top" 34	-af bRadDouble "left" 62
   // sculpt Max Displacement Slider
    -af bDisHalf "top" 56	-af bDisHalf "left" 2 
    -af bDispFloat "top" 57	-af bDispFloat "left" 22
    -af bDisDouble "top" 56	-af bDisDouble "left" 62   
   // sculpt Max Opacity Slider
    -af bOpacHalf "top" 80	-af bOpacHalf "left" 2 
    -af bOpacFloat "top" 81	-af bOpacFloat "left" 22
    -af bOpacDouble "top" 80	-af bOpacDouble "left" 62
   // sculpt Max SMooth Slider
    -af bSmthLess "top" 80	-af bSmthLess "left" 86 
    -af bSmthInt  "top" 81	-af bSmthInt  "left" 106
    -af bSmthMore "top" 80	-af bSmthMore "left" 136  
   // control buttons 
    -af tglWireBrushDisp "top" 34 -af tglWireBrushDisp "left" 86 
//    -af b1to1Dis "top" 34	-af b1to1Dis "left" 106 
//    -af bAutoset "top" 34	-af bAutoset "left" 126  
    -af directionField "top" 56	-af directionField "left" 96      
  toolXOver;    
}
  
  
global proc buildXUI()
{ // builds or rebuilds X-Tools
  global int    $xtoolRestart;
  global string $iconPath;
  global string $scriptPath;
  global int $hotkeysOn;
  global int $shelfSet;
  global int $shelfOn;
  global int $brushScript;
  global int $isMaya8Plus;
  global int $isMaya85Plus;
  global string $shelfPath;
  global string $userXShelf;
  global string $userAltShelf;
  global string $gMainWindow;
  global int $toolMessages;
  global int $shutDownScript;
  global int $xToolboxShutdown;  
  global string $xtoolForm;
  int $xToolwLE;
  int $xToolwTE;
 // set window width and height for mac, pc, and linux platforms  
  global int $xWinHeight;
  int $xShelfHeight = 161;
  int $xWinWidth;    
  string $shelfForm;
  string $xtoolsWin; 
  string $xtWinTitle;
 // begin drawing X-Tools window
  if (`windowPref -ex xToolsWindow`) windowPref -remove xToolsWindow; // delete Window Pref
 // set globals for first time
  $hotkeysOn = false; // off by default
  $brushScript = false;  // off by default
  int $x3dMode = false; //on by default - removed in version 3.8 varible kept for compatiblity
  $shelfSet = 1;    // 1 = poly only, 2 = nurb only, 3 = General only(in ver4.0), 5 = all (old Default) 1,2 only valid setting
  if ($shelfSet==1) $xtWinTitle = "X-Tools 3.9.6" + " Poly";
  if ($shelfSet==2) $xtWinTitle = "X-Tools 3.9.6" + " Nurb";
  if ($shelfSet==3) $xtWinTitle = "X-Tools 3.9.6" + " General"; 
  $shelfOn = false; // off by default 
  $toolMessages = false; // off by default
 // load user prefs - if any
  if (`filetest -r ($scriptPath+"xTools_UserPrefs.mel")`)
  {// source and run Preference file to set GUI variables
    string $loadingPrefs = "source " + "\"" + $scriptPath + "xTools_UserPrefs.mel\"";
    text -e -l "Loading Preferences." xsText;
    progressBar -edit -step 1 xsProgressControl;
    eval ($loadingPrefs);
    eval ("xTools_UserPrefs");
  } 
  if (($shelfSet < 1)||($shelfSet > 3)) // old shelf tabs removed - ignore settings
    $shelfSet = 1;
  if (`about -mac`)
  {  
    $xWinHeight = 166 + ($shelfOn*$xShelfHeight);
    $xWinWidth = 160;
  }
  if (`about -li`) // linux os
  {  
    $xWinHeight = 154 + ($shelfOn*$xShelfHeight);
    $xWinWidth = 162;
  } 
 // set toolmessages prefs to on/off based on xtool prefs 
  if ($isMaya8Plus)
    optionVar -intValue toolMessageVisible $toolMessages;  
 // build Commands and set hotkeys if hotkeysOn is set
  buildXCommands;
  if ($hotkeysOn) setXHotKeys;
  if ($isMaya8Plus)
    optionVar -intValue toolMessageVisible $toolMessages;
 // delete old xtools window
  if (`window -ex xToolsWindow`)
  { // save prefs and delete interface  
    saveXPrefs;
    deleteUI xToolsWindow;
    $xtoolRestart = true;
  }  
  if (`about -win`)    
    $xtoolsWin = `window 
   // toolbox style, not resizeable
      -tlb 1 -rtf 1
      -in "xtools3.9.6"          
      -s 0
      -title $xtWinTitle
      -menuBar 1
      -bgc 0.75 0.75 0.75
      xToolsWindow`;
  else
    $xtoolsWin = `window 
   // toolbox style, not resizeable
      -w $xWinWidth -h $xWinHeight
      -tlb 1 
      -in "xtools3.9.6"          
      -s 0 
      -title $xtWinTitle
      -menuBar 1
      xToolsWindow`;     
  $xLayout = `columnLayout -adj 1 mainXLayout`;  // main X-Tools Layout
 // add menus or pop-menu
  text -e -l "Building X-Tool Menus." xsText;
  progressBar -edit -step 1 xsProgressControl;
  makeXToolsMenu ($xtoolsWin);
 // build grid
  $xtoolForm = `formLayout toolXOver`; // for overlay
 // add standard xtools grid and build tool overlays
  text -e -l "Building Tool Overlays." xsText;
  progressBar -edit -step 1 xsProgressControl;
  text -e -l "Building Sculpt Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;  
  buildSculptOverlay;
  text -e -l "Building SoftMod Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;    
  buildSoftModOverlay;
  text -e -l "Building Paint Selection Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;   
  buildPaintSelectionOverlay;
  text -e -l "Building Direction Button Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;  
  buildDirectionButtonOverlay;
  text -e -l "Building Center Button Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;    
  buildCenterButtonOverlay;
  text -e -l "Building Normal Display Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;  
  buildNormalDisplayOverlay;
  text -e -l "Building Poly Shape Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildPolyShapeOverlay;
  text -e -l "Building Nurb Shape Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;    
  buildPolyCreaseOverlay;
  text -e -l "Building Poly Crease Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;      
  buildNurbShapeOverlay;
  text -e -l "Building Poly Display Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;    
  buildPolyDisplayOverlay;
  text -e -l "Building Nurb Display Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildNurbDisplayOverlay;
  text -e -l "Building Face Select Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildFaceSelectOverlay;
  text -e -l "Building Random Select Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildRandomSelectOverlay;
  text -e -l "Building Face Tool Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildFaceToolOverlay;
  text -e -l "Building Edge Tool Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildEdgeToolOverlay;
  text -e -l "Building Deformer Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildDeformerOverlay;
  text -e -l "Building Curve Tool Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl; 
  buildCurveToolOverlay;
  text -e -l "Building Nurb Tool Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildNurbToolOverlay;
  text -e -l "Building Selct Tool Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildSelectLoopOverlay;
  text -e -l "Building Toggle Edge Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildToggleEdgeOverlay;
  text -e -l "Building Mirror Duplicate Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl;
  buildMirrorDuplicateOverlay;
  text -e -l "Building Help List Overlay." xsText;
  progressBar -edit -step 1 xsProgressControl; 
  buildHelplistOverlay;
  text -e -l "Loading Tool Grid." xsText;
  progressBar -edit -step 1 xsProgressControl;  
  $xtoolGrid = `gridLayout -nrc 4 5 -cwh 32 32 toolXGrid`;
  formLayout -e
    // Layout standard Tool Grid
    -af toolXGrid "top"  0 	-af toolXGrid "left" 0 toolXOver;
  for ($xbutton=1;$xbutton<21;$xbutton++)
  {
    shelfButton -h 32 -w 32 -ann ("xbutton"+$xbutton) ("xbutton"+$xbutton);
    popupMenu -mm 1 -aob true ("xpopup"+$xbutton);
  } 
 // choose which tol set to display a poly tool set if called for
  if ($shelfSet == 1) setPolyTools;
  if ($shelfSet == 2) setNurbTools;
  if ($shelfSet == 3) setGeneralTools;  
 // create User Shelfs
  text -e -l "Creating User Shelves." xsText;
  progressBar -edit -step 1 xsProgressControl;
  setParent $xLayout;
  separator -vis $shelfOn -height 1 -style "in" shelfSeparator;
  $shelfForm = `formLayout -vis $shelfOn -w 160 -numberOfDivisions 100 shelfForm`;  // layout for user shelf
  $shelfgrid = `gridLayout -w 1 -h 160 shelfGrid`;  //  // used as place holder to insure a certain shelfForm height
  setParent ..;
  $shelfTabs = `shelfTabLayout -tabsVisible 1 -imageVisible 1 -scrollable 0 -childResizable 1 -image "smallTrash.xpm" -innerMarginWidth 0 -innerMarginHeight 0`;  
  $userXShelf = `shelfLayout -cwh 32 32`; 
  setParent ..;
  $userAltShelf = `shelfLayout -cwh 32 32`;
  shelfTabLayout -edit -tabLabel $userXShelf   "User Shelf" $shelfTabs;
  shelfTabLayout -edit -tabLabel $userAltShelf "Alt Shelf" $shelfTabs;
  formLayout -edit
    -attachForm $shelfTabs "top"    0
    -attachForm $shelfTabs "left"   0
    -attachForm $shelfTabs "bottom" 0
    -attachForm $shelfgrid "right"  0  
    -attachForm $shelfTabs "right"  0 
    $shelfForm;
 // checking for saved user shelf files 
  string $shelfFile = $scriptPath + "xTools_UserShelf.mel";
 // loading user shelf file if it exists 
  if (`filetest -f $shelfFile`)
  {
    addShelfFile ($userXShelf,"xTools_UserShelf.mel");
    text -e -l "Loading User Shelf." xsText;
    progressBar -edit -step 1 xsProgressControl;
  }
  else 
  { 
    text -e -l "Creating new User Shelf." xsText;
    progressBar -edit -step 1 xsProgressControl; 
  }
  string $shelfFile = $scriptPath + "xTools_AltShelf.mel";
 // loading user alt file if it exists 
  if (`filetest -f $shelfFile`)
  {
    addShelfFile ($userAltShelf,"xTools_AltShelf.mel");
    text -e -l "Loading Alt Shelf." xsText;
    progressBar -edit -step 1 xsProgressControl;    
  }  
  else 
  {
    text -e -l "Creating new Alt Shelf." xsText;
    progressBar -edit -step 1 xsProgressControl; 
  } 
 // gui ends
  text -e -l "Creating Toolbox." xsText;
  progressBar -edit -step 1 xsProgressControl;
  showWindow $xtoolsWin;
 // grab xtools window height
  $xWinHeight = `window -q -h xToolsWindow`;
 // cleanup script if Xtools is shutdown
  global int $xToolboxShutdown;
  $xToolboxShutdown = `scriptJob -runOnce true -uid "xToolsWindow" closeXtools`;
  text -e -l "X-Tools is running." xsText;
  progressBar -edit -step 1 xsProgressControl; 
  print ("X-Tools is Running.\n");
}  


global proc updateShelfDisplay()
{ // updates gadgets and window properties to correct display User Shelf as on or off
  global int $shelfOn;
  global int $xWinHeight;
  menuItem -e -en $shelfOn clearShelfMenu;
  menuItem -e -en $shelfOn saveShelfMenu;
  separator -e -vis $shelfOn shelfSeparator; 
  formLayout -e -vis $shelfOn shelfForm; 
  if ($shelfOn)
    $xWinHeight = $xWinHeight + 161;
  else $xWinHeight = $xWinHeight - 161;
  window -e -h $xWinHeight xToolsWindow;  
}


global proc int currentInactive()
{ // returns boolen value based on the interactive flag of the current Shelf
  global int $shelfSet;
  if ($shelfSet==2) return `optionVar -q createNurbPrimitiveAsTool`;
  else return `optionVar -q createPolyPrimitiveAsTool`;
}


global proc makeXToolsMenu(string $xtoolsWin)
{ // build X-Tools Main Window Menu
  global int $isMaya8Plus;
  global int $hotkeysOn;
  global int $shelfSet;
  global int $shelfOn;
  global int $helpOn;
  global int $toolMessages;
  global int $brushScripts;
  global string $userXShelf;
  text -e -l "Building X-Tools Menu." xsText;
  progressBar -edit -step 1 xsProgressControl;   
  menu -p $xtoolsWin -label "Pref" -pmc "updateInteractiveFlags";
    menuItem -label "Iconify " -command "iconifyToggle";  
    menuItem -divider 1;
    menuItem -label "HotKeys" -cb $hotkeysOn -command "if ($hotkeysOn) releaseXHotKeys; else setXHotKeys; $hotkeysOn = 1 - $hotkeysOn";       
    if ($isMaya8Plus)
    {
      menuItem -divider 1;    
      menuItem -label "Tool Messages" -cb `optionVar -q  toolMessageVisible` -c "$toolMessages = 1 - $toolMessages; optionVar -intValue toolMessageVisible $toolMessages";
      menuItem -en ($shelfSet<3) -label "Interactive Creation" -cb `currentInactive` -c "updateCurrentInteractiveFlag" xInteractive; 
   }  
    menuItem -divider 1;
    menuItem -label "Save Prefs" -command "saveXPrefs";
  menu -p $xtoolsWin -label "Tools";
    radioMenuItemCollection;
      menuItem -label "Poly Tools"   -rb ($shelfSet==1) -command "if ($shelfOn) saveUserShelf; $shelfSet = 1; setPolyTools;" xPolyMenu;  
      menuItem -label "Nurbs Tools"  -rb ($shelfSet==2) -command "if ($shelfOn) saveUserShelf; $shelfSet = 2; setNurbTools;" xNurbMenu;   
      menuItem -label "General Tools" -rb ($shelfSet==3) -command "if ($shelfOn) saveUserShelf; $shelfSet = 3; setGeneralTools;" xGeneralMenu;;  
    menuItem -divider 1;
    menuItem -label "Mel-O-Matic" -command "xmelomatic";
    menuItem -label "Gui Py" -command "guipy"; 
    menuItem -label "UV Hero" -command "uvhero";     
    menuItem -divider 1;    
      menuItem -label "User Shelves" -cb $shelfOn -command "if ($shelfOn) saveUserShelf; $shelfOn = 1 - $shelfOn; updateShelfDisplay";
//    menuItem -label "Load a Shelf" -en $shelfOn -command "addShelfFile (\"\")" loadShelfMenu;
    menuItem -label "Clear Shelf" -en $shelfOn -command "deleteUI (`shelfLayout -q -ca $userXShelf`)" clearShelfMenu;
    menuItem -label "Save Shelf" -en $shelfOn -command  saveUserShelf saveShelfMenu;
  menu -p $xtoolsWin -label "Help" -helpMenu true;
    menuItem -label "Help Mode" -cb $helpOn -command "$helpOn = 1 - $helpOn; setHelpTools" xHelpModeMenu; 
    menuItem -label "Find Command" -command "helpListOverlay(1);" xHelpListMenu; 
    menuItem -divider 1;
    menuItem -label "Latest Version" -command "showHelp -absolute \"http://www.highend3d.com/maya/downloads/mel_scripts/modeling/poly_tools/X-Tools-4783.html\"" xHelpLatestMenu; 
    menuItem -label "X-Tools Home Page" -command "showHelp -absolute \"http://www.andrews3dbrain.com/xtools.html\"" xHelpHomeMenu;     
    menuItem -label "Training Videos" -command "showHelp -absolute \"http://www.andrews3dbrain.com/xtooltraining.html\"" xHelpVideoMenu;     
    menuItem -divider 1;    
    menuItem -label "About X-Tools..." -command xToolsAbout;
}


global proc turnOffToolMessages()
{ // turns off Tool Messages
  global int $isMaya8Plus;
  if ($isMaya8Plus)
    optionVar -intValue toolMessageVisible false;
}


global proc restoreToolMessagesSettings()
{ // restores Tool Messages Settins from Tool Message Settings
  global int $isMaya8Plus;
  global int $toolMessages;
  if ($isMaya8Plus)
    optionVar -intValue toolMessageVisible $toolMessages;  
}


global proc setHelpTools()
{ // changes xtools window title to reflect whether click help mode is on or not
  global int $helpOn;
  global int $shelfSet;
  if ($helpOn)
  {
    window -e -t "X-Tools Help Mode" xToolsWindow;
    int $start = 0;
    if ($shelfSet==2)
      $start = 20;
    if ($shelfSet==3)
      $start = 40;      
    for ($x = 1; $x < 21; $x++)
      shelfButton -e -c ("xHelpButton("+($x+$start)+",0)") -dcc "" ("xbutton"+$x);
    xHelpButton(0,0);
  }  
  else
  { 
    if ($shelfSet==1) 
    {
      window -e -t "X-Tools 3.9.6 Poly" xToolsWindow;
      setPolyTools;
    }  
    if ($shelfSet==2) 
    {
      window -e -t "X-Tools 3.9.6 Nurb" xToolsWindow;    
      setNurbTools;
    }  
    if ($shelfSet==3) 
    {
      window -e -t "X-Tools 3.9.6 General" xToolsWindow;    
      setGeneralTools;
    }      
    print ("X-Tools Help Mode is off.\n"); 
  }
}


global proc copyShelfButton(string $oldButton, string $newButton)
{ // copy the values old shelfbutton to the new shelfbutton
  shelfButton -e -c (`shelfButton -q -c $oldButton`) $newButton;
  shelfButton -e -ann (`shelfButton -q -ann $oldButton`) $newButton;  
  shelfButton -e -i (`shelfButton -q -i $oldButton`) $newButton;
  shelfButton -e -dcc (`shelfButton -q -dcc $oldButton`) $newButton;  
}


global proc selectLoopOverlay(int $onMode)
{// switch buttons of softMod overlay off or on
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  text   -e -vis $onMode slSpacingLabel;
  button -e -vis $onMode slCancelButton;
  button -e -vis $onMode slSpacingDownButton;
  intField -e -vis $onMode slSpacingFloat;
  button -e -vis $onMode slSpacingUpButton; 
  text   -e -vis $onMode slOffsetLabel;  
  button -e -vis $onMode slOffsetDownButton;
  intField -e -vis $onMode slOffsetFloat;  
  button -e -vis $onMode slOffsetUpButton; 
  shelfButton -e -vis $onMode slGrowButton;
  shelfButton -e -vis $onMode slSwapButton; 
}


global proc sculptOverlay(int $onMode)
{// switch buttons of sculpt overlay off or on
 // toggle main xtools grid
  global int $shelfSet;
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  shelfButton -e -vis $onMode pushBButton;
  shelfButton -e -vis $onMode pullBButton;
  shelfButton -e -vis $onMode smoothBButton;
  shelfButton -e -vis $onMode relaxBButton; 
  shelfButton -e -vis $onMode eraseBButton;
  button -e -vis $onMode sculptReturnButton;
  shelfButton -e -vis $onMode bsymx;  
  shelfButton -e -vis $onMode bsymy;
  shelfButton -e -vis $onMode bsymz;
  shelfButton -e -vis $onMode bsymno;
  floatField  -e -vis $onMode bRadFloat;
  shelfButton -e -vis $onMode bRadHalf; 
  shelfButton -e -vis $onMode bRadDouble;  
  floatField  -e -vis $onMode bDispFloat;
  shelfButton -e -vis $onMode bDisHalf; 
  shelfButton -e -vis $onMode bDisDouble;  
  floatField  -e -vis $onMode bOpacFloat;
  shelfButton -e -vis $onMode bOpacHalf; 
  shelfButton -e -vis $onMode bOpacDouble;    
  intField    -e -vis $onMode bSmthInt;
  shelfButton -e -vis $onMode bSmthLess; 
  shelfButton -e -vis $onMode bSmthMore; 
  shelfButton -e -vis $onMode tglWireBrushDisp;  
  optionMenu -e  -vis $onMode directionField;
  shelfButton -e -vis $onMode brushOptions;
  if ($onMode<1)
    switch ($shelfSet)
    {
      case 1: window -e -t "X-Tools 3.9.6 Poly" xToolsWindow; break;
      case 2: window -e -t "X-Tools 3.9.6 Nurb" xToolsWindow; break;
      case 3: window -e -t "X-Tools 3.9.6 General"   xToolsWindow; break;
    } 
}



global proc softModOverlay(int $onMode)
{// switch buttons of softMod overlay off or on
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  button -e -vis $onMode softModReturnButton;
  shelfButton -e -vis $onMode softModOptions;
  floatField  -e -vis $onMode smRadFloat;
  shelfButton -e -vis $onMode smRadHalf; 
  shelfButton -e -vis $onMode smRadDouble;
}


global proc paintSelectOverlay(int $onMode)
{// switch buttons of sculpt overlay off or on
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  button -e -vis $onMode paintSReturnButton;
  shelfButton -e -vis $onMode psymx;  
  shelfButton -e -vis $onMode psymy;
  shelfButton -e -vis $onMode psymz;
  shelfButton -e -vis $onMode psymno;
  floatField  -e -vis $onMode pRadFloat;
  shelfButton -e -vis $onMode pRadHalf; 
  shelfButton -e -vis $onMode pRadDouble;  
  shelfButton -e -vis $onMode pAutoset;   
  shelfButton -e -vis $onMode paintSOptions;
}


global proc creaseButtonOverlay(int $onMode)
{// switch buttons of overlay off or onfor PolyCrease
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  floatField -e -vis $onMode pCreaseFloat;
  button -e -vis $onMode polyCreaseGoButton;
  button -e -vis $onMode polyCreaseCancelButton;
}




global proc directionButtonOverlay(int $onMode)
{// switch buttons of direction Button overlay off or on
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  button -e -vis $onMode xPosButton;
  button -e -vis $onMode xNegButton;
  button -e -vis $onMode yPosButton;
  button -e -vis $onMode yNegButton;  
  button -e -vis $onMode zPosButton;
  button -e -vis $onMode zNegButton;
  button -e -vis $onMode dCancelButton;
}


global proc setdirectiontoMirror()
{// set the direction buttons to poly mirror commands
  button -e -c "xPolyMirror(0); directionButtonOverlay(0);" xPosButton;
  button -e -c "xPolyMirror(1); directionButtonOverlay(0);" xNegButton;
  button -e -c "xPolyMirror(2); directionButtonOverlay(0);" yPosButton;
  button -e -c "xPolyMirror(3); directionButtonOverlay(0);" yNegButton;
  button -e -c "xPolyMirror(4); directionButtonOverlay(0);" zPosButton;
  button -e -c "xPolyMirror(5); directionButtonOverlay(0);" zNegButton;  
}


global proc setdirectiontoSelectHalf()
{// set the direction buttons to poly mirror commands
  button -e -c "selectHalf(1); directionButtonOverlay(0)" xPosButton;
  button -e -c "selectHalf(2); directionButtonOverlay(0)" xNegButton;
  button -e -c "selectHalf(3); directionButtonOverlay(0)" yPosButton;
  button -e -c "selectHalf(4); directionButtonOverlay(0)" yNegButton;
  button -e -c "selectHalf(5); directionButtonOverlay(0)" zPosButton;
  button -e -c "selectHalf(6); directionButtonOverlay(0)" zNegButton;
}


global proc setdirectiontoDeleteHalf()
{// set the direction buttons to poly mirror commands
  button -e -c "selectHalf(1); delete; directionButtonOverlay(0)" xPosButton;
  button -e -c "selectHalf(2); delete; directionButtonOverlay(0)" xNegButton;
  button -e -c "selectHalf(3); delete; directionButtonOverlay(0)" yPosButton;
  button -e -c "selectHalf(4); delete; directionButtonOverlay(0)" yNegButton;
  button -e -c "selectHalf(5); delete; directionButtonOverlay(0)" zPosButton;
  button -e -c "selectHalf(6); delete; directionButtonOverlay(0)" zNegButton;
}


global proc setdirectiontoExtractHalf()
{// set the direction buttons to poly mirror commands
  button -e -c "selectHalf(1); quickExtract(false); directionButtonOverlay(0)" xPosButton;
  button -e -c "selectHalf(2); quickExtract(false); directionButtonOverlay(0)" xNegButton;
  button -e -c "selectHalf(3); quickExtract(false); directionButtonOverlay(0)" yPosButton;
  button -e -c "selectHalf(4); quickExtract(false); directionButtonOverlay(0)" yNegButton;
  button -e -c "selectHalf(5); quickExtract(false); directionButtonOverlay(0)" zPosButton;
  button -e -c "selectHalf(6); quickExtract(false); directionButtonOverlay(0)" zNegButton;
}


global proc setdirectiontoDuplicateHalf()
{// set the direction buttons to poly mirror commands
  button -e -c "selectHalf(1); quickExtract(true); directionButtonOverlay(0)" xPosButton;
  button -e -c "selectHalf(2); quickExtract(true); directionButtonOverlay(0)" xNegButton;
  button -e -c "selectHalf(3); quickExtract(true); directionButtonOverlay(0)" yPosButton;
  button -e -c "selectHalf(4); quickExtract(true); directionButtonOverlay(0)" yNegButton;
  button -e -c "selectHalf(5); quickExtract(true); directionButtonOverlay(0)" zPosButton;
  button -e -c "selectHalf(6); quickExtract(true); directionButtonOverlay(0)" zNegButton;
}



global proc setdirectiontoCenterPivot()
{// set the direction buttons to poly mirror commands
  button -e -c "centerpivotconstrain(3); directionButtonOverlay(0)" xPosButton;
  button -e -c "centerpivotconstrain(0); directionButtonOverlay(0)" xNegButton;
  button -e -c "centerpivotconstrain(4); directionButtonOverlay(0)" yPosButton;
  button -e -c "centerpivotconstrain(1); directionButtonOverlay(0)" yNegButton;
  button -e -c "centerpivotconstrain(5); directionButtonOverlay(0)" zPosButton;
  button -e -c "centerpivotconstrain(2); directionButtonOverlay(0)" zNegButton;
}


global proc mirrorDuplicateOverlay(int $onMode)
{// switch buttons of mirror Duplicate Overlay off or on
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  text -e -vis $onMode mirrorCopyLabel;
  button -e -vis $onMode xMirrorCopyButton;
  button -e -vis $onMode yMirrorCopyButton;
  button -e -vis $onMode zMirrorCopyButton;
  text -e -vis $onMode mirrorInstLabel;  
  button -e -vis $onMode xMirrorInstButton;  
  button -e -vis $onMode yMirrorInstButton;
  button -e -vis $onMode zMirrorInstButton;
  button -e -vis $onMode mdCancelButton;
}


global proc centerButtonOverlay(int $onMode)
{// switch buttons of direction Button overlay off or on
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  button -e -vis $onMode xCenButton;
  button -e -vis $onMode yCenButton;
  button -e -vis $onMode zCenButton;
  button -e -vis $onMode xyCenButton;  
  button -e -vis $onMode yzCenButton;
  button -e -vis $onMode zxCenButton;
  button -e -vis $onMode originCenButton;
  button -e -vis $onMode cCancelButton;
}


global proc toggleEdgeOverlay(int $onMode)
{// switch buttons of toggle edge overlay off or on
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  button -e -vis $onMode teSoftButton;
  button -e -vis $onMode teHardButton;
  button -e -vis $onMode teCancelButton;
}



global proc normalDisplayOverlay(int $onMode)
{// switch buttons of normal display overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   if ($onMode)
   {
     float $currentLength[] = `polyOptions -q -sn`;
     floatSlider -e -value $currentLength[0] nLengthSlider;
   }
   floatSlider -e -vis $onMode nLengthSlider;
   shelfButton -e -vis $onMode nDisplayButton;
   button -e -vis $onMode  nDoneButton;
}


global proc polyShapeOverlay(int $onMode)
{// switch buttons of polyshapes overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode pCubeButton;
   shelfButton -e -vis $onMode pPlaneButton;
   shelfButton -e -vis $onMode pSphereButton;
   shelfButton -e -vis $onMode pCylinderButton;
   shelfButton -e -vis $onMode pConeButton;
   shelfButton -e -vis $onMode pTorusButton;
   shelfButton -e -vis $onMode pPyramidButton;
   shelfButton -e -vis $onMode pPipeButton;   
   shelfButton -e -vis $onMode pHelixButton;
   shelfButton -e -vis $onMode sculptPrimButton;
   shelfButton -e -vis $onMode pSoccerButton;
   shelfButton -e -vis $onMode pPlatonicButton; 
   button -e -vis $onMode pShapeCancelButton;
}


global proc nurbShapeOverlay(int $onMode)
{// switch buttons of nurbshapes overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode nCubeButton;
   shelfButton -e -vis $onMode nPlaneButton;
   shelfButton -e -vis $onMode nSphereButton;
   shelfButton -e -vis $onMode nCylinderButton;
   shelfButton -e -vis $onMode nConeButton;
   shelfButton -e -vis $onMode nTorusButton;
   shelfButton -e -vis $onMode nCircleButton; 
   button -e -vis $onMode nShapeCancelButton;
}


global proc polyDisplayOverlay(int $onMode)
{// switch buttons of Poly Display modes overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode pwosButton;
   shelfButton -e -vis $onMode pxrayButton;
   shelfButton -e -vis $onMode pisButton;
   shelfButton -e -vis $onMode pwfaceButton;
   shelfButton -e -vis $onMode pbfaceButton;
   shelfButton -e -vis $onMode pcamDisplayButton;
   shelfButton -e -vis $onMode pInfoButton; 
   shelfButton -e -vis $onMode pActxrayButton; 
   shelfButton -e -vis $onMode pJointxrayButton; 
   button -e -vis $onMode pDisplayCancelButton; 
}


global proc nurbDisplayOverlay(int $onMode)
{// switch buttons of Nurb Display modes overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode nwosButton;
   shelfButton -e -vis $onMode nxrayButton;
   shelfButton -e -vis $onMode nnormalsButton;
   shelfButton -e -vis $onMode cvButton;
   shelfButton -e -vis $onMode epButton;
   shelfButton -e -vis $onMode hullButton;   
   shelfButton -e -vis $onMode ncamDisplayButton;
   shelfButton -e -vis $onMode cDispButton; 
   shelfButton -e -vis $onMode sDispButton;    
   button -e -vis $onMode nDisplayCancelButton;
}


global proc selectRadPoly()
{ //selects a random amount of components based slider's value
  selectMode -component; 
  selectType -allComponents 0 -polymeshFace 1;
  polySelectConstraint -m 3 -t 0x0008 -r 1 -rr `floatSlider -q -v rValueSlider`; 
  polySelectConstraint -m 0 -r 0;
}


global proc randomSelectOverlay(int $onMode)
{// displays a slider gadget that controls Random Selection
  if ($onMode)
  {
    selectMode -component; 
    selectType -allComponents 0 -polymeshFace 1;  
    polySelectConstraint -m 3 -t 0x0008 -r 1 -rr 0.35; 
    polySelectConstraint -m 0 -r 0;
  }  
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  floatSlider -e -vis $onMode rValueSlider;          
  button -e -vis $onMode rDoneButton;  
}


global proc helpListOverlay(int $onMode)
{// displays a help list on/off
 // toggle main xtools grid
  gridLayout  -e -vis (1-$onMode) toolXGrid;
  textScrollList -e -vis $onMode helpList;
  button -e -vis $onMode findButton;            
  button -e -vis $onMode helpCloseButton;
 //find and help are mutually exclusive 
  menuItem -e -en (1-$onMode) xHelpModeMenu;
 // set window title
  if ($onMode)
    window -e -t "X-Tools 3.9.6 Find" xToolsWindow;
  else
    setHelpTools;
}


global proc faceSelectOverlay(int $onMode)
{// switch buttons of select face overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode fTriButton;
   shelfButton -e -vis $onMode fQuadButton;
   shelfButton -e -vis $onMode fNgonButton;
   shelfButton -e -vis $onMode fUntriButton;
   shelfButton -e -vis $onMode fLaminaButton;
   shelfButton -e -vis $onMode fRandomButton; 
   shelfButton -e -vis $onMode bEdgeButton;
   shelfButton -e -vis $onMode unSharedEdgeButton;
   shelfButton -e -vis $onMode unSharedVertButton;       
   shelfButton -e -vis $onMode bVertButton;
   shelfButton -e -vis $onMode inVertButton;   
   shelfButton -e -vis $onMode cVertButton;
   shelfButton -e -vis $onMode wVertButton;
   shelfButton -e -vis $onMode pVertButton;
   shelfButton -e -vis $onMode sVertButton;
   shelfButton -e -vis $onMode nsVertButton;  
   shelfButton -e -vis $onMode hardsoftSelectButton;
   shelfButton -e -vis $onMode unflippedButton;   
   button -e -vis $onMode fSelectCancelButton;  
}


global proc deformerOverlay(int $onMode)
{// switch buttons of select face overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode dBendButton;
   shelfButton -e -vis $onMode dFlareButton;
   shelfButton -e -vis $onMode dSineButton;
   shelfButton -e -vis $onMode dSquashButton;
   shelfButton -e -vis $onMode dTwistButton;
   shelfButton -e -vis $onMode dWaveButton;
   shelfButton -e -vis $onMode dClusterButton;  
   shelfButton -e -vis $onMode dLatticeButton;  
   shelfButton -e -vis $onMode dWrapButton;    
   shelfButton -e -vis $onMode dSculptButton;
   shelfButton -e -vis $onMode dSoftmodButton;     
   button -e -vis $onMode deformerCancelButton;  
}


global proc faceToolOverlay(int $onMode)
{// switch buttons of select face overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode fHoleButton;
   shelfButton -e -vis $onMode fBridgeButton;
   shelfButton -e -vis $onMode fPokeButton;
   shelfButton -e -vis $onMode fTrilateButton;
   shelfButton -e -vis $onMode fQuadlateButton;
   shelfButton -e -vis $onMode fWedgeButton;         
   button -e -vis $onMode fToolCancelButton;  
}


global proc edgeToolOverlay(int $onMode)
{// switch buttons of select face overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode ePolyButton;
   shelfButton -e -vis $onMode eInsertButton;
   shelfButton -e -vis $onMode eOffsetButton;   
   shelfButton -e -vis $onMode eRadialButton;
   shelfButton -e -vis $onMode eCutButton;
   shelfButton -e -vis $onMode eFlipButton;
   shelfButton -e -vis $onMode eSpinButton;
   shelfButton -e -vis $onMode eBevelButton;
   shelfButton -e -vis $onMode e35QuadButton;   
   button -e -vis $onMode eToolCancelButton; 
}


global proc curveToolOverlay(int $onMode)
{// switch buttons of curve tool overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode cNewCurve;
   shelfButton -e -vis $onMode cEPcurveButton;
   shelfButton -e -vis $onMode cCVcurveButton;
   shelfButton -e -vis $onMode cPencilButton;
   shelfButton -e -vis $onMode c2PtArcButton;
   shelfButton -e -vis $onMode c3PtArcButton;
   shelfButton -e -vis $onMode cCircleButton;   
   button -e -vis $onMode cToolCancelButton;
}


global proc nurbToolOverlay(int $onMode)
{// switch buttons of nurb tool overlay off or on
 // toggle main xtools grid
   gridLayout  -e -vis (1-$onMode) toolXGrid;
   shelfButton -e -vis $onMode nLoftButton;
   shelfButton -e -vis $onMode nExtrudeButton;
   shelfButton -e -vis $onMode nRevolveButton;
   shelfButton -e -vis $onMode nBoundaryButton;
   shelfButton -e -vis $onMode nSquareButton;
   shelfButton -e -vis $onMode nBirail1Button;
   shelfButton -e -vis $onMode nBirail2Button;
   shelfButton -e -vis $onMode nBirail3Button;
   shelfButton -e -vis $onMode nPlanarButton;
   shelfButton -e -vis $onMode nBevelPlusButton;   
   button -e -vis $onMode nToolCancelButton;  
}


global proc setPolyTools()
{ // begin the Polygon Tools 
  global int $helpOn;
  global int $shelfSet;
  $shelfSet = 1;
  if (!$helpOn) window -e -t "X-Tools 3.9.6 Poly" xToolsWindow;
  menuItem -e -en 1 xInteractive;
  print ("Poly Tools Loaded.\n");
  string $currentTool = `currentCtx`;  
  if ($currentTool=="artPuttyContext")
    setToolTo selectSuperContext;
  setPolyMenus;
  setPolyButtons;
  if ($helpOn) setHelpTools;
}


global proc setNurbTools()
{ // begin the Nurb Tools 
  global int $helpOn;
  global int $shelfSet;
  $shelfSet = 2;  
  if (!$helpOn) window -e -t "X-Tools 3.9.6 Nurb" xToolsWindow;
  menuItem -e -en 1 xInteractive;
  print ("Nurb Tools Loaded.\n");
  string $currentTool = `currentCtx`;  
  if ($currentTool=="artPuttyContext")
    setToolTo selectSuperContext;
  setNurbMenus;
  setNurbButtons;
  if ($helpOn) setHelpTools;
}


global proc setGeneralTools()
{ // begin the Polygon Tools 
  global int $helpOn;
  global int $shelfSet;
  $shelfSet = 3;
  if (!$helpOn) window -e -t "X-Tools 3.9.6 General" xToolsWindow;
  menuItem -e -en 0 xInteractive;
  print ("General Tools Loaded.\n");
  string $currentTool = `currentCtx`;  
  if ($currentTool=="artPuttyContext")
    setToolTo selectSuperContext;
  setGeneralMenus;
  setGeneralButtons;
  if ($helpOn) setHelpTools;
}


global proc setPolyButtons()
{ // begin the Polygon Tools 
  global int $isMaya8Plus;
  global int $isMaya85Plus;
  global string $iconPath;
  global int $keepFacesTogether;
  global int $polyInterActive;
  global int $nurbInterActive;
  string $currentSelection[];
 // show main grid
  gridLayout -e -vis 1 toolXGrid;
 // turn off sculpt overlay controls
  sculptOverlay (0);
 // first row begins
  shelfButton -e -vis 1
    -image ($iconPath + "paintselection.xpm") -ann "Artisan Select Face"
    -command "paintSelectMode" -doubleClickCommand "paintSelectOptions" xbutton1; 
  shelfButton -e -vis 1
    -image ($iconPath + "selectloopbrd.xpm") -ann "Select Loop or Border"
    -command "selectLoopRing(1,0,0);" xbutton2;           
  shelfButton -e -vis 1
    -image ($iconPath + "togglewosnoop.xpm") -ann "Wire Frame Display"
    -command "toggleWos" xbutton3;   
  shelfButton -e -vis 1
    -image ($iconPath + "comptoggle.xpm") -ann "Toggle Object Display"
    -command "toggleComp" -doubleClickCommand "CustomPolygonDisplayOptions;" xbutton4; 
  shelfButton -e -vis 1
    -image ($iconPath + "togglenormal.xpm") -ann "Toggle Normals"
    -command "togglePolyNormals" -doubleClickCommand "normalDisplayOverlay(1);" xbutton5;
 // first row ends - second row begins
  if (`about -win`)
     shelfButton -e -vis 1 
       -image ($iconPath + "aligntoface.xpm") -ann "Align Move Manipulator to Component"
       -command "alignToSelection" -doubleClickCommand "reAlignOptions" xbutton6;
  else 
     shelfButton -e -vis 1 
	 -image ($iconPath + "aligntoface.xpm")
	 -ann "Align Move Manipulator"
	 -command "alignToSelection"
	 -doubleClickCommand "toolPropertyWindow; manipMoveProperties; manipMoveValues Move; toolPropertyShow;" xbutton6;          
  shelfButton -e -vis 1
    -image ($iconPath + "splitedgering.xpm") -ann "Edge Ring Split"
    -command "uberSplitEdge" -doubleClickCommand "SplitEdgeRingToolOptions;" xbutton7;         
  $currentSelection = `ls -sl -fl`;   
  if ((size($currentSelection)>0)&&(!`gmatch $currentSelection[0] "*.*"`))
       shelfButton -e -vis 1
    -image ($iconPath + "appendpoly.xpm") -ann "Append to Polygon"
    -command "uberNewFace" -doubleClickCommand "faceToolOverlay(1); setToolTo selectSuperContext" xbutton8;
  else shelfButton -e -vis 1
    -image ($iconPath + "createpoly.xpm") -ann "Create New Polygon"
    -command "uberNewFace" -doubleClickCommand "faceToolOverlay(1); setToolTo selectSuperContext" xbutton8;
  shelfButton -e -vis 1
    -image ($iconPath + "xpolysoftedge.xpm") -ann "Toggle Hardness"
    -command "toggleEdgeHardness" -doubleClickCommand "PolygonSoftenHardenOptions;" xbutton9;       
  shelfButton -e -vis 1 
    -image ($iconPath + "conformnormal.xpm") -ann "Conform Normals"
    -command "conformPolyNormals" xbutton10;	        
 // second row ends - third row begins
  shelfButton -e -vis 1
    -image ($iconPath + "mergevertex.xpm") -ann "Merge"
    -command "mergePolyVertices" -doubleClickCommand "undo; MergeVerticesOptions;" xbutton11;
  shelfButton -e -vis 1 
    -image ($iconPath + "ubertweek.xpm") -ann "Sculpt Tool"
    -command "sculptTweek" -doubleClickCommand sculptTweekOptions xbutton12;
  shelfButton -e -vis 1
    -image ($iconPath + "uberextrude.xpm") -ann "Extrude Face/Edge"
    -command "uberExtrude" xbutton13;   
  shelfButton -e -vis 1
    -image ($iconPath + "mirrorpoly.xpm") -ann "Mirror Geometry" -command "setdirectiontoMirror; directionButtonOverlay(1)" xbutton14;           	 
  shelfButton -e -vis 1
    -image ($iconPath + "xungroup.xpm") -ann "UnGroup"
    -command "breakOfFace" xbutton15;        
 //third row ends - fourth row begins
  shelfButton -e -vis 1 
    -image ($iconPath + "pcube.xpm") -ann "Poly Cube"
    -command "CreatePolygonCube" xbutton16;    
  shelfButton -e -vis 1
    -image ($iconPath + "polysmooth.xpm") -ann "Poly Smooth"
    -command "smoothPolyMesh" -doubleClickCommand "SmoothPolygonOptions;" xbutton17;	        
  shelfButton -e -vis 1 
    -image ($iconPath + "freezetrans.xpm") -ann "Freeze Transformations"
    -command "freezeTransformNode" xbutton18;        
  shelfButton -e -vis 1
    -image ($iconPath + "centerpivot.xpm") -ann "Center Pivot on Selection"
    -command "reCenterPivot" xbutton19;  
  shelfButton -e -vis 1
    -image ($iconPath + "deletethings.xpm") -ann "Delete history"
    -command "deleteShapeHistory" xbutton20;
}


global proc setPolyMenus()
{ // begin the Polygon Tools 
  global int $isMaya8Plus;
  global int $isMaya85Plus;
  global string $iconPath;
  global int $keepFacesTogether;
  global int $polyInterActive;
  global int $nurbInterActive;
 // first row begins
  popupMenu -e -dai xpopup1; 
  popupMenu -e -mm 1 xpopup1;  
       menuItem -p xpopup1 -rp "N" -label "Component Finder..." -command "faceSelectOverlay(1);" xmenu1n;
       menuItem -p xpopup1 -rp "E" -label "Object Mode" -command "xObjectMode" xmenu1e;       
       menuItem -p xpopup1 -rp "W" -label "Lasso Tool" -command "setToolTo lassoSelectContext" xmenu1w; 
       menuItem -p xpopup1 -rp "S" -label "View Selected" -command "isolateSelection" xmenu1s;        
       menuItem -p xpopup1 -label "Select Half Mesh ..." -command "setdirectiontoSelectHalf; directionButtonOverlay(1)" xmenu1m1;
       menuItem -p xpopup1 -divider 1;
       menuItem -p xpopup1 -label "Select All Meshes" -command "SelectAllPolygonGeometry;" xmenu2s;      
  popupMenu -e -dai xpopup2;
  popupMenu -e -mm 1 xpopup2;
       menuItem -p xpopup2 -rp "W" -label "Contained Vertices" -command "setToolTo selectSuperContext; PolySelectConvert 3;" xmenu2w;
       if ($isMaya85Plus)
         menuItem -p xpopup2 -rp "N" -label "Grow Loop" -command "selectLoopRing(1,1,0);" xmenu2n;    
       else
         menuItem -p xpopup2 -rp "N" -label "Spacing Options" -command "selectLoopOverlay(1)" xmenu2n;
       if ($isMaya85Plus)
         menuItem -p xpopup2 -rp "NE" -label "Edge Pattern" -command "selectLoopRing(1,0,1)" xmenu2ne;
       menuItem -p xpopup2 -rp "E" -label "Contained Faces" -command "setToolTo selectSuperContext; PolySelectConvert 10;" xmenu2e;
       menuItem -p xpopup2 -rp "S" -label "Convert to FacePath" -command edgeToFacePath xmenu2s;       
       menuItem -p xpopup2 -label "Convert to Curve" -command loopToCurve xmenu2m1;
       menuItem -p xpopup2 -divider 1;        
       menuItem -p xpopup2 -label "Separate on Loop" -command splitOnLoop xmenu2m2;       
  popupMenu -e -dai xpopup3;
  popupMenu -e -mm 1 xpopup3;	 
       menuItem -p xpopup3 -rp "N" -label "Display Modes" -command "polyDisplayOverlay(1)" xmenu3n;
       menuItem -p xpopup3 -rp "W" -label "XRay" -command "toggleXray" xmenu3w;
       menuItem -p xpopup3 -rp "E" -label "Poly Info" -command "TogglePolyCount" xmenu3e;      
       menuItem -p xpopup3 -rp "S" -label "View Selected" -command "isolateSelection" xmenu3s;       
       menuItem -p xpopup3 -label "Show Hidden Meshes" -command "ShowPolygonSurfaces; ShowSubdivSurfaces;" xmenu3m1;   
  popupMenu -e -dai xpopup4;
  popupMenu -e -mm 1 xpopup4;
       menuItem -p xpopup4 -rp "E" -label "Border Edges" -command "ToggleBorderEdges;" xmenu4e;
       menuItem -p xpopup4 -rp "W" -label "Soft Edges" -command "ToggleSoftEdges;" xmenu4w;
       menuItem -p xpopup4 -rp "S" -label "Face Centers" -command "TogglePolygonFaceCenters;" xmenu4s;
       menuItem -p xpopup4 -rp "N" -label "Vertices" -command "ToggleVertices;" xmenu4n;  
  popupMenu -e -dai xpopup5;
  popupMenu -e -mm 1 xpopup5;
       menuItem -p xpopup5 -rp "SW" -label "Tiny" -command "setNormalsSize .05;" xmenu5sw;     
       menuItem -p xpopup5 -rp "NW" -label "Short" -command "setNormalsSize .16;" xmenu5nw;
       menuItem -p xpopup5 -rp "NE" -label "Medium" -command "setNormalsSize .4;" xmenu5ne;
       menuItem -p xpopup5 -rp "SE" -label "Long" -command "setNormalsSize 1;" xmenu5se;
       menuItem -p xpopup5 -rp "N" -label "Half" -command "polyOptions -r -sn 0.5" xmenu5n;  
       menuItem -p xpopup5 -rp "S" -label "Double" -command "polyOptions -r -sn 2" xmenu5s;
 // first row ends - second row begins
  popupMenu -e -dai xpopup6;
  popupMenu -e -mm 1 xpopup6;
       menuItem -p xpopup6 -rp "N" -label "Align Pivot" -command "alignManip" xmenu6n;          
       menuItem -p xpopup6 -rp "W" -label "Align to Object" 
         -command "manipMoveContext -e -mode 0 -orientAxes 0 0 0 Move;" xmenu6w;         
       menuItem -p xpopup6 -rp "E" -label "Align to Local" 
         -command "manipMoveContext -e -mode 1 -orientAxes 0 0 0 Move;" xmenu6e;         
       if ($isMaya8Plus)
         menuItem -p xpopup6 -rp "S" -label "Transform Component" 
           -command "setToolTo moveSuperContext; MovePolygonComponent;" xmenu6s;            
       else
         menuItem -p xpopup6 -rp "S" -label "Move Component" 
           -command "setToolTo moveSuperContext; MovePolygonComponent;" xmenu6s;                
  popupMenu -e -dai xpopup7;
  popupMenu -e -mm 1 -aob true xpopup7;
       menuItem -p xpopup7 -rp "W" -label "Radial Ring Split" -command "turnOffToolMessages; radialEdgeSplit; restoreToolMessagesSettings;" xmenu7w; 
       menuItem -p xpopup7 -rp "N" -label "Edge Tools..." -command "edgeToolOverlay(1)" xmenu7n;    
       menuItem -p xpopup7 -rp "E" -label "Cut Face" -command "CutPolygon" xmenu7e;        
       menuItem -p xpopup7 -ob true -command "CutPolygonOptions" xmenu7eo;
       menuItem -p xpopup7 -rp "NE" -label "Insert Loop Options" -command "SplitEdgeRingToolOptions;" xmenu7ne;       
       menuItem -p xpopup7 -rp "S" -label "Split Poly" -command "polySoftEdge -a 0; select -cl;" xmenu7s;
       menuItem -p xpopup7 -ob true -command "SplitPolygonToolOptions;" xmenu7so;
       menuItem -p xpopup7 -label "Reverse Edge" -command "reverseEdgeDir" xmenu7m1;       
       menuItem -p xpopup7 -label "Crease Edge" -command "creaseButtonOverlay(1)" xmenu7m2;       
  popupMenu -e -dai xpopup8;
  popupMenu -e -mm 1 -pmc "updateInteractiveFlags" xpopup8;
       menuItem -p xpopup8 -rp "W" -label "Chamfer" -command "polyChamferVtx 1 0.25 0;" xmenu8w;
       menuItem -p xpopup8 -rp "N" -label "Face Tools..." -command "faceToolOverlay(1)" xmenu8n;
       if ($isMaya8Plus)
         menuItem -p xpopup8 -rp "E" -label "Bridge" -command "BridgeEdge" xmenu8e;
       if ($isMaya8Plus)
         menuItem -p xpopup8 -ob true -command "BridgeEdgeOptions" xmenu8eo; 
       menuItem -p xpopup8 -rp "S" -label "Fill Hole" -command "polyCloseBorder -ch 1;" xmenu8s;
  popupMenu -e -dai xpopup9;
  popupMenu -e -mm 1 xpopup9;
       menuItem -p xpopup9 -rp "S" -label "All Hard" -command "polySoftEdge -a 0; select -cl;" xmenu9s;
       menuItem -p xpopup9 -rp "N" -label "All Soft" -command "polySoftEdge -a 180; select -cl;" xmenu9n;    
       menuItem -p xpopup9 -rp "NW" -label "90 Hard" -command "polySoftEdge -a 90; select -cl;" xmenu9nw;
       menuItem -p xpopup9 -rp "NE" -label "60 Hard" -command "polySoftEdge -a 60; select -cl;" xmenu9ne;
       menuItem -p xpopup9 -rp "SE" -label "45 Hard" -command "polySoftEdge -a 45; select -cl;" xmenu9se;
       menuItem -p xpopup9 -rp "SW" -label "30 Hard" -command "polySoftEdge -a 30; select -cl;" xmenu9sw;       
  popupMenu -e -dai xpopup10;
  popupMenu -e -mm 1 xpopup10;
       menuItem -p xpopup10 -rp "N" -label "Flip Normal" -command "ReversePolygonNormals;" xmenu10n;
       menuItem -p xpopup10 -rp "S" -label "Set to Face" -command "polySetToFaceNormal;" xmenu10s;       
 // second row ends - third row begins
  popupMenu -e -dai xpopup11;
  popupMenu -e -mm 1 xpopup11;
       menuItem -p xpopup11 -rp "N" -label "Merge to Center" -command "MergeToCenter;" xmenu11n; 
       menuItem -p xpopup11 -rp "NW" -label "Merge to Nearest" -command "mergetoNearest;" xmenu11nw;
       menuItem -p xpopup11 -rp "NE" -label "Merge Options" -command "MergeVerticesOptions;" xmenu11ne;       
       menuItem -p xpopup11 -rp "S"  -label "Merge Edge Tool" -command "MergeEdgeTool; changeToolIcon;" xmenu11s;
       menuItem -p xpopup11 -rp "W" -label "Collapse" -command "PolygonCollapse;" xmenu11w;
       menuItem -p xpopup11 -rp "E" -label "CollapseRing" -command "SelectEdgeRing; polyCollapseEdge;" xmenu11e;
       menuItem -p xpopup11 -label "Split Vertex" -command "SplitVertex;" xmenu11m1;
  popupMenu -e -dai xpopup12;
  popupMenu -e -mm 1 -allowOptionBoxes true xpopup12;
       menuItem -p xpopup12 -rp "N"  -label "Deformers..." -command "deformerOverlay(1)" xmenu12n;
       menuItem -p xpopup12 -rp "E"  -label "Lattice" -command "CreateLattice;" xmenu12e;
       menuItem -p xpopup12 -ob true -command "CreateLatticeOptions;" xmenu12eo;
       menuItem -p xpopup12 -rp "W"  -label "Wrap" -command "CreateWrap;" xmenu12w;  
       menuItem -p xpopup12 -ob true -command "CreateWrapOptions;" xmenu12wo;    
       menuItem -p xpopup12 -rp "S"  -label "SoftMod" -command "softModTweek;" xmenu12s;
       menuItem -p xpopup12 -ob true -command "softModTweekOptions;" xmenu12no;       
       menuItem -p xpopup12 -label "Cluster" -command "CreateCluster;" xmenu12m1;
       menuItem -p xpopup12 -ob true -command "CreateClusterOptions;" xmenu12m1o;   
       menuItem -p xpopup12 -divider 1;
       menuItem -p xpopup12 -label "SoftMod at selection" -command "placeSoftMod" xmenu12m2; 
  popupMenu -e -dai xpopup13;    
  popupMenu -e -mm 1 -pmc "updateTogetherFlags" xpopup13;  
       menuItem -p xpopup13 -rp "N" -label "Faces Together" 
         -cb $keepFacesTogether // check box set by upDateFlag Procedure
         -command "togglePolyMoveComponents; updateTogetherFlags;" xmenu13n;     
  popupMenu -e -dai xpopup14;
  popupMenu -e -mm 1 xpopup14; 
        menuItem -p xpopup14 -rp "N" -label "Mirror Duplicate..." -command "mirrorDuplicateOverlay(1);" xmenu14n;
        menuItem -p xpopup14 -rp "W" -label "Group" -command "Group;" xmenu14w;
        menuItem -p xpopup14 -rp "E" -label "Parent" -command "Parent;" xmenu14e;
        menuItem -p xpopup14 -rp "S" -label "Combine Plus" -command "uberCombine" xmenu14s;
  popupMenu -e -dai xpopup15;
  popupMenu -e -mm 1 -pmc "updateTogetherFlags" xpopup15;    
       menuItem -p xpopup15 -rp "W" -label "UnGroup" -command "Ungroup;" xmenu15w;
       menuItem -p xpopup15 -rp "E" -label "UnParent" -command "Unparent;" xmenu15e;  
       menuItem -p xpopup15 -rp "S" -label "Separate" 
         -command "SeparatePolygon; DeleteHistory; pickWalk -d up; ungroup;" xmenu15s;            
       menuItem -p xpopup15 -rp "N" -label "Faces Together"        
        -cb $keepFacesTogether
        -command "togglePolyMoveComponents; updateTogetherFlags;"  xmenu15n; 
       menuItem -p xpopup15 -label "Extract Half ..." -command "setdirectiontoExtractHalf; directionButtonOverlay(1)" xmenu15m1;
       menuItem -p xpopup15 -label "Duplicate Half ..." -command "setdirectiontoDuplicateHalf; directionButtonOverlay(1)" xmenu15m2;       
       menuItem -p xpopup15 -divider 1;        
       menuItem -p xpopup15 -label "Separate on Loop" -command splitOnLoop xmenu15m3;   
 //third row ends - fourth row begins
  popupMenu -e -dai xpopup16;
  popupMenu -e -mm 1 -pmc "updateInteractiveFlags" -aob true xpopup16;    
       menuItem -p xpopup16 -rp "N" -label "More Shapes..." -command "polyShapeOverlay(1)" xmenu16n; 
       menuItem -p xpopup16 -rp "S" -label "Polygon CleanUp..." -command "CleanupPolygonOptions" xmenu16s;   
       if ($isMaya8Plus)
       {
         menuItem -p xpopup16 -label "Interactive" -cb $polyInterActive
            -command "toggleCreatePolyPrimitiveAsTool;" xmenu16m1;  
         menuItem -p xpopup16 -divider 1;    
       } 
       menuItem -p xpopup16 -label "Make Live/Not Live" -command "MakeLive;" xmenu8m2;
       menuItem -p xpopup16 -divider 1;  
       menuItem -p xpopup16 -label "Plane"  -command "CreatePolygonPlane" xmenu8m3; 
       menuItem -p xpopup16 -label "Sphere" -command "CreatePolygonSphere" xmenu8m4;   
  popupMenu -e -dai xpopup17;
  popupMenu -e -mm 1 xpopup17;    
       menuItem -p xpopup17 -rp "N" -label "Average Vertices" -command "performPolyAverageVertex 0;" xmenu17n;
       menuItem -p xpopup17 -rp "S" -label "Proxy..." -command "SmoothProxyOptions;" xmenu17s;
       menuItem -p xpopup17 -rp "E" -label "SubDivide Faces" -command "SubdividePolygon;" xmenu17e;	        
  popupMenu -e -dai xpopup18;
  popupMenu -e -mm 1 xpopup18;    
       menuItem -p xpopup18 -rp "W" -label "Duplicate" -command "duplicate -rr;" xmenu18w;
       menuItem -p xpopup18 -rp "E" -label "Instance" -command "instance;" xmenu18e; 
       if ($isMaya8Plus)
         menuItem -p xpopup18 -rp "N" -label "Duplicate Special" -command "DuplicateSpecialOptions;" xmenu18n;       
       else menuItem -p xpopup18 -rp "N" -label "Duplicate Options" -command "DuplicateOptions;" xmenu18n; 
  popupMenu -e -dai xpopup19;
  popupMenu -e -mm 1 xpopup19;
       menuItem -p xpopup19 -rp "N"  -label "More Positions ..." -command "setdirectiontoCenterPivot; directionButtonOverlay(1);" xmenu19n;
       menuItem -p xpopup19 -rp "W"-label "Copy Pivot" -command "storePivot;" xmenu19w;
       menuItem -p xpopup19 -rp "E"-label "Paste Pivot" -command "recallPivot;" xmenu19e;  
       menuItem -p xpopup19 -rp "S" -label "Center Selection" -command "centerButtonOverlay(1)" xmenu19s;     
       menuItem -p xpopup19 -label "Stand on Grid" -command "standOnGrid;" xmenu19m1;          
  popupMenu -e -dai xpopup20;
  popupMenu -e -mm 1 xpopup20;    
       menuItem -p xpopup20 -rp "N" -label "Delete All History" -command "delete -all -constructionHistory;" xmenu20n;
       menuItem -p xpopup20 -rp "W" -label "Delete Edge" -command "deleteEdgeClean;" xmenu20w;
       menuItem -p xpopup20 -rp "E" -label "Delete Loop" -command "PolyConvertToLoopAndDelete;" xmenu20e;
       menuItem -p xpopup20 -rp "S" -label "Delete Construction Shapes" -command delConstructShapes xmenu20s;
       menuItem -p xpopup20 -label "Delete Half Mesh ..." -command "setdirectiontoDeleteHalf; directionButtonOverlay(1)" xmenu20m1;
       menuItem -p xpopup20 -divider 1;
       menuItem -p xpopup20 -label "Delete Image Planes" -command "delete `ls -type imagePlane`;" xmenu20m2;       
       menuItem -p xpopup20 -label "Delete Empty Groups" -command "deleteEmptyTransforms;" xmenu20m3;
}


global proc setNurbButtons()
{ // begin the Nurb Tools
  global int $isMaya8Plus;
  global int $isMaya85Plus;  
  global string $iconPath; 
  global int $nurbInterActive;
 // show main grid
  gridLayout -e -vis 1 toolXGrid;
 // turn off sculpt overlay controls
  sculptOverlay (0);
 // first row begins
  shelfButton -e -vis 1
    -image ($iconPath + "paintcv.xpm") -ann "Artisan CV Select"
    -command "paintSelectMode" -doubleClickCommand "paintSelectOptions" xbutton1;
  shelfButton -e -vis 1 
    -image ($iconPath + "selectnurbedge.xpm") -ann "Iso Selection"
    -command "selectNurbEdge" xbutton2;
  shelfButton -e -vis 1
    -image ($iconPath + "togglewosnoop.xpm") -ann "Wire Frame Display"
    -command "toggleWos" xbutton3;
  shelfButton -e -vis 1 
    -image ($iconPath + "compnurbtoggle.xpm") -ann "Toggle Object Display"
    -command "toggleCVDisplay;" -doubleClickCommand "CustomNURBSComponentsOptions;" xbutton4;
  shelfButton -e -vis 1
    -image ($iconPath + "reversenurbnormal.xpm") -ann "Reverse Nurb Normals"
    -command "reverseNurb;" -doubleClickCommand "ReverseSurfaceDirectionOptions;" xbutton5;
 // first row ends - second row begins
  shelfButton -e -vis 1
    -image ($iconPath + "movenormal.xpm") -ann "Align Manipulator to Component" -command "activateMoveNormal;"         
    -doubleClickCommand "manipMoveContext -e -mode 2 -orientAxes 0 0 0 Move; setToolTo moveSuperContext; toolPropertyWindow; manipMoveProperties; toolPropertyShow;" xbutton6;
  shelfButton -e -vis 1
    -image ($iconPath + "uberinsert.xpm")
    -ann "Insert Knot/Iso-Parm" -command "uberinsert" xbutton7;  
  shelfButton -e -vis 1
    -image ($iconPath + "buildboundary.xpm")
    -ann "New Nurb Geometry" -command "newNurbPatch;" xbutton8;
  shelfButton -e -vis 1
    -image ($iconPath + "newcurve.xpm") -ann "New Curve"
    -command "uberNewCurve;" -doubleClickCommand "EPCurveToolOptions;" xbutton9;
  shelfButton -e -vis 1 
    -image ($iconPath + "projectcurve.xpm") -ann "Project Curve"
    -command "makeCurveOnSurface;" -doubleClickCommand TrimTool xbutton10;
 // second row end - third row begins       
  shelfButton -e -vis 1
    -image ($iconPath + "stitchnurb.xpm") -ann "Stitch"
    -command "makeGlobalStitch;" -doubleClickCommand "GlobalStitchOptions;" xbutton11;
  shelfButton -e -vis 1
    -image ($iconPath + "ubertweek.xpm") -ann "Sculpt Tool"
    -command "sculptTweek" -doubleClickCommand sculptTweekOptions xbutton12;
  shelfButton -e -vis 1 
    -image ($iconPath + "extrudenurbedge.xpm") -ann "Extrude Nurb Component"
    -command "extrudenurbedge;" xbutton13;
  shelfButton -e -vis 1 
    -image ($iconPath + "uberattach.xpm") -ann "Attach Nurb"  
    -command "attachNurbs" -doubleClickCommand "attachNurbsOptions;" xbutton14; 
  shelfButton -e -vis 1 
	 -image ($iconPath + "xungroup.xpm") -ann "UnGroup" 
	 -command "detachNurbUngroup;" -doubleClickCommand DetachSurfacesOptions xbutton15;
 // third row ends - fourth row begins          
  shelfButton -e -vis 1
    -image ($iconPath + "nsphere.xpm") -ann "Nurb Sphere"
    -command "CreateNURBSSphere" xbutton16;
  shelfButton -e -vis 1
    -image ($iconPath + "rebuildcurvenurb.xpm") -ann "Rebuild Nurb"
    -command "uberRebuildNurb;" -doubleClickCommand "rebuildNurbOptions;" xbutton17;
  shelfButton -e -vis 1
    -image ($iconPath + "freezetrans.xpm") -ann "Freeze Transformations"
    -command "freezeTransformNode;" xbutton18;
  shelfButton -e -vis 1
    -image ($iconPath + "centerpivot.xpm") -ann "Center Pivot on Selection"
    -command "reCenterPivot;" xbutton19;
  shelfButton -e -vis 1
    -image ($iconPath + "deletethings.xpm") -ann "Delete History"
    -command "deleteShapeHistory" xbutton20;
}


global proc setNurbMenus()
{ // begin the Nurb Tools
  global int $isMaya8Plus;
  global int $isMaya85Plus;  
  global string $iconPath; 
  global int $nurbInterActive;
 // first row begins
  popupMenu -e -dai xpopup1; 
  popupMenu -e -mm 1 xpopup1;  
     menuItem -p xpopup1 -rp "E" -label "Object Mode" -command "xObjectMode" xmenu1e;            
     menuItem -p xpopup1 -rp "W" -label "Lasso Tool" -command "setToolTo lassoSelectContext;" xmenu1w; 
     menuItem -p xpopup1 -rp "S" -label "Select All Surfaces" -command "SelectAllNURBSSurfaces;" xmenu1s;       
     menuItem -p xpopup1 -rp "N" -label "Select All Curves" -command "SelectAllNURBSCurves;" xmenu1n;       
  popupMenu -e -dai xpopup2; 
  popupMenu -e -mm 1 xpopup2; 	
     menuItem -p xpopup2 -rp "N" -label "Select all Edges" -command selectAllNurbEdges xmenu2n;	 
  popupMenu -e -dai xpopup3; 
  popupMenu -e -mm 1 xpopup3;	 
       menuItem -p xpopup3 -rp "N" -label "Display Modes" -command "nurbDisplayOverlay(1)" xmenu3n;
       menuItem -p xpopup3 -rp "W" -label "Curve Display" -command "toggleCurveDisplay" xmenu3w;   
       menuItem -p xpopup3 -rp "E" -label "Surface Display" -command "toggleSurfaceDisplay" xmenu3e;
       menuItem -p xpopup3 -rp "S" -label "Show Hidden Curves" -command "ShowNURBSCurves;" xmenu3s;
       menuItem -p xpopup3 -label "Show Hidden Surfaces" -command "ShowNURBSSurfaces;" xmenu3m1;       
  popupMenu -e -dai xpopup4; 
  popupMenu -e -mm 1 xpopup4;
       menuItem -p xpopup4 -rp "N" -label "Hulls" -command "ToggleHulls;" xmenu4n;
       menuItem -p xpopup4 -rp "W" -label "Edit Points" -command "ToggleEditPoints;" xmenu4w;
       menuItem -p xpopup4 -rp "S" -label "Patch Centers" -command "ToggleSurfaceFaceCenters;" xmenu4s;
       menuItem -p xpopup4 -rp "E" -label "Normals" -command "ToggleNormals;" xmenu4e;
  popupMenu -e -dai xpopup5; 
 // first row ends - second row begins
  popupMenu -e -dai xpopup6; 
  popupMenu -e -mm 1 xpopup6;
       menuItem -p xpopup6 -rp "N" -label "Align Pivot" -command "alignManip" xmenu6n;     
       menuItem -p xpopup6 -rp "S" -label "Align to World" -command "manipMoveContext -e -mode 2 -orientAxes 0 0 0 Move;" xmenu6s;         
       menuItem -p xpopup6 -rp "W" -label "Align to Object" -command "manipMoveContext -e -mode 0 -orientAxes 0 0 0 Move;" xmenu6w;         
       menuItem -p xpopup6 -rp "E" -label "Align to Local" -command "manipMoveContext -e -mode 1 -orientAxes 0 0 0 Move;" xmenu6e;         
       menuItem -p xpopup6 -label "Align Components" -command "centerButtonOverlay(1)" xmenu6m1;            
  popupMenu -e -dai xpopup7;     
  popupMenu -e -dai xpopup8; 
  popupMenu -e -mm 1 xpopup8;    
       menuItem -p xpopup8 -rp "S" -label "Loft" -command "Loft;" xmenu8s;
       menuItem -p xpopup8 -rp "W" -label "Revolve" -command "Revolve;" xmenu8w;        
       menuItem -p xpopup8 -rp "E" -label "Square" -command "SquareSurface;" xmenu8e;  
       menuItem -p xpopup8 -rp "N" -label "Nurb Tools..." -command "nurbToolOverlay(1);" xmenu8n;        ; 
  popupMenu -e -dai xpopup9; 
  popupMenu -e -mm 1 xpopup9;
       menuItem -p xpopup9 -rp "W" -label "CV Curve Tool"  -command "CVCurveTool;" xmenu9w;
       menuItem -p xpopup9 -rp "E" -label "EP Curve Tool"  -command "EPCurveTool;" xmenu9e;       
       menuItem -p xpopup9 -rp "S" -label "Close Curve" -command "OpenCloseCurve;" xmenu9s; 
       menuItem -p xpopup9 -rp "N" -label "Curve Tools..." -command "curveToolOverlay(1);" xmenu9n;          
  popupMenu -e -dai xpopup10; 
  popupMenu -e -mm 1 xpopup10;
       menuItem -p xpopup10 -rp "N" -label "Trim" -command "TrimTool;" xmenu10n;
       menuItem -p xpopup10 -rp "S" -label "UnTrim" -command "UntrimSurfaces;" xmenu10s;
       menuItem -p xpopup10 -rp "W" -label "Nurb Boolean" -command "SurfaceBooleanIntersectTool;" xmenu10w;       
       menuItem -p xpopup10 -rp "E" -label "Intersect Surfaces" -command "IntersectSurfaces;" xmenu10e;   
 // second row end - third row begins       
  popupMenu -e -dai xpopup11; 
  popupMenu -e -mm 1 xpopup11;
       menuItem -p xpopup11 -rp "N" -label "Snap CVs to Center" -command snapCVtoCenter xmenu11n;         
  popupMenu -e -dai xpopup12; 
  popupMenu -e -mm 1 -allowOptionBoxes true xpopup12;
       menuItem -p xpopup12 -rp "N" -label "SoftMod" -command "softModTweek;" xmenu12n; 
       menuItem -p xpopup12 -ob true -command "softModTweekOptions;" xmenu12no;
       menuItem -p xpopup12 -rp "E" -label "Lattice" -command "CreateLattice;" xmenu12e;
       menuItem -p xpopup12 -ob true -command "CreateLatticeOptions;" xmenu12eo;
       menuItem -p xpopup12 -rp "W" -label "Wrap" -command "CreateWrap;" xmenu12w;  
       menuItem -p xpopup12 -ob true -command "CreateWrapOptions;" xmenu12wo;   
       menuItem -p xpopup12 -rp "S" -label "Cluster" -command "CreateCluster;" xmenu12s;  
       menuItem -p xpopup12 -ob true -command "CreateClusterOptions;" xmenu12so;          
       menuItem -p xpopup12 -label "Non-Linear Deformers..." -command "nonLinearDeformWindow;" xmenu12m1; 
  popupMenu -e -dai xpopup13; 
  popupMenu -e -mm 1 -allowOptionBoxes true xpopup13;
       menuItem -p xpopup13 -rp "N" -label "Extrude" -command Extrude xmenu13n;
       menuItem -p xpopup13 -ob true -command ExtrudeOptions xmenu13no;	  
  popupMenu -e -dai xpopup14; 
  popupMenu -e -mm 1 xpopup14;
       menuItem -p xpopup14 -rp "W" -label "Group" -command "Group;" xmenu14w;
       menuItem -p xpopup14 -rp "E" -label "Parent" -command "Parent;" xmenu14e;  
       menuItem -p xpopup14 -rp "N" -label "Mirror Duplicate..." -command "mirrorDuplicateOverlay(1);" xmenu14n;
  popupMenu -e -dai xpopup15; 
  popupMenu -e -mm 1 xpopup15;
       menuItem -p xpopup15 -rp "W" -label "UnGroup" -command "Ungroup;" xmenu15w;
       menuItem -p xpopup15 -rp "E" -label "UnParent" -command "Unparent;" xmenu15e;         
 // third row ends - fourth row begins          
  popupMenu -e -dai xpopup16; 
  popupMenu -e -mm 1 -pmc "updateInteractiveFlags"  xpopup16;   
       menuItem -p xpopup16 -rp "N" -label "Nurb Shapes" -command "nurbShapeOverlay(1)" xmenu16n;  
       menuItem -p xpopup16 -rp "S" -label "Convert to Polygon" -command "convertNurbHideOrg;" xmenu16s;
       menuItem -p xpopup16 -ob true -command "NURBSToPolygonsOptions;" xmenu16so;
       if ($isMaya8Plus)
       {
         menuItem -p xpopup16 -label "Interactive" -cb $nurbInterActive
            -command "toggleCreateNurbsPrimitiveAsTool;" xmenu16m1;  
         menuItem -p xpopup16 -divider 1;    
       } 
       menuItem -p xpopup16 -label "Make Live/Not Live" -command "MakeLive;" xmenu16m2;              
  popupMenu -e -dai xpopup17; 
  popupMenu -e -mm 1 xpopup17; 
       menuItem -p xpopup17 -rp "N" -label "Toggle Nurb Degree" -command nurbDegreeToggle xmenu17n; 	 
  popupMenu -e -dai xpopup18; 
  popupMenu -e -mm 1 xpopup18; 
       menuItem -p xpopup18 -rp "W" -label "Duplicate" -command "duplicate -rr;" xmenu18w;
       menuItem -p xpopup18 -rp "E" -label "Instance" -command "instance;" xmenu18e; 
       if ($isMaya8Plus)
         menuItem -p xpopup18 -rp "S" -label "Duplicate Special" -command "DuplicateSpecialOptions;" xmenu18s;       
       else menuItem -p xpopup18 -rp "S" -label "Duplicate Options" -command "DuplicateOptions;" xmenu18s; 
  popupMenu -e -dai xpopup19; 
  popupMenu -e -mm 1 xpopup19; 
       menuItem -p xpopup19 -rp "N"  -label "More Positions ..." -command "setdirectiontoCenterPivot; directionButtonOverlay(1);" xmenu19n;
       menuItem -p xpopup19 -rp "W" -label "Copy Pivot" -command "storePivot;" xmenu19w;
       menuItem -p xpopup19 -rp "E" -label "Paste Pivot" -command "recallPivot;" xmenu19e;  
       menuItem -p xpopup19 -rp "S" -label "Center Selection" -command "centerButtonOverlay(1)" xmenu19s;     
       menuItem -p xpopup19 -label "Stand on Grid" -command "standOnGrid;" xmenu19m1;          
  popupMenu -e -dai xpopup20; 
  popupMenu -e -mm 1 xpopup20; 
       menuItem -p xpopup20  -rp "N" -label "Delete All History" -command "delete -all -constructionHistory;" xmenu20n;
       menuItem -p xpopup20  -rp "S" -label "Delete Construction Shapes" -command delConstructShapes xmenu20s; 
       menuItem -p xpopup20 -label "Delete Image Planes" -command "delete `ls -type imagePlane`;" xmenu20m1;
       menuItem -p xpopup20 -label "Delete Empty Groups" -command "deleteEmptyTransforms;" xmenu20m2;   			
}


global proc setGeneralButtons()
{ // begin the General Buttons 
  global int $isMaya8Plus;
  global int $isMaya85Plus;
  global string $iconPath;
  string $currentSelection[];
 // show main grid
  gridLayout -e -vis 1 toolXGrid;
 // turn off sculpt overlay controls
  sculptOverlay (0);
 // first row begins
  shelfButton -e -vis 1
    -image ($iconPath + "paintselection.xpm") -ann "Artisan Select Face"
    -command "paintSelectMode;" -doubleClickCommand "paintSelectOptions" xbutton1;
  shelfButton -e -vis 1
    -image ($iconPath + "drawjoint.xpm") -ann "Draw Joints"
    -command "drawJoint;" -doubleClickCommand "JointToolOptions;" xbutton2;
  shelfButton -e -vis 1 
    -image ($iconPath + "mirrorjoint.xpm") -ann "Mirror Joints"
    -command "MirrorJointOptions;" -doubleClickCommand ";" xbutton3;     
  shelfButton -e -vis 1 
    -image ($iconPath + "skinning.xpm") -ann "Bind Shapes"
    -command "SmoothBindSkin;" -doubleClickCommand ";" xbutton4;           
  shelfButton -e -vis 1
    -image ($iconPath + "pointconstraint.xpm") -ann "Add Point Constaint"
    -command "PointConstraint;" -doubleClickCommand ";" xbutton5;    
 // first row ends - second row begins
  shelfButton -e -vis 1
    -image ($iconPath + "gravity.xpm") -ann "Add Gravity"
    -command "addField" -doubleClickCommand ";" xbutton6;     
  shelfButton -e -vis 1 
    -image ($iconPath + "makeparticles.xpm") -ann "create a particle and emitter"
    -command "addParticle" -doubleClickCommand ";" xbutton7;
  shelfButton -e -vis 1
    -image ($iconPath + "makerigid.xpm") -ann "Make a Rigid Body"
    -command "addRigid" -doubleClickCommand ";" xbutton8;       
  shelfButton -e -vis 1 
    -image ($iconPath + "ncloth.xpm") -ann "Make N-Cloth"
    -command "addNCloth"  -doubleClickCommand ";" xbutton9;
  shelfButton -e -vis 1
   -image ($iconPath + "newfluid.xpm") -ann "New 2D Fluid with an Emitter"
    -command "addFluid" -doubleClickCommand ";" xbutton10;    
 // second row ends - third row begins
  shelfButton -e -vis 1
    -image ($iconPath + "uvtexturemap.xpm") -ann "Planar Map"
    -command "addUVMap" -doubleClickCommand ";" xbutton11;  
  shelfButton -e -vis 1 
    -image ($iconPath + "paintweights.xpm") -ann "Paint Weights"
    -command "ArtPaintSkinWeightsToolOptions;" -doubleClickCommand ";" xbutton12;
  shelfButton -e -vis 1 
    -image ($iconPath + "paintfx.xpm") -ann "create Paint FX"
    -command "PaintEffectsTool;" -doubleClickCommand ";"xbutton13;   
  shelfButton -e -vis 1
    -image ($iconPath + "fur.xpm") -ann "Add New Fur Description"
    -command "addFur" -doubleClickCommand ";" xbutton14;           	 
  shelfButton -e -vis 1
    -image ($iconPath + "hair.xpm") -ann "Add Hair"
    -command "addHair" -doubleClickCommand ";" xbutton15;        
 //third row ends - fourth row begins
  shelfButton -e -vis 1 
    -image ($iconPath + "makeshader.xpm") -ann "Make or assign a blinn"     
    -command "addShader" -doubleClickCommand ";" xbutton16;          
  shelfButton -e -vis 1 
    -image ($iconPath + "makelight.xpm") -ann "Make a Spotlight"
    -command "addLight" -doubleClickCommand ";" xbutton17;       
  shelfButton -e -vis 1 
    -image ($iconPath + "freezetrans.xpm") -ann "Freeze Transformations"
    -command "freezeTransformNode" xbutton18;        
  shelfButton -e -vis 1
    -image ($iconPath + "centerpivot.xpm") -ann "Center Pivot on Selection"
    -command "reCenterPivot" xbutton19;  
  shelfButton -e -vis 1
    -image ($iconPath + "deletethings.xpm") -ann "Delete history"
    -command "deleteShapeHistory" xbutton20;
}


global proc setGeneralMenus()
{ // begin the General Menus 
  global int $isMaya8Plus;
  global int $isMaya85Plus;
  global string $iconPath;
 // first row begins
  popupMenu -e -dai xpopup1; 
  popupMenu -e -mm 1 xpopup1;  
       menuItem -p xpopup1 -rp "N" -label "Special Components ..." -command "faceSelectOverlay(1);" xmenu1n;
       menuItem -p xpopup1 -rp "E" -label "Object Mode" -command "xObjectMode" xmenu1e;       
       menuItem -p xpopup1 -rp "W" -label "Lasso Tool" -command "setToolTo lassoSelectContext" xmenu1w; 
       menuItem -p xpopup1 -rp "S" -label "View Selected" -command "isolateSelection" xmenu1s;        
       menuItem -p xpopup1 -label "Select Half Mesh ..." -command "setdirectiontoSelectHalf; directionButtonOverlay(1)" xmenu1m1;
       menuItem -p xpopup1 -divider 1;
       menuItem -p xpopup1 -label "Select All Meshes" -command "SelectAllPolygonGeometry;" xmenu2s;
  popupMenu -e -dai xpopup2;
  popupMenu -e -mm 1 xpopup2;  
       menuItem -p xpopup2 -rp "N" -label "Set Radius" -command "jdsWin;" xmenu2n;
       menuItem -p xpopup2 -rp "E" -label "Prefix Joints" -command "PrefixHierarchyNames;" xmenu2e;
       menuItem -p xpopup2 -rp "W" -label "Search/Replace" -command "PrefixHierarchyNames;" xmenu2w; 
       menuItem -p xpopup2 -rp "S" -label "Toggle Local Axes" -command "ToggleLocalRotationAxes;" xmenu2s;      
  popupMenu -e -dai xpopup3;
  popupMenu -e -mm 1 -aob true xpopup3;
       menuItem -p xpopup3 -rp "N" -label "Orient Joint" -command "OrientJointOptions;" xmenu3n;
       menuItem -p xpopup3 -rp "E" -label "IK Handle" -command "IKHandleTool;" xmenu3e;
       menuItem -p xpopup3 -rp "S" -label "Insert Joint" -command "InsertJointTool;" xmenu3s;
       menuItem -p xpopup3 -rp "W" -label "Spline IK Handle" -command "IKSplineHandleTool;" xmenu3w; 	   
  popupMenu -e -dai xpopup4;
  popupMenu -e -mm 1 -aob true xpopup4;
       menuItem -p xpopup4 -rp "N" -label "Bind Pose" -command "GoToBindPose;" xmenu4n;
       menuItem -p xpopup4 -rp "NW" -label "Mirror Skin Weight" -command "MirrorSkinWeights;" xmenu4nw;
       menuItem -p xpopup4 -rp "NE" -label "Copy Skin Weight" -command "CopySkinWeights;" xmenu4ne;             
       menuItem -p xpopup4 -rp "E" -label "Pune Small Weights" -command "PruneSmallWeightsOptions;" xmenu4e;
       menuItem -p xpopup4 -rp "W" -label "Rigid bind" -command "RigidBindSkin;" xmenu4w;
       menuItem -p xpopup4 -rp "S" -label "Detach Skin" -command "DetachSkin;" xmenu4s;   
  popupMenu -e -dai xpopup5;
  popupMenu -e -mm 1 -aob true xpopup5;
       menuItem -p xpopup5 -rp "NW" -label "Aim" -command "AimConstraint;" xmenu5nw;
       menuItem -p xpopup5 -rp "NE" -label "Orient" -command "performOrientConstraint 0;" xmenu5ne;
       menuItem -p xpopup5 -rp "E" -label "Parent" -command "ParentConstraint;" xmenu5e;
       menuItem -p xpopup5 -rp "W" -label "Geometry" -command "GeometryConstraint;" xmenu5w;
       menuItem -p xpopup5 -rp "N"  -label "Normal" -command "performNormalConstraint 0;" xmenu5n;    
 // first row ends - second row begins
  popupMenu -e -dai xpopup6;
  popupMenu -e -mm 1 -aob true xpopup6;
       menuItem -p xpopup6 -rp "NW" -label "Radial" -command "Radial;" xmenu6nw;
       menuItem -p xpopup6 -rp "NE" -label "Newton" -command "Newton;" xmenu6ne;
       menuItem -p xpopup6 -rp "E" -label "Turbulence" -command "Turbulence;" xmenu6e;
       menuItem -p xpopup6 -rp "W" -label "Uniform" -command "Uniform;" xmenu6w;
       menuItem -p xpopup6 -rp "N"  -label "Volume Axis" -command "VolumeAxis;" xmenu6n;
       menuItem -p xpopup6 -rp "S"  -label "Affect Selected" -command "AffectSelectedObject;" xmenu6s;       
  popupMenu -e -dai xpopup7;
  popupMenu -e -mm 1 -aob true xpopup7;
       menuItem -p xpopup7 -rp "NE" -label "Collide" -command "MakeCollide;" xmenu7ne;
       menuItem -p xpopup7 -rp "NW" -label "Collision Event" -command "ParticleCollisionEvents;" xmenu7nw;      
       menuItem -p xpopup7 -rp "W" -label "Goal" -command "Goal;" xmenu7w;
       menuItem -p xpopup7 -rp "E"  -label "Instance" -command "ParticleInstancer;" xmenu7e;
       menuItem -p xpopup7 -rp "S"  -label "Dynamic Relationship" -command "DynamicRelationshipEditor;" xmenu7s;       
       menuItem -p xpopup7 -label "Particle Tool" -command "ParticleToolOptions;" xmenu7m1;
  popupMenu -e -dai xpopup8;
  popupMenu -e -mm 1 -aob true xpopup8;
       menuItem -p xpopup8 -rp "N" -label "Passive Rigid" -command "CreatePassiveRigidBody;" xmenu8n;
       menuItem -p xpopup8 -rp "NE" -label "Nail Constraint"  -command  "optionVar -iv constrainTypesOM 1; CreateConstraint; performDynamics 2Constrain 0;" xmenu8ne;
       menuItem -p xpopup8 -rp "E" -label  "Hinge Constraint"  -command "optionVar -iv constrainTypesOM 3; CreateConstraint; performDynamics 2Constrain 0;" xmenu8e;      
       menuItem -p xpopup8 -rp "SE" -label "Pin Constraint"    -command "optionVar -iv constrainTypesOM 2; CreateConstraint; performDynamics 2Constrain 0;" xmenu8Se; 
       menuItem -p xpopup8 -rp "S" -label  "Spring Constraint" -command "optionVar -iv constrainTypesOM 4; CreateConstraint; performDynamics 2Constrain 0;" xmenu8s; 
       menuItem -p xpopup8 -rp "W" -label "Soft Body" -command "CreateSoftBody;" xmenu8w;
       menuItem -p xpopup8 -rp "NW"  -label "Springs" -command "CreateSpring;" xmenu8nw;    
  popupMenu -e -dai xpopup9;
  popupMenu -e -mm 1 -aob true xpopup9;
       menuItem -p xpopup9 -rp "N"  -label "Passive NCloth" -command "nClothMakeCollide;" xmenu9n;
       menuItem -p xpopup9 -rp "E"  -label "Trans Const" -command "performCreateDynamicConstraint 0 \"transform\";" xmenu9e;
       menuItem -p xpopup9 -rp "S"  -label "Comp2Comp Const" -command "performCreateDynamicConstraint 0 \"pointToPoint\";" xmenu9s;
       menuItem -p xpopup9 -rp "W"  -label "Pnt2Srf Const" -command "performCreateDynamicConstraint 0 \"pointToSurface\";" xmenu9w;       
  popupMenu -e -dai xpopup10;
  popupMenu -e -mm 1 -aob true xpopup10;
       menuItem -p xpopup10 -rp "N" -label "Add Emitter" -command "FluidEmitter;" xmenu10n;
       menuItem -p xpopup10 -rp "E" -label "3D Container" -command "Create3DContainer;" xmenu10e;
       menuItem -p xpopup10 -rp "S" -label "Collide" -command "MakeFluidCollide;" xmenu10s;
       menuItem -p xpopup10 -rp "W" -label "Emit from Shape" -command "EmitFluidFromObject;" xmenu10w;                  
 // second row ends - third row begins
  popupMenu -e -dai xpopup11;
  popupMenu -e -mm 1 -aob true xpopup11;
      // menuItem -p xpopup11 -rp "N" -label "texture" -command "" xmenu11n;
       menuItem -p xpopup11 -rp "E" -label "Cylinder" -command "performPolyProjectionArgList \"1\" {\"0\", \"Cylindrical\", \"ls -selection\", \"0\"} \"\";" xmenu11e;
       menuItem -p xpopup11 -rp "S" -label "UV Editor" -command "TextureViewWindow;" xmenu11s;
       menuItem -p xpopup11 -rp "W" -label "Spherical" -command "performPolyProjectionArgList \"1\" {\"0\", \"Spherical\", \"ls -selection\", \"0\"} \"\";" xmenu11w;    
  popupMenu -e -dai xpopup12;
  popupMenu -e -mm 1 -aob true xpopup12;
       menuItem -p xpopup12 -rp "N" -label "Component Editor" -command "ComponentEditor;" xmenu12n;
       menuItem -p xpopup12 -rp  "E" -label "Paint SoftBody" -command "artAttrToolScript 3 \"particle\";" xmenu12e;
       menuItem -p xpopup12 -rp "S" -label "Paint Fluid" -command "PaintFluidsToolOptions" xmenu12s;
       menuItem -p xpopup12 -rp "W" -label "Paint NCloth" 
        -command "artAttrNClothToolScript 4 thickness; toolPropertyWindow; artAttrNClothProperties; artAttrNClothValues artAttrNClothContext; toolPropertyShow;" xmenu12w;    
  popupMenu -e -dai xpopup13;    
  popupMenu -e -mm 1 -aob true xpopup13;
       menuItem -p xpopup13 -rp "N" -label "Visor" -command "VisorWindow;" xmenu13n;
       menuItem -p xpopup13 -rp "E" -label "Make Paintable" -command "MakePaintable;" xmenu13e;
       menuItem -p xpopup13 -rp "S" -label "Current Settings" -command "TemplateBrushSettings;" xmenu13s;
       menuItem -p xpopup13 -rp "W" -label "Convert to Poly" -command "PaintEffectsToPoly;" xmenu13w;       
  popupMenu -e -dai xpopup14;
  popupMenu -e -mm 1 -aob true xpopup14;
      menuItem -p xpopup14 -rp "N" -label "Paint Fur Attr" -command "HfPaintHairAttrTool 1;" xmenu14n;
//       menuItem -p xpopup14 -rp "E" -label "fur" -command "" xmenu14e;
//       menuItem -p xpopup14 -rp "S" -label "fur" -command "" xmenu14s;
//       menuItem -p xpopup14 -rp "W" -label "fur" -command "" xmenu14w;      
  popupMenu -e -dai xpopup15;
  popupMenu -e -mm 1 -aob true xpopup15;
       menuItem -p xpopup15 -rp "N" -label "Paint Follicles" -command "paintHairTool 1;" xmenu15n;
//       menuItem -p xpopup15 -rp "E" -label "hair" -command "" xmenu15e;
       menuItem -p xpopup15 -rp "S" -label "Make Curve Dynamic" -command "MakeCurvesDynamic;" xmenu15s;
//      menuItem -p xpopup15 -rp "W" -label "hair" -command "" xmenu15w;                  
 //third row ends - fourth row begins
  popupMenu -e -dai xpopup16;
  popupMenu -e -mm 1 -aob true xpopup16;
       menuItem -p xpopup16 -rp "NW" -label "Ansiotrophic" -command "createAndAssignShader anisotropic \"\";" xmenu16nw;
       menuItem -p xpopup16 -rp "NE" -label "Phong" -command "createAndAssignShader phong \"\";" xmenu16ne;
       menuItem -p xpopup16 -rp "E" -label "Phong E" -command "createAndAssignShader phongE \"\";" xmenu16e;
       menuItem -p xpopup16 -rp "W" -label "Layered" -command "createAndAssignShader layeredShader \"\";" xmenu16w;
       menuItem -p xpopup16 -rp "N"  -label "Lambert" -command "createAndAssignShader lambert \"\";" xmenu16n;
       menuItem -p xpopup16 -rp "S"  -label "HyperShader" -command "HypershadeWindow;" xmenu16s;
       menuItem -p xpopup16 -label "Delete Unused Shaders" -command "deleteUnusedShader;" xmenu161;       
  popupMenu -e -dai xpopup17;
  popupMenu -e -mm 1 -aob true xpopup17;
       menuItem -p xpopup17 -rp "NW" -label "Ambient" -command "CreateAmbientLight;" xmenu17nw;
       menuItem -p xpopup17 -rp "NE" -label "Point" -command "CreatePointLight;" xmenu17ne;
       menuItem -p xpopup17 -rp "E" -label "Area" -command "CreateAreaLight;" xmenu17e;
       menuItem -p xpopup17 -rp "W" -label "Volume" -command "CreateVolumeLight;" xmenu17w;
       menuItem -p xpopup17 -rp "N"  -label "Directional" -command "CreateDirectionalLight;" xmenu17n;
       menuItem -p xpopup17 -rp "SW" -label "Break Links" -command "BreakLightLinks;" xmenu17sw;
       menuItem -p xpopup17 -rp "SE" -label "Make Links" -command "MakeLightLinks;" xmenu17se;     
       menuItem -p xpopup17 -rp "S" -label "Link Editor" -command "LightCentricLightLinkingEditor;" xmenu17s;       
  popupMenu -e -dai xpopup18;       
  popupMenu -e -mm 1 -aob true xpopup18;    
       menuItem -p xpopup18 -rp "N" -label "Duplicate" -command "duplicate -rr;" xmenu18n;
       menuItem -p xpopup18 -rp "S" -label "Instance" -command "instance;" xmenu18s; 
       if ($isMaya8Plus)
         menuItem -p xpopup18 -rp "E"  -label "Duplicate Special .." -command "DuplicateSpecialOptions;" xmenu18e;       
       else menuItem -p xpopup18 -rp "E" -label "Duplicate Options ..." -command "DuplicateOptions;" xmenu18e; 
       menuItem -p xpopup18 -rp "W" -label "Mirror Duplicate ..." -command "mirrorDuplicateWindow;" xmenu18w;                   
       menuItem -p xpopup18 -label "Center Selection" -command "centerButtonOverlay(1)" xmenu18m1;    
       menuItem -p xpopup18 -divider 1;  
       menuItem -p xpopup18 -label "Stand on Grid" -command "standOnGrid;" xmenu18m2;        
  popupMenu -e -dai xpopup19;
  popupMenu -e -mm 1 xpopup19;    
       menuItem -p xpopup19 -rp "N"  -label "Center Y+" -command "centerpivotconstrain(4);" xmenu19n;
       menuItem -p xpopup19 -rp "S"  -label "Center Y-" -command "centerpivotconstrain(1);" xmenu19s;
       menuItem -p xpopup19 -rp "NW"  -label "Center X+" -command "centerpivotconstrain(3);" xmenu19nw;
       menuItem -p xpopup19 -rp "NE"  -label "Center X-" -command "centerpivotconstrain(0);" xmenu19ne;
       menuItem -p xpopup19 -rp "SW"  -label "Center Z+" -command "centerpivotconstrain(5);" xmenu19sw;
       menuItem -p xpopup19 -rp "SE"  -label "Center Z-" -command "centerpivotconstrain(2);" xmenu19se;
       menuItem -p xpopup19 -label "Copy Pivot" -command "storePivot;" xmenu19m1;
       menuItem -p xpopup19 -label "Paste Pivot" -command "recallPivot;" xmenu19m2;  
  popupMenu -e -dai xpopup20;
  popupMenu -e -mm 1 xpopup20;    
       menuItem -p xpopup20 -rp "N" -label "Delete All History" -command "delete -all -constructionHistory;" xmenu20n;
       menuItem -p xpopup20 -rp "W" -label "Delete Edge" -command "deleteEdgeClean;" xmenu20w;
       menuItem -p xpopup20 -rp "E" -label "Delete Loop" -command "PolyConvertToLoopAndDelete;" xmenu20e;
       menuItem -p xpopup20 -rp "S" -label "Delete Construction Shapes" -command delConstructShapes xmenu20s;
       menuItem -p xpopup20 -label "Delete Image Planes" -command "delete `ls -type imagePlane`;" xmenu20m1;       
       menuItem -p xpopup20 -label "Delete Empty Groups" -command "deleteEmptyTransforms;" xmenu20m2;
}


global proc xToolsAbout ()
{ // opens about Dialog
  string $aboutString = "X-Tools 3.9.6 by Andrew Osiow (C) Copyright 2006 - 2009";

  $aboutString = $aboutString + "\n\nX-Tools was created to be the ultimate toolbox script for Maya.  The most common\n";
  $aboutString = $aboutString + "and powerful tools used in Maya have been grouped into themes for easy and logical\n";
  $aboutString = $aboutString + "access.  To speed up workflow, Many common sequences have compressed into one.\n";
  $aboutString = $aboutString + "step.  Other related functions have been loaded to context sensitive buttons, that do\n";
  $aboutString = $aboutString + "different functions under different situations.  X-Tools is like a modern cell phone -\n";
  $aboutString = $aboutString + "a lot of power in compact interface.";

  $aboutString = $aboutString + "\n\nShareware:  X-Tools 3.9.6 is presented as Shareware and is the result of hundreds of\n";
  $aboutString = $aboutString + "hours of my personal time.  I definetly feel it's worth a fee of $20.  If you agree then\n";
  $aboutString = $aboutString + "go to www.andrews3dbrain.com and click the \"payme\" buttom on the X-Tools page.\n\n";
  $aboutString = $aboutString + "Your financial support will encourage me to develop and expand X-Tools.\n";
  
  $aboutString = $aboutString + "\nThe X-Tools script can not be renamed or redistributed in whole or as individual\n";
  $aboutString = $aboutString + "procedures.  The author is not responsible for any hardware or software damage or\n";
  $aboutString = $aboutString + "the delay of any commercial or private project.\n";
  $aboutString = $aboutString + "\n-------------------------------------------------------------------";
  $aboutString = $aboutString + "---------------------------------------------------------------------\n";  
  $aboutString = $aboutString + "\nDedicated to the students of Expression Digital College ";
  $aboutString = $aboutString + "who have been incredibly\ninspiring to me.  Here's a short list of some of the notable ";
  $aboutString = $aboutString + "students that offered\nsuggestions to improve X-Tools or just loyal support:\n\n";
  $aboutString = $aboutString + "   Mike Bailey, Donna Lei, Melissa Nichols, Jason Tsang, Graham Payne,\n";
  $aboutString = $aboutString + "   Matt Benson, Eric Reed, Grabriel Kennedy, Collin Tullius, and Brian Smith.\n";
  confirmDialog -title "X-Tools About" -bgc 1.0 1.0 1.0 -message $aboutString -button "OK";
}


global proc sculptTweek ()
{// choose sculpt tool and auto set radius and max displacement
  SculptGeometryTool; 
 // guess at size of brush 
 // turning off
 // autoSetBrushSize;
  updateBrushGadets;
  string $currentBrushMode;
  string $currentTool = `currentCtx`;
  if ($currentTool == "artPuttyContext")
    $currentBrushMode = `artPuttyCtx -q -mtm $currentTool`;  
  updateBrushModeDisplay ($currentBrushMode);  
 // turn on sculpt overlay controls hide grid
  sculptOverlay (1);
}


global proc sculptTweekOptions ()
{ // opens tool options for sculpt tool
  SculptGeometryTool;
  toolPropertyWindow;
  artPuttyProperties;
  artPuttyValues artPuttyContext;
  toolPropertyShow;
}


global proc softModTweek ()
{ // choose softMod tool and auto set fall off radius
  global int $isMaya8Plus;
  select -cl;
  autoSetSoftModSize; 
//  if ($isMaya8Plus)
//    setSoftModFalloffMode("Surface");
  SoftModTool;
  updateSoftModGadets;
 // turn on sculpt overlay controls hide grid
  softModOverlay (1);      
}


global proc paintSelectMode()
{ //put brush in selection mode an turns on selected vertices display
  global int $shelfSet;  
  global int $addToBrushSelection;
  ArtPaintSelectTool; 
 // guess at size of brush 
 //turned off for now
 // autoSetBrushSize;
 // set script to reset brush gadgets
  updateBrushGadets;
  paintSelectOverlay (1);      
}


global proc paintSelectOptions ()
{ // opens tool options for paint select gadget
  toolPropertyWindow; 
  artSelectProperties; 
  artSelectValues artSelectContext;
  toolPropertyShow;
}


global proc softModTweekOptions ()
{ // displays softMod options
  SoftModTool;
  toolPropertyWindow;
  softModProperties;
  softModValues softModContext;
  toolPropertyShow; 
}


global proc updateSofModGadets()
{ // updates the softMod ovelay gadets to match the current SoftMod settings
  float $softModRadius;
  $softModRadius = `optionVar -q softModFalloffRadius`;
  floatField -e -v $softModRadius smRadFloat;
}


global proc updateBrushGadets()
{ // updates the brush ovelay gadets to match the current brush settings
  string $refAxis = "no";
  float $currentRadius;
  float $currentDisp;
  float $currentOpac;
  int $currentSmoothValue;
  string $currentBrushMode;
  string $currentReferenceDir;
  string $currentTool = `currentCtx`;
  if ($currentTool == "artSelectContext")
  {
    $currentRadius = `artSelectCtx -q -radius $currentTool`;
    if (`artSelectCtx -q -rn $currentTool`)
      $refAxis = `artSelectCtx -q -ra $currentTool`;
  }
  else 
  {
    $currentRadius = `artPuttyCtx -q -radius $currentTool`;
    $currentDisp = `artPuttyCtx -q -maxdisp $currentTool`;
    $currentOpac = `artPuttyCtx -q -opacity $currentTool`; 
    $currentReferenceDir = `artPuttyCtx -q -rv $currentTool`;
    if (`artPuttyCtx -q -rn $currentTool`)
      $refAxis = `artPuttyCtx -q -ra $currentTool`;
    $currentSmoothValue = 0;
    if (`artPuttyCtx -q -autosmooth $currentTool`)
      $currentSmoothValue = `artPuttyCtx -q -smoothiters $currentTool`;
    $currentBrushMode = `artPuttyCtx -q -mtm $currentTool`;   
    floatField -e -v $currentDisp -maxValue ($currentDisp*2) bDispFloat;
    if ($currentOpac > `floatField -q -maxValue bOpacFloat`)
      $currentOpac = `floatField -q -maxValue bOpacFloat`;
    intField -e -v $currentSmoothValue bSmthInt;     
    floatField -e -v $currentOpac bOpacFloat; 
   // set reference direction gadgets
    updateDirOpButtons($currentReferenceDir);
  }
 // update both radius gadgets
  floatField -e -v $currentRadius -maxValue ($currentRadius*2) bRadFloat;
  floatField -e -v $currentRadius -maxValue ($currentRadius*2) pRadFloat;  
 // set symmetry control
  updateSymModeDisplay($refAxis);
}


global proc autoSetBrushSize()
{ // sets brush radius gadget based on a fraction on the current camera's center of Interest
  string $currentTool = `currentCtx`;
  string $currentPane = `getPanel -wf`;
  string $currentCam = `modelEditor -q -cam $currentPane`;
  string $cameraShape[] = `listRelatives -s $currentCam`;
  float $currentCOI = `getAttr ($cameraShape[0]+".centerOfInterest")`;
  float $currentRadius;
  if (`getAttr ($cameraShape[0]+".orthographic")`)
    $currentRadius = $currentCOI / 400.0;
  else $currentRadius = $currentCOI / 20.0;
  if ($currentTool=="artSelectContext")
    artSelectCtx -e -radius $currentRadius $currentTool;  
  else 
  {
    artPuttyCtx -e -radius $currentRadius $currentTool;
    artPuttyCtx -e -maxdisp $currentRadius $currentTool;
  } 
  updateBrushGadets;
}


global proc constrainDispToggle()
{ // toggles disp gadget - if displace will keep value within a constant ratio
  global string $iconPath;
  global int $contrainDisplacement;
  global float $brushRatio;
  floatField -e -en $contrainDisplacement  bDispFloat;
  shelfButton -e -en $contrainDisplacement bDisHalf; 
  shelfButton -e -en $contrainDisplacement bDisDouble; 
  $contrainDisplacement= 1 - $contrainDisplacement;
  if ($contrainDisplacement)
  {
    $brushRatio = (`floatField -q -v bDispFloat`) / (`floatField -q -v bRadFloat`);
    menuItem -e -label "Uncontrain Max Disp" toggleDispConstraintMenu; 
  }
  else 
  {
    menuItem -e -label "contrain Max Disp" toggleDispConstraintMenu;   
  }
}


global proc setBrushSize1to1()
{ // sets brush maxdisp to be the same as radius 
  string $currentTool = `currentCtx`;
  if ($currentTool=="artPuttyContext")
  {
    float $currentDisp = `artPuttyCtx -q -radius $currentTool`;
    artPuttyCtx -e -maxdisp $currentDisp $currentTool;  
    floatField -e -v $currentDisp -maxValue ($currentDisp*2) bDispFloat;
  } 
}


global proc setBrushSize (float $radiusScale)  
{ // sets brush radius gadget by a radiusScale
  // work for both art select and art putty brushes
  global float $brushRatio;
  global int $contrainDisplacement;
  string $currentTool = `currentCtx`;
  float $currentRadius;
  if ($currentTool == "artSelectContext")
    $currentRadius = `artSelectCtx -q -radius $currentTool`;
  else $currentRadius = `artPuttyCtx -q -radius $currentTool`;
  $currentRadius = $currentRadius * $radiusScale;
  if ($currentTool == "artSelectContext")
    artSelectCtx -e -radius $currentRadius $currentTool;  
  else
    artPuttyCtx -e -radius $currentRadius $currentTool;    
  floatField -e -v $currentRadius -maxValue ($currentRadius*2) bRadFloat;
  floatField -e -v $currentRadius -maxValue ($currentRadius*2) pRadFloat;  
  if ($contrainDisplacement)
  {
    float $currentDisp = $currentRadius * $brushRatio;
    artPuttyCtx -e -maxdisp $currentDisp $currentTool;  
    floatField -e -v $currentDisp -maxValue ($currentDisp*2) bDispFloat;  
  }
}


global proc updateBrushRadius ()  
{ // sets brush radius from radius gadget
  // work for both art select and art putty brushes
  global float $brushRatio;
  global int $contrainDisplacement;  
  string $currentTool = `currentCtx`;
  float $currentRadius = `floatField -q -v bRadFloat`;
  if ($currentTool == "artSelectContext")
    artSelectCtx -e -radius $currentRadius $currentTool;  
  else
    artPuttyCtx -e -radius $currentRadius $currentTool; 
  if ($contrainDisplacement)
  {
    float $currentDisp = $currentRadius * $brushRatio;
    artPuttyCtx -e -maxdisp $currentDisp $currentTool;  
    floatField -e -v $currentDisp -maxValue ($currentDisp*2) bDispFloat; 
  }
}


global proc setBrushDisp (float $dispScale)  
{ // sets brush radius gadget by a radiusScale
  // work for both art select and art putty brushes
  string $currentTool = `currentCtx`;
  float $currentDisp = `artPuttyCtx -q -maxdisp $currentTool`;
  $currentDisp = $currentDisp * $dispScale;
  artPuttyCtx -e -maxdisp $currentDisp $currentTool;  
  floatField -e -v $currentDisp -maxValue ($currentDisp*2) bDispFloat;  
}


global proc updateBrushDisp ()  
{ // sets brush radius from radius gadget
  // work for both art select and art putty brushes
  string $currentTool = `currentCtx`;
  float $currentDisp = `floatField -q -v bDispFloat`;  
  artPuttyCtx -e -maxdisp $currentDisp $currentTool;         
}


global proc setBrushOpac (float $opacScale)  
{ // sets brush radius gadget by a radiusScale
  // work for both art select and art putty brushes
  string $currentTool = `currentCtx`;
  float $currentOpac = `artPuttyCtx -q -opacity $currentTool`;
  $currentOpac = $currentOpac * $opacScale;
  if ($currentOpac > `floatField -q -maxValue bOpacFloat`)
    $currentOpac = `floatField -q -maxValue bOpacFloat`;
  artPuttyCtx -e -opacity $currentOpac $currentTool;  
  floatField -e -v $currentOpac bOpacFloat;  
}


global proc updateBrushOpac ()  
{ // sets brush radius from radius gadget
  // work for both art select and art putty brushes
  string $currentTool = `currentCtx`;
  float $currentOpac = `floatField -q -v bOpacFloat`;  
  artPuttyCtx -e -opacity $currentOpac $currentTool;         
}


global proc setBrushSmoothing (int $smoothChange)  
{ // sets brush smoothing gadget one up or down
  string $currentTool = `currentCtx`;
  float $currentSmoothing;
  if (`artPuttyCtx -q -autosmooth $currentTool`)
    $currentSmoothing = `artPuttyCtx -q -smoothiters $currentTool`;
  else $currentSmoothing = 0;
  $currentSmoothing = $currentSmoothing + $smoothChange;
  if ($currentSmoothing > 0)
  { // if value great than 0 set tool smoothing on
    artPuttyCtx -e -autosmooth true `currentCtx`; 
    if ($currentSmoothing<11)
      artPuttyCtx -e -smoothiters $currentSmoothing `currentCtx`; 
  } 
  else artPuttyCtx -e -autosmooth false `currentCtx`;
  if (($currentSmoothing>-1)&&($currentSmoothing<11))
    intField -e -v $currentSmoothing bSmthInt;  
}


global proc changeBrushSmoothingValue()
{ // changes brush Smoothing value as a result of drag on slider
  string $currentTool = `currentCtx`;
  int $currentSmoothValue = `intField -q -v bSmthInt`; 
  if ($currentSmoothValue > 0)
  { // if value great than 0 set tool smoothing on
    artPuttyCtx -e -autosmooth true `currentCtx`; 
    if ($currentSmoothValue<11) 
      artPuttyCtx -e -smoothiters $currentSmoothValue `currentCtx`; 
  } 
  else artPuttyCtx -e -autosmooth false `currentCtx`; 
}


global proc updateBrushModeDisplay(string $pushedButton)
{ // updates the brush mode buttons and window display
  global string $iconPath;
  global string $lastSculptMode;
  window -e -t ("X-Tools 3.9.6 Sculpt "+$pushedButton) xToolsWindow; 
 // reset old mode button
  if ($lastSculptMode!="")
    shelfButton -e -image ($iconPath + $lastSculptMode + "brush.xpm") ($lastSculptMode+"BButton");  
 // set current mode as button pushed down 
  shelfButton -e -image ($iconPath + $pushedButton + "brushdown.xpm") ($pushedButton+"BButton");
 // enable or disable smoothing gadget 
  if (($pushedButton == "pull") || ($pushedButton == "push") || ($pushedButton == "smooth"))
  {
    shelfButton -e -en 1 bSmthLess;    
    intField -e -en 1 bSmthInt;
    shelfButton -e -en 1 bSmthMore;       
  }
  else
  {
    shelfButton -e -en 0 bSmthLess;    
    intField -e -en 0 bSmthInt;
    shelfButton -e -en 0 bSmthMore;      
  }
  $lastSculptMode = $pushedButton;
}


global proc setBrushMode(string $pushedButton)
{ // updates the brush operation buttons
  global string $brshSmthGad;
  //$lastBrushOp = $pushedButton;
  string $currentTool = `currentCtx`;
  artPuttyCtx -e -mtm $pushedButton $currentTool;
  updateBrushModeDisplay ($pushedButton);  
}


global proc updateSymModeDisplay(string $pushedButton)
{ // updates the sym mode buttons and window display
  global string $iconPath;
  global string $lastSymMode;
  string $currentTool = `currentCtx`;
  string $buttonPrefix;
  if ($currentTool=="artSelectContext")
    $buttonPrefix = "psym";
  else 
    $buttonPrefix = "bsym";
 // reset old mode button
  if ($lastSymMode!="")
    shelfButton -e -image ($iconPath + $lastSymMode + "sym.xpm") ($buttonPrefix+$lastSymMode);  
 // set current mode as button pushed down 
  shelfButton -e -image ($iconPath + $pushedButton + "symdown.xpm") ($buttonPrefix+$pushedButton);
  $lastSymMode = $pushedButton;
}


global proc setSymMode (string $symAxis)
{ // updates the brush symmetry buttons
  string $referenceValue = `optionMenu -q -v directionField`;
  string $currentTool = `currentCtx`;
  if ($symAxis=="no")
    if ($currentTool=="artSelectContext")
      artSelectCtx -e -rn false $currentTool;
    else artPuttyCtx -e -rn false $currentTool;
  else if ($currentTool=="artSelectContext")
  {
    artSelectCtx -e -rn true $currentTool;
    artSelectCtx -e -ra $symAxis $currentTool;  
  }
  else
  {     
    artPuttyCtx -e -rn true $currentTool;
    artPuttyCtx -e -ra $symAxis $currentTool;
   // check to see if the invert normal vector should be turned off
    if ($symAxis!="no")
   // if reflection is on, invert reference normal if in the same direction as reflection
      if ($symAxis==tolower($referenceValue))
        artPuttyCtx -e -irv 1 artPuttyContext;
      else
        artPuttyCtx -e -irv 0 artPuttyContext;             
  }
  updateSymModeDisplay($symAxis);
}


global proc toggleWireframeforBrush()
{// sets wireframe display on or off for Sculpt Brush
 // also turns wireframe on shaded off if needed
  string $currentTool = `currentCtx`; 
  int $wireOn = 1 - `artPuttyCtx -q -showactive $currentTool`;  
  artPuttyCtx -e -showactive $wireOn `currentCtx`;
  if ($wireOn<1) //off
  {// turn wireframe on surface off for active camera
    string $currentPane = `getPanel -wf`;
    modelEditor -e -wos 0 $currentPane;
  }
}


global proc updateDirOpButtons(string $referenceDir)
{ // updates the button for brush dir 
  global string $iconPath;
  switch ($referenceDir)
  {
     case "normal":      optionMenu -e -v "N" directionField; break;
     case "view":        optionMenu -e -v "V" directionField; break;  
     case "firstnormal": optionMenu -e -v "FN" directionField; break;  
     case "xaxis":           optionMenu -e -v "X" directionField; break;      
     case "yaxis":           optionMenu -e -v "Y" directionField; break;    
     case "zaxis":           optionMenu -e -v "Z" directionField; break;     
  }
}


global proc setDirOp()
{ // updates the brush dir 
  string $referenceDir;
  string $currentTool = `currentCtx`;
  string $referenceVlaue = `optionMenu -q -v directionField`;
  string $refAxis = "no";
  switch ($referenceVlaue)  // set reference vector based on option menu setting
  {
     case "N":      $referenceDir = "normal"; break;
     case "V":      $referenceDir = "view"; break;  
     case "FN":     $referenceDir = "firstnormal"; break;  
     case "X" :     $referenceDir = "xaxis"; break;      
     case "Y" :     $referenceDir = "yaxis"; break;    
     case "Z" :     $referenceDir = "zaxis"; break;     
  } 
  if ($currentTool=="artPuttyContext")
  {
    artPuttyCtx -e -rv $referenceDir artPuttyContext;
    if (`artPuttyCtx -q -rn $currentTool`)
      $refAxis = `artPuttyCtx -q -ra $currentTool`;
    if ($refAxis!="no")
   // if reflection is on, invert reference normal if in the same direction as reflection
      if ($refAxis==tolower($referenceVlaue))
        artPuttyCtx -e -irv 1 artPuttyContext;
      else
        artPuttyCtx -e -irv 0 artPuttyContext;         
    updateDirOpButtons ($referenceDir);
  }  
}


global proc autoSetSoftModSize ()
{ // sets soft Mod tool Radius based camera distance from origin
  // if poly componets are selected it will set radius component bounding box
  global float $softModRadius;
  string $currentShape[] = `ls -sl`;
  if ((`gmatch $currentShape[0] "*.f*"`) || (`gmatch $currentShape[0] "*.e*"`) || (`gmatch $currentShape[0] "*.*"`))
  {
    float $bbox[] = `polyEvaluate -bc`;
    float $bBoxVolume = abs($bbox[0] - $bbox[3]) * abs($bbox[1] - $bbox[4]) * abs($bbox[3] - $bbox[5]);
    $softModRadius = `pow $bBoxVolume (0.3)`;
  }
  else // set based on camera vantage point
  {
    string $currentPane = `getPanel -wf`;
    string $currentCam = `modelEditor -q -cam $currentPane`;
    string $cameraShape[] = `listRelatives -s $currentCam`;
    float $currentCOI = `getAttr ($cameraShape[0]+".centerOfInterest")`;
    if (`getAttr ($cameraShape[0]+".orthographic")`)
      $softModRadius = $currentCOI / 100.0;
    else $softModRadius = $currentCOI / 5.0;
  }
  optionVar -floatValue softModFalloffRadius $softModRadius;
}


global proc setSoftModSize (float $radiusScale)
{ // sets soft Mod tool Radius based radius scale value
  float $softModRadius;
 // get current SoftMod Value 
  $softModRadius = `optionVar -q softModFalloffRadius`;
  $softModRadius = $softModRadius * $radiusScale;
 // set the value of the radius gadget 
  floatField -e -v $softModRadius smRadFloat;
  updateSoftModRadius;
}


global proc updateSoftModGadets()
{ //resets softmod radius gadget to match current softmod falloff radius
  float $softModRadius = `optionVar -q softModFalloffRadius`;
  floatField -e -v $softModRadius smRadFloat;  
}


global proc updateSoftModRadius()
{ // sets the current Soft Modification 
 // grab the value from the radius gadget 
  float $newRadius = `floatField  -q -v smRadFloat`; 
 //get the name of the current soft Mod Deformer
  string $softModName[] = `ls -sl`;
 // set value of current deformer 
  setAttr (substring($softModName[0],1,size($softModName[0])-6)+".falloffRadius") $newRadius;
 // set new default radius for soft Mods 
  optionVar -floatValue softModFalloffRadius $newRadius;
}


global proc activateMoveNormal ()
{
  MoveNormalTool;
}


global proc toggleCVDisplay ()
{
  ToggleCVs;
}


global proc reverseNurb ()
{
  reversePreset 1 1 0;
}


global proc iconifyToggle ()
{ // toggles the the Iconified state of Xtools
  if (`window -ex xToolsWindow`) // if xtools is running
    if (`window -q -i xToolsWindow`) // if iconified then restore otherwise iconify
      window -e -i 0 xToolsWindow;
    else window -e -i 1 xToolsWindow;
}


global proc toggleBFCull ()
{ // toggles backface culling off/on for selected shade node
  string $selectedObjects[] = `ls -sl`;
  string $currentObject;
  for ($curentObject in $selectedObjects)
  {
    int $currentBFC = getAttr ($currentObject+".backfaceCulling");
    if ($currentBFC > 0)
      $currentBFC = 3;
    setAttr ($currentObject+".backfaceCulling") (3 - $currentBFC);
  }
}


global proc toggleWos ()
{ // toggles wire-frame on shaded off/on for active camera
  string $currentPane = `getPanel -wf`;
  int $currentWOS = `modelEditor -q -wos $currentPane`;
  modelEditor -e -wos (1-$currentWOS) $currentPane;
}


global proc toggleXray ()
{ // toggles xray mode off/on for active camera
  string $currentPane = `getPanel -wf`;
  int $currentXRAY = `modelEditor -q -xray $currentPane`;
  modelEditor -e -xray (1-$currentXRAY) $currentPane;
}


global proc toggleXrayComp ()
{ // toggles xray mode off/on for active camera
  string $currentPane = `getPanel -wf`;
  int $currentXRAYComp = `modelEditor -q -activeComponentsXray $currentPane`;
  modelEditor -e -activeComponentsXray (1-$currentXRAYComp) $currentPane;
}


global proc toggleXrayJoint ()
{ // toggles xray mode off/on for active camera
  string $currentPane = `getPanel -wf`;
  int $currentXRAYJoint = `modelEditor -q -jointXray $currentPane`;
  modelEditor -e -jointXray (1-$currentXRAYJoint) $currentPane;
}


global proc toggleMeshDisplay ()
{ // toggles Display mode for Polys for active camera
  string $currentPane = `getPanel -wf`;
  int $currentPolyDisplay = `modelEditor -q -polymeshes $currentPane`;
  modelEditor -e -polymeshes (1-$currentPolyDisplay) $currentPane;
}


global proc toggleCurveDisplay  ()
{ // toggles Nurb Curve Display on shaded off/on for active camera
  string $currentPane = `getPanel -wf`;
  int $currentNC = `modelEditor -q -nc $currentPane`;
  modelEditor -e -nc (1-$currentNC) $currentPane;
}


global proc toggleSurfaceDisplay  ()
{ // toggles Nurb Surface Display on shaded off/on for active camera
  string $currentPane = `getPanel -wf`;
  int $currentNS = `modelEditor -q -ns $currentPane`;
  modelEditor -e -ns (1-$currentNS) $currentPane;
}


global proc toggleCamDisplay ()
{ // toggles camera display
  string $currentPane = `getPanel -wf`;
  int $currentCamDisp = `modelEditor -q -cameras $currentPane`;
  modelEditor -e -cameras (1-$currentCamDisp) $currentPane;
}


global proc isolateSelection ()
{ // toggles view isolate off/on for active camera
  string $currentPane = `getPanel -wf`;
  int $currentIS = `isolateSelect -q -s $currentPane`;
  enableIsolateSelect $currentPane (1-$currentIS);
  isolateSelect -s (1-$currentIS) $currentPane;
}


global proc toggleComp ()
{ // toggle softedges and border edges for selection or everything if there is no selection
  int $nothingSelected = 0;
  string $ifSelected[] = `ls -sl`;  
  if ($ifSelected[0] == "")
  {
    $nothingSelected = 1;
    SelectAllPolygonGeometry;
  }
  ToggleSoftEdges; ToggleBorderEdges;
  if ($nothingSelected)
    select -cl;
 
}

global proc placeSoftMod () 
{// places Soft Mod at selected Vertice
  global float $softModRadius;
  string $selectedVertice[] = `ls -sl -fl`;
  float $vPos[] = pointPosition ($selectedVertice[0]); 
 // grab shape name
  string $shapeBuffer[];
  tokenize($selectedVertice[0],".",$shapeBuffer);
  string $shapeName = $shapeBuffer[0];       
  select -cl;
  hilite -u $shapeName;
  select -r $shapeName;
 // auto set radius
  autoSetSoftModSize;
 // place soft mod on shape at selected location 
  softMod -fc $vPos[0] $vPos[1] $vPos[2] -fr $softModRadius;
 // set tool to softMod 
  SoftModTool;   
}


global proc selectHalf (int $direction)
{// selects half of an objects faces based on direction
  string $selectionList[] = `ls -sl`;
  selectMode -component; 
  selectType -allComponents 0 -polymeshFace 1;
  for ($currentSelection in $selectionList)
  {   
  // calculate bounding box 
    float $bboxInfo[] = `exactWorldBoundingBox -ii 1 $currentSelection`;
  // calculate center based on bounding box  
    float $obCenter[];
    $obCenter[0] = ($bboxInfo[0]+$bboxInfo[3])/2;
    $obCenter[1] = ($bboxInfo[1]+$bboxInfo[4])/2;
    $obCenter[2] = ($bboxInfo[2]+$bboxInfo[5])/2;    
    switch ($direction)
    { //calculates the appropiate edge of the bounding box
      case  1: 
        //x+
            polySelectConstraint -m 3 -t 8 -d 3 -db 0 ($bboxInfo[3]-$obCenter[0]) -da $bboxInfo[3] 0 0 -dp $bboxInfo[3] 0 0;         
          polySelectConstraint -m 0 -d 0;
        break;    
      case  2:
        //x-    
          polySelectConstraint -m 3 -t 8 -d 3 -db 0 ($obCenter[0]-$bboxInfo[0]) -da $bboxInfo[0] 0 0 -dp $bboxInfo[0] 0 0; 
          polySelectConstraint -m 0 -d 0;
        break;
      case  3: 
         //y+
          polySelectConstraint -m 3 -t 8 -d 3 -db 0 ($bboxInfo[4]-$obCenter[1]) -da 0 $bboxInfo[4] 0 -dp 0 $bboxInfo[4] 0; 
          polySelectConstraint -m 0 -d 0;      
        break;    
      case  4:
         //y-
          polySelectConstraint -m 3 -t 8 -d 3 -db 0 ($obCenter[1]-$bboxInfo[1]) -da 0 $bboxInfo[1] 0 -dp 0 $bboxInfo[1] 0; 
          polySelectConstraint -m 0 -d 0;               
        break;
      case  5: 
        //z+
          polySelectConstraint -m 3 -t 8 -d 3 -db 0 ($bboxInfo[5]-$obCenter[2]) -da 0 0 $bboxInfo[5] -dp 0 0 $bboxInfo[5]; 
          polySelectConstraint -m 0 -d 0;             
        break;
      case  6: 
        //z-
          polySelectConstraint -m 3 -t 8 -d 3 -db 0 ($obCenter[2]-$bboxInfo[2]) -da 0 0 $bboxInfo[2] -dp 0 0 $bboxInfo[2]; 
          polySelectConstraint -m 0 -d 0;      
        break;    
    }
  }
}


global proc storePivot() 
{ // stores current point in global variable
  global float $lastPivotPosition[];
  string $currentTool = `currentCtx`;
  if ($currentTool=="moveSuperContext")
    $lastPivotPosition = `manipMoveContext -q -p Move`;
  if ($currentTool=="RotateSuperContext")
    $lastPivotPosition = `manipRotateContext -q -p Rotate`;
  if ($currentTool=="scaleSuperContext")
    $lastPivotPosition = `manipScaleContext -q -p Scale`;
}


global proc recallPivot () 
{ // recalls and set pivot point from global variable
  // can only be used with a node that has a transform
  global float $lastPivotPosition[];
  xform -a -ws -piv $lastPivotPosition[0] $lastPivotPosition[1] $lastPivotPosition[2]; 
}


global proc reCenterPivot()
{ // center's pivot on world or object - toggle
  // will adjust objects pivot to current selection
  global string $iconPath;
  global int $pivotShape;
  string $selection[] = `ls -sl`;
  if (`gmatch $selection[0] "*.*"`+"\n") 
  {// place pivot at current Manipulator
    string $currentTool = `currentCtx`;
     float $vPos[];
     if ($currentTool=="moveSuperContext")
       $vPos = `manipMoveContext -q -p Move`;
     if ($currentTool=="RotateSuperContext")
       $vPos = `manipRotateContext -q -p Rotate`;
     if ($currentTool=="scaleSuperContext")
       $vPos = `manipScaleContext -q -p Scale`;
    // grab shape name
     string $shapeBuffer[];
     tokenize($selection[0],".",$shapeBuffer);
     string $shapeName = $shapeBuffer[0];       
     select -cl;
     hilite -u $shapeName;
     select -r $shapeName;
     xform -a -ws -piv $vPos[0] $vPos[1] $vPos[2];
     print ("Centering on Component.\n");
  } 
  else if ($pivotShape)
  { // center pivot on shape
    CenterPivot;
    $pivotShape = false;
    print ("Centering of Shape.\n");
    shelfButton -e -ann "Center on Pivot World" -image ($iconPath + "centerpivotworld.xpm") xbutton19;
  }
  else // center on world
  { 
    xform -ws -piv 0 0 0;
    $pivotShape = true;
    print ("Centering on World.\n");
    shelfButton -e -ann "Center Pivot on Selection" -image ($iconPath + "centerpivot.xpm") xbutton19;
  }
}        
       
       
global proc centerpivotconstrain (int $side)
{ // moves pivot point to the center of any 6 faces of an objects bounding box
  string $selectionList[] = `ls -sl`;
  for ($currentSelection in $selectionList)
  { select -r $currentSelection; 
    float $bboxInfo[] = `exactWorldBoundingBox -ii 1`;
    float $centerInfo[];
    $centerInfo[0] = ($bboxInfo[0]+$bboxInfo[3])/2;
    $centerInfo[1] = ($bboxInfo[1]+$bboxInfo[4])/2;
    $centerInfo[2] = ($bboxInfo[2]+$bboxInfo[5])/2;     
    switch ($side)
    {
      case  0: 
        xform -ws -piv $bboxInfo[0] $centerInfo[1] $centerInfo[2];  //x-
        break;    
      case  1: 
        xform -ws -piv $centerInfo[0] $bboxInfo[1] $centerInfo[2];  //y-
        break;
      case  2: 
        xform -ws -piv $centerInfo[0] $centerInfo[1] $bboxInfo[2];  //z-
        break;    
      case  3: 
        xform -ws -piv $bboxInfo[3] $centerInfo[1] $centerInfo[2];  //x+
        break;
      case  4: 
        xform -ws -piv $centerInfo[0] $bboxInfo[4] $centerInfo[2];  //y+
        break;
      case  5: 
        xform -ws -piv $centerInfo[0] $centerInfo[1] $bboxInfo[5];  //z+        
        break;    
    }
  }
  select -r $selectionList;
}


global proc alignManip ()
{ //aligns objects scale orientation to orientation axis of Move Tool 
  float $currentAlignment[];
  float $currentDegree[];  
  string $currentSelection[] = `ls -hl`; 
  if ($currentSelection[0]!="")
  {
    xObjectMode; // if highlighted - go to object mode
    $currentSelection = `ls -sl`;
  } 
  string $currentShape = $currentSelection[0];
  if ($currentShape!="")
  { 
    setToolTo moveSuperContext;
    $currentAlignment = `manipMoveContext -q -oa Move`;
    $currentDegree[0] = `rad_to_deg $currentAlignment[0]`;
    $currentDegree[1] = `rad_to_deg $currentAlignment[1]`;
    $currentDegree[2] = `rad_to_deg $currentAlignment[2]`;
   // freeze out current transforms  
    FreezeTransformations; 
   // reverse rotate order
    setAttr ($currentShape+".rotateOrder") 5;
   // set rotate to be opposite of Move Manipulator 
    rotate (-$currentDegree[0]) (-$currentDegree[1]) (-$currentDegree[2]);
   // reset transforms 
    FreezeTransformations;
   // restore rotate order
    setAttr ($currentShape+".rotateOrder") 0;  
    rotate $currentDegree[0] $currentDegree[1] $currentDegree[2];  
  }  
}


global proc reAlignOptions()
{ // a second double click opens up the tool options for move
  manipMoveContext -e -mode 2 -orientAxes 0 0 0 Move; 
  setToolTo moveSuperContext; 
  toolPropertyWindow; 
  manipMoveProperties; 
  toolPropertyShow;
}


global proc alignToSelection ()
{ // aligns move manipulator to face, vertex, or edge normal
  global string $iconPath;
  global int $isMaya2008Plus; 
  global int $alignToSelection;
  global int $newSelectionScript; 
  setToolTo moveSuperContext; // reseting to move tool
 // if 2008 or higher this tools toggles between World mode and Normal Average
  if ($isMaya2008Plus)
  {
    if ($alignToSelection)
    {
      manipMoveContext -e -mode 9 Move; 
      shelfButton -e -ann "Align Move Manipulator to World" -image ($iconPath + "aligntoworld.xpm") xbutton6;      
      $alignToSelection = false;     
    }
    else
    {
      manipMoveContext -e -mode 2 -orientAxes 0 0 0 Move;
      shelfButton -e -ann "Align Move Manipulator to Selection" -image ($iconPath + "aligntoface.xpm") xbutton6;           
      $alignToSelection = true;
    }
  }
  else
  { // older code for 8.5 or less
    string $selectedComponent[] = `ls -sl`;
    string $selectedVertice[];
    if ($selectedComponent[0]!="")
    { //turn on ignore mode so new selection script won't do anything
      if (size(`listRelatives -s $selectedComponent[0]`)==0) // Is it components?
      {
        if ($alignToSelection) 
        {// align to selection if new selection else align to world
          turnOffToolMessages; //turn off interactive Tool Messages
         // figure out what type of component is selected
          int $componentType = 3;  // face by default
          if (`gmatch $selectedComponent[0] "*.vtx*"`+"\n") 
          $componentType = 1;  
          if (`gmatch $selectedComponent[0] "*.e*"`+"\n") 
          $componentType = 2; 
          if (($componentType < 2) && (size($selectedComponent)<2))
          { // special condition for single vertice - surround faces are selected to grab normal value
            $selectedVertice = $selectedComponent;
            ConvertSelectionToFaces;
            $selectedComponent = `ls -sl`;
            $componentType = 3;   
          }
          manipMoveOrient $componentType;
          manipMoveContext -e -mode 6 Move; 
          manipMoveAlignHandleWith($selectedComponent[0], $selectedComponent);
          if (size($selectedVertice)>0)
            select $selectedVertice;
          else select $selectedComponent;
          $alignToSelection = false; // setting toggle to world
          shelfButton -e -ann "Align Manipulator to World" -image ($iconPath + "aligntoworld.xpm") xbutton6;      
          print ("Aligning to Selection.\n");
        }
        else // else sets alignment to world 
        {
          manipMoveContext -e -mode 2 -orientAxes 0 0 0 Move;
          $alignToSelection = true;  // setting toggle to world
          shelfButton -e -ann "Align Move Manipulator to Component" -image ($iconPath + "aligntoface.xpm") xbutton6;     
          print ("Aligning to World.\n");
          setToolTo moveSuperContext;
          restoreToolMessagesSettings; // restore Message setting to their previous state
        }
      } // else "object mode" reset object manipulator world
      else 
      {
        manipMoveContext -e -mode 2 -orientAxes 0 0 0 Move;
        shelfButton -e -ann "Align Move Manipulator to Component" -image ($iconPath + "aligntoface.xpm") xbutton6;     
        print ("Aligning to World.\n");        
      }
    }
    else
    { // else sets alignment to world   
      manipMoveContext -e -mode 2 -orientAxes 0 0 0 Move;
      $alignToSelection = true;  // setting toggle to world
      shelfButton -e -ann "Align Move Manipulator to Component" -image ($iconPath + "aligntoface.xpm") xbutton6;
      print ("Aligning to World.\n");
    }  
  }
}

global proc alignMoveComponent()
{ // used to repeated move component 
  global int $alignToSelection;  
  deleteShapeHistory;
  setToolTo moveSuperContext;
  MovePolygonComponent;
  $alignToSelection = false;  
}


global proc deleteShapeHistory()
{ // deletes history in component or object mode
  string $selectedComponents[] = `ls -sl -fl`;
  string $selectedHiLights[] = `ls -hl -fl`;
  delete -ch $selectedHiLights;
  delete -ch $selectedComponents;
}


global proc toggleFaceSelect ()
{ // toggle whole face select off/on
  int $currentFS = `polySelectConstraint -q -ws`;
  polySelectConstraint -ws (1-$currentFS);
}


global proc xObjectMode()
{// converts any hilited objects to selected objects with components still selected
 //resets tool to basic marquee tool
  if (`window -ex brushSelWindow`) 
    deleteUI brushSelWindow;
  setToolTo selectSuperContext;
  string $currentObjects[] = `ls -hl`;
  select -cl; // clear components  
  selectMode -o; // object selection mode
  hilite -u $currentObjects; // unlite
  select -r $currentObjects;
}


global proc deleteEmptyTransforms ()
{ // delete transform nodes that have no children
  string $topNodes[] = `ls -tr`;
  string $currentNode;
  for ($currentNode in $topNodes)
  {
    string $isEmpty[] = `listRelatives -c $currentNode`;
    if ($isEmpty[0]=="")
      delete $currentNode;
  }
}


global proc deleteEdgeClean ()
{
  string $selectedEdges[] = `ls -sl`;
  polyDelEdge -cv true -ch 1 $selectedEdges;
}


global proc uberCombine ()
{ // does all the functions to complete a mesh combine
  CombinePolygons; 
  DeleteHistory; 
  polyMergeVertex  -d 0.0001; 
  ConformPolygonNormals; 
  DeleteHistory;
}


global proc uberExtrude ()
{ // uses extrude edge if an edge is selected; uses extrude face if a face is selected
  // obsolete since Maya 8
  string $selectedComponent[] = `ls -sl`;
  if (`gmatch $selectedComponent[0] "*.e*"`) ExtrudeEdge;
  else ExtrudeFace;

}


global proc uberNewFace ()
{ // uses append tool if there's a mesh select: otherwise uses create
  global int $isMaya8Plus;
  string $ifSelected[] = `ls -sl`;
  if (`gmatch $ifSelected[0] "*.e*"`)
  { // we've got edges
    if (isBorderEdge($ifSelected[0]))
    {
      int $edgeTotal = size($ifSelected);
      switch ($edgeTotal)
      {
        case 1:
          polyCloseBorder -ch 1;
          break;
        case 2:
          if ($isMaya8Plus)
            BridgeEdge;
          break;   
        default: 
          AppendToPolygonTool;
          break;
      }    
    }
    else polyBevel -offset 0.5 -offsetAsFraction 1 -autoFit 1 -segments 1 -worldSpace 1 -fillNgons 1 -mergeVertices 1 -mergeVertexTolerance 0.0001 -smoothingAngle 30 -miteringAngle 180 -angleTolerance 180 -ch 1 $ifSelected;
  }   
  if (`gmatch $ifSelected[0] "*.v*"`) 
    polyChamferVtx 1 0.5 0;  
  if (`gmatch $ifSelected[0] "*.f*"`) 
    PokePolygon;      
  if (!`gmatch $ifSelected[0] "*.*"`)
  { // if it's not a component
    if ($ifSelected[0] == "") CreatePolygonTool;
    else AppendToPolygonTool;
  }
}


global proc convertNurbHideOrg ()
{ // converts nurb to Polygon and hide Nurbs
  string $currentNurbs[] = `ls -sl`;
  HideSelectedObjects;
  nurbsToPoly -mnd 1  -ch 1 -f 2 -pt 1 -pc 200 -chr 0.9 -ft 0.01 -mel 0.001 -d 0.1 -ut 3 -un 3 -vt 3 -vn 3 -uch 0 -ucr 0 -cht 0.2 -es 0 -ntr 0 -mrt 0 -uss 1 $currentNurbs[0]; 
}


global proc xmelomatic()
{ // displays a list gadget of mel scripts
  // mel scripts can be; run, sourced and run, or just sourced
  // 1.9 includes from makexwindow that size the window for all os
  string $melomaticWin;
  
  string $melPath = `internalVar -userScriptDir`;
  string $melFiles[] = `getFileList -fld $melPath`;
  global int $melFileListNumber;
 // Interface Begins
  if (`about -win`) // windows operating system  
    $melomaticWin = `window -t "Mel-O-Matic 1.9" -rtf 1 -s 0 melomaticWindow`;
  if (`about -li`) // linux os
    $wndName = `window -t "Mel-O-Matic 1.9" -w 466 -h 312 -s 0 -mnb 0 -mxb 0 melomaticWindow`;     
  if (`about -mac`) // mac os
    $wndName = `window -t "Mel-O-Matic 1.9" -w 466 -h 320 -s 0 melomaticWindow`;   
	 
  string $melomaticForm = `formLayout -numberOfDivisions 100`;
  
 // Create Controllers
  text -label "Select a Mel Script to run:" mLabelName;

  textField -text $melPath  -width 356 dirNameField;
  button -width 70 -height 22 -label "Browse" 
         -command "browseForDirectoryMel" browseButton;

  textScrollList -w 430
    -numberOfRows 12 -allowMultiSelection false 
 		-showIndexedItem 1 melList;
  string $melFile;
  for ( $melFile in $melFiles )
    if (($melFile != "melomatic.mel") || ($melFile != "xtools.mel")) // don't include these scripts in the list
      if ( fileExtension($melFile) == "mel")
        textScrollList -e -append (basename($melFile,".mel")) melList;
  
  if ($melFileListNumber > 0)      
    textScrollList -e -sii $melFileListNumber melList;     
  text -label "Action" actionText;
  radioCollection  actionType;
    radioButton -label "Run" runButton;
    radioButton -label "Source and Run" sourceAndRunButton;
    radioButton -label "Source Only" sourceOnlyButton;
    
  radioCollection -e -sl "runButton" actionType;
  
  button -width 150 -height 26 -label "Execute" -align "center"
         -command "runMel; deleteUI melomaticWindow" createButton;  // executes and closes
  button -width 150 -height  26 -label "Apply" 
         -command "runMel" applyButton;                     // executes and stays open             
  button -width 150 -height 26 -label "Close" 
         -command "deleteUI melomaticWindow" closeButton;   // closes interface
 
 // Layout Interface

  formLayout -e	// arrange layout
       	-af "mLabelName" "left" 10
     	-af "mLabelName" "top" 12
     	-af "dirNameField" "left" 18
     	-ac "dirNameField" "top" 8 "mLabelName"
     	-ac "browseButton" "top" 8 "mLabelName"
       	-ac "browseButton" "left" 4 "dirNameField"   	
     	-af "melList" "left" 18
     	-ac "melList" "top" 6 "dirNameField"
     	-af "actionText" "left" 30
     	-ac "actionText" "top" 12 "melList" 
     	-ac "runButton" "left" 20 "actionText"
     	-ac "runButton" "top" 12 "melList" 
     	-ac "sourceAndRunButton" "left" 24 "runButton"
     	-ac "sourceAndRunButton" "top" 12 "melList" 
     	-ac "sourceOnlyButton" "left" 24 "sourceAndRunButton"
     	-ac "sourceOnlyButton" "top" 12 "melList"      	
      	-ac "createButton" "top" 12 "runButton"    	
	-af "createButton" "left" 4 
	-af "createButton" "bottom" 4
      	-ac "applyButton" "top" 12 "runButton"  	
	-ac "applyButton" "left" 4 "createButton"
	-af "applyButton" "bottom" 4
	-ac "closeButton" "top" 12 "runButton"  
	-ac "closeButton" "left" 4 "applyButton"
	-af "closeButton" "bottom" 4
	-af "closeButton" "right" 4	
	$melomaticForm;
 // Interface Ends

  showWindow $melomaticWin;
}


global proc browseForDirectoryMel()
{// Open file browser to default Mel Directory
  string $melPath = `internalVar -userScriptDir`;
  $melPath = `fileDialog -directoryMask $melPath`;
  string $melDirectory = dirname ($melPath) + "/";
  textField -e -tx $melDirectory dirNameField;
  textScrollList -e -ra melList;
  string $melFiles[] = `getFileList -fld $melDirectory`;
  string $melFile;
  for ( $melFile in $melFiles )
    if ($melFile != "xtools.mel") // don't include this script in the list
      if ( fileExtension($melFile) == "mel")
        textScrollList -e -append (basename($melFile,".mel")) melList;  
}


global proc runMel ()
{ // execute mel script - source first if requested
  string $melPath = `textField -q -tx dirNameField`;
  global int $melFileListNumber; 
  int $ListNumbers[] = `textScrollList -q -sii melList`;
  $melFileListNumber = $ListNumbers[0];
  string $selectedMelFile = stringArrayToString (`textScrollList -q -si melList`,""); 
  if (size($selectedMelFile)>0)
  {
    string $actionSelection = `radioCollection -q -sl actionType`;
    switch ($actionSelection)
    { case "runButton":
        eval $selectedMelFile;
        break;
      case "sourceAndRunButton":
        eval ( "source " + "\"" + $melPath + $selectedMelFile + ".mel\"");
        eval $selectedMelFile;
        break;
      case "sourceOnlyButton":
        eval ( "source " + "\"" + $melPath + $selectedMelFile + ".mel\"");
        break;
    }
  }
}

//  Based on GuiPy.mel By Andrew Osiow 2009 Copyright

global proc guipy()
{
  string $gpPath = `internalVar -userScriptDir`;
  string $gpFiles[] = `getFileList -fld $gpPath`;

 // Interface Begins
  if (`window -ex guipyWindow`) deleteUI guipyWindow;
  string $guipyWin = `window 
	  -title "Gui Py 1.6" 
	  -iconName "GP" 
	  -rtf 1 -s 0
	 guipyWindow`;
	 
  string $guipyForm = `formLayout -numberOfDivisions 100`;
  
 // Create Controllers
  text -label "Select a Python Script to run:" gpLabelName;

  textField -text $gpPath  -width 356 gpdirNameField;
  button -width 70 -height 22 -label "Browse" 
         -command "browseForDirectoryPy" gpbrowseButton;

  textScrollList -w 430
    -numberOfRows 12 -allowMultiSelection false 
 		-showIndexedItem 1 gpythonList;
  string $gpFile;
  for ( $gpFile in $gpFiles )
    if ($gpFile != "guipy.mel") // don't include this script in the list
      if ( fileExtension($gpFile) == "py")
        textScrollList -e -append (basename($gpFile,".py")) gpythonList;
  
  
  text -label "Action" gpActionText;
  radioCollection  gpActionType;
    radioButton -label "Execute" gprunButton;
    radioButton -label "Import and Execute" gpsourceAndRunButton;
    radioButton -label "Import Only" gpsourceOnlyButton;
    
  radioCollection -e -sl "gpsourceAndRunButton" gpActionType;
  
  button -width 150 -height 26 -label "Execute" -align "center"
         -command "runPython; deleteUI guipyWindow" createButton;  // executes and closes
  button -width 150 -height  26 -label "Apply" 
         -command "runPython" applyButton;                     // executes and stays open             
  button -width 150 -height 26 -label "Close" 
         -command "deleteUI guipyWindow" closeButton;   // closes interface
 
 // Layout Interface

  formLayout -e	// arrange layout
       	-af "gpLabelName" "left" 10
     	-af "gpLabelName" "top" 12
     	-af "gpdirNameField" "left" 18
     	-ac "gpdirNameField" "top" 8  "gpLabelName"
     	-ac "gpbrowseButton" "top" 8  "gpLabelName"
       	-ac "gpbrowseButton" "left" 4 "gpdirNameField"   	
     	-af "gpythonList" "left" 18
     	-ac "gpythonList" "top" 6 "gpdirNameField"
     	-af "gpActionText" "left" 30
     	-ac "gpActionText" "top" 12 "gpythonList" 
     	-ac "gprunButton" "left" 20 "gpActionText"
     	-ac "gprunButton" "top" 12 "gpythonList" 
     	-ac "gpsourceAndRunButton" "left" 24 "gprunButton"
     	-ac "gpsourceAndRunButton" "top" 12 "gpythonList" 
     	-ac "gpsourceOnlyButton" "left" 24 "gpsourceAndRunButton"
     	-ac "gpsourceOnlyButton" "top" 12 "gpythonList"      	
      	-ac "createButton" "top" 12 "gprunButton"    	
	-af "createButton" "left" 4 
	-af "createButton" "bottom" 4
      	-ac "applyButton" "top" 12 "gprunButton"  	
	-ac "applyButton" "left" 4 "createButton"
	-af "applyButton" "bottom" 4
	-ac "closeButton" "top" 12 "gprunButton"  
	-ac "closeButton" "left" 4 "applyButton"
	-af "closeButton" "bottom" 4
	-af "closeButton" "right" 4	
	$guipyForm;
 // Interface Ends

  showWindow $guipyWin;
}


global proc browseForDirectoryPy()
{// Open file browser to default Script Directory
  string $pyPath = `internalVar -userScriptDir`;
  $pyPath = `fileDialog -directoryMask $pyPath`;
  string $pyDirectory = dirname ($pyPath) + "/";
  textField -e -tx $pyDirectory gpdirNameField;
  textScrollList -e -ra gpythonList;
  string $pyFiles[] = `getFileList -fld $pyDirectory`;
  string $pyFile;
  for ( $pyFile in $pyFiles )
    if ($pyFile != "guipy.mel") // don't include this script in the list
      if ( fileExtension($pyFile) == "py")
        textScrollList -e -append (basename($pyFile,".py")) gpythonList;  
}


global proc runPython ()
{ // execute Python script - source first if requested
  python ("import os, sys");
  string $pyPath = `textField -q -tx gpdirNameField`;
  python ("sys.path.append(os.path.abspath('" + $pyPath + "'))");
  string $selectedPyFile = stringArrayToString (`textScrollList -q -si gpythonList`,"");
  if (size($selectedPyFile)>0)
  {
    string $actionSelection = `radioCollection -q -sl gpActionType`;
    switch ($actionSelection)
    { case "gprunButton":
        python ($selectedPyFile + "." + $selectedPyFile+"()");
        break;
      case "gpsourceAndRunButton":
        // need to add code to test whether the python code has already been loaded

        python ("import " + $selectedPyFile );        	
        python ("reload (" + $selectedPyFile + ")" );
        python ($selectedPyFile + "." + $selectedPyFile+"()");
        break;
      case "gpsourceOnlyButton":
        python ( "import " + $selectedPyFile );
        break;
    }
  }
}


// including UVhero.mel script
// With thanks to Mike Bailey (a former student) for the idea and an early gui layout

global proc uvhero()
{ // delete saved Window Pref
  if (`windowPref -ex fnsWindow`) windowPref -remove fnsWindow; 
  // create a window structure
  if (`window -ex fnsWindow`) deleteUI fnsWindow;
  string $fnsWin = `window 
    -w 20 -h 10 // a small window will stretch to fit gadgets in layout mode
    -title "UV Hero 1.5" -iconName "UVH"
    -rtf 1 -s 0  // resize to fit - no sizing gadget
    fnsWindow`;
    
  string $fnsLayout = `formLayout -numberOfDivisions 100`;  // create a Form Layout with a 100 grid point
  
 //  Controls
 //  adding option menu for cameras in the scene
  string $allCameras[] = `listCameras`;
  string $cameraOption = `optionMenu -label "Camera" -cc "updateCameraDirection" camOpField`;
  for ($currentCamera in $allCameras)
    menuItem -label $currentCamera;
  setParent ..;
 // add text top annotate view axis
  text -width 20 -height 16 -label ("["+`grabAxis` +"]") viewAxisText;
 // add button to set camera fom current view
  button -width 90 -height 26 -label "Active View" -align "center" 
           -command "grabActiveCamera" activeViewButton;
  intSliderGrp -label "Angle" -field true
    -minValue -0 -maxValue 90
    -fieldMinValue -0 -fieldMaxValue 90
    -value 0 
    -ct3 "left" "left" "left" 
    -cw3 40 50 30
    faceAngleSlider;
  radioButtonGrp -numberOfRadioButtons 4
    -label "Facing" -labelArray4 "Front" "Back" "Both" "Not"
    -sl 1
    -ct5 "left" "left" "left" "left" "left"
    -cw5 40 50 50 50 50 faceAngleRadio;
  string $projectOption = `optionMenu -label "UV Map" camProjField`;  
    menuItem -label "None";
    menuItem -label "Planar";  
    menuItem -label "Cylindrical"; 
    menuItem -label "Spherical";
  setParent ..;
 // add remap button that reapplys uv mapping without updating selection
  button -width 90 -height 26 -label "Remap" -align "center" 
           -command "fnsUVremap" uvRemapButton;

 // Gui Buttons
  button -width 90 -height 26 -label "Select" -align "center" 
         -command "selectFacebyCameraViewAngle(`optionMenu -q -v camOpField`,`intSliderGrp -q -v faceAngleSlider`,`radioButtonGrp -q -sl faceAngleRadio`); deleteUI fnsWindow " selectButton;  // select and closes
         
  button -width 90 -height 26 -label "Apply" 
         -command "selectFacebyCameraViewAngle(`optionMenu -q -v camOpField`,`intSliderGrp -q -v faceAngleSlider`,`radioButtonGrp -q -sl faceAngleRadio`)" applyButton; // select
         
  button -width 90 -height 26 -label "Close" 
         -command "deleteUI fnsWindow" closeButton;   // closes interface

 // arrange Gui
  formLayout -e	
 // -af positions a gadget relative to the edge of the form
 // -ac positions a gadget relative to another gadget
 // layout fields
    -af "camOpField" "left" 12
    -af "camOpField" "top" 12
    -ac "viewAxisText" "left" 4 "camOpField"
    -af "viewAxisText" "top" 14
    -ac "activeViewButton" "left" 26 "camOpField"
    -af "activeViewButton" "top" 10
    -af "faceAngleSlider" "left" 12    
    -ac "faceAngleSlider" "top" 6 "camOpField"
    -af "faceAngleRadio" "left" 12
    -ac "faceAngleRadio" "top" 10 "faceAngleSlider"
    -af "camProjField" "left" 12
    -ac "camProjField" "top" 10 "faceAngleRadio" 
    -ac "uvRemapButton" "left" 8 "camProjField"
    -ac "uvRemapButton" "top" 8 "faceAngleRadio" 
 // layout buttons 
    -ac "selectButton" "top" 12 "camProjField"  
    -af "selectButton" "left" 4 
    -af "selectButton" "bottom" 4
    -ac "applyButton" "top" 12 "camProjField"  
    -ac "applyButton" "left" 4 "selectButton"
    -af "applyButton" "bottom" 4
    -ac "closeButton" "top" 12 "camProjField"      
    -ac "closeButton" "left" 4 "applyButton" 
    -af "closeButton" "bottom" 4
    -af "closeButton" "right" 4
  $fnsLayout;          
  showWindow $fnsWin;
}


global proc updateCameraDirection ()
{ // set the camera Direction Text based on the current Camera
  text -e -l ("["+`grabAxis`+"]") viewAxisText;
}


global proc grabActiveCamera ()
{ // sets the camera gadget to the name of camera linking to the current active viewport
  string $currentPane = `getPanel -wf`;
  string $currentCamera = `modelEditor -q -camera $currentPane`;
  optionMenu -e -v $currentCamera camOpField; 
}


global proc string grabAxis ()
{// with the cardinal axis of a predefined camera for both Y and Z up
  string $currentCamera = `optionMenu -q -v camOpField`;
  if (`upAxis -q -axis` == "y")
    switch ($currentCamera)
    {
      case "front" : $viewAxis = "Z"; break;
      case "side"  : $viewAxis = "X"; break;     
      case "top"   : $viewAxis = "Y"; break;
      default      : $viewAxis = "P"; break;
    }   
  else 
    switch ($currentCamera)
    {
      case "front" : $viewAxis = "Y"; break;
      case "side"  : $viewAxis = "X"; break;     
      case "top"   : $viewAxis = "Z"; break; 
      default      : $viewAxis = "P"; break;
    };    
  return $viewAxis;
}


global proc fnsUVremap (string $currentCamera)
{ // remaps the current selection based on curent setings
  if (`optionMenu -q -v camProjField`!="None")
  {
    string $curProj = `optionMenu -q -v camProjField`;   
    string $curOp = `optionMenu -q -v camOpField`;
    string $mapDir;
    switch ($curOp)
    {
      case "front" : $mapDir = "z"; break;
      case "side"  : $mapDir = "x"; break;     
      case "top"   : $mapDir = "y"; break;    
      default : $mapDir = "b"; break;
    }
    string $newProj[] = `polyProjection -ch 1 -type $curProj -md $mapDir -sf 1`;
    select -addFirst $newProj;
    if ($curProj!="Planar" )
    { // aligns Project to match camera view
      // need work camera 
      setAttr ($newProj[0]+".rotateX") (90 - `getAttr ($currentCamera+".rotateX")`);
      setAttr ($newProj[0]+".rotateY") (-`getAttr ($currentCamera+".rotateY")`);
      setAttr ($newProj[0]+".projectionHorizontalSweep") 360;
      if ($curProj=="Spherical" )
        setAttr ($newProj[0]+".projectionVerticalSweep") 180;
    }
  }
}


global proc selectFacebyCameraViewAngle (string $camera, int $angle, int $choice)
{// selects the faces of current selected or highlighted objects
 // based on the angle threshold to, (or away from) the camera view vector 
 // select hilited objects 
  string $highlightedObjects[] = `ls -hl`;
  string $selectedObjects[] = `ls -sl -tr`;
  hilite -u $highlightedObjects;
 // select hilited objects
  select -r $highlightedObjects;
 // add non hilited objects that were selected 
  select -add $selectedObjects;
 // grab new selection  
  $selectedObjects = `ls -sl`;
 // calculate camera View Normal
  $viewVector = {0.0,0.0,-1.0};
  $viewVector = pointMatrixMult ($viewVector,`getAttr ($camera+"Shape.worldMatrix")`);
  select $selectedObjects;  // necessary because of bug with pointMatrixMult
  string $polyFaceInfo[]; 
  float $polyFaceValue[];
  for ($currentSelection in $selectedObjects)
  {
    $PolyFaceInfo = `polyInfo -fn`;
    string $currentFace;
    for ($i=0;$i<size($PolyFaceInfo);$i++)
    {
      string $faceNormalString = $PolyFaceInfo[$i]; //need for tokenize to work
      string $faceNormalData[];    
      int $faceTotal = tokenize($faceNormalString,$faceNormalData);        
     // convert string data to a vector 
      $faceNormal = {0.0,0.0,0.0};
      $faceNormal[0] = $faceNormalData[2];
      $faceNormal[1] = $faceNormalData[3]; 
      $faceNormal[2] = $faceNormalData[4];
     // faceNormal data is currently in shape space - mulitply with worl Matrix to get world Space
     // grab current selection to handle annoying bug that deselect everything when pointMatrixMult is called
     string $selectionMemory[] = `ls -sl`;
     $faceNormal = pointMatrixMult ($faceNormal,`getAttr ($currentSelection+".worldMatrix")`);
     // returns previous selection
     select $selectionMemory;
     // grab dot product and normalize 
      float $facingAngle = dotProduct($faceNormal, $viewVector, 1 );
     // compare faceingangle to angle threshold 
      if ($choice == 1) $facingAngle = $facingAngle * -1;  // front face
      if ($choice > 2 ) $facingAngle = abs($facingAngle);  // both Face and Not
      if ($choice <4)
        if (cosd($angle)<=$facingAngle)
        {//select Face
          hilite -r $currentSelection;
          string $faceNumber = substring($faceNormalData[1],1,size($faceNormalData[1])-1);
          select -add ($currentSelection+".f["+$faceNumber+"]");
        } else {}
      else 
        if (cosd($angle)>$facingAngle)
        {//select Face
          hilite -r $currentSelection;
          string $faceNumber = substring($faceNormalData[1],1,size($faceNormalData[1])-1);
          select -add ($currentSelection+".f["+$faceNumber+"]");
        }
    }
  }
  // map or remap UVs - if selected
  fnsUVremap($camera);
}


//including subDpolytoggle from the script of the same name by Andrew Osiow (c) 2006

global proc subdpolytoggle ()
{
  string $selectedShapes[] = `ls -sl`;
  string $currentShape;
  string $shapeNode[];
  for ($currentShape in $selectedShapes)
  { 
    DeleteHistory;
    if (nodeType ($currentShape) == "transform") 
      $shapeNode = `listRelatives -s $currentShape`;
    else $shapeNode[0] = $currentShape; 
    string $currentNodeType = `nodeType $shapeNode[0]`;
    switch ($currentNodeType)
    { //converts mesh, deletes original and renames new shape to match old name
      case "mesh":
        int $polyTotal[] = `polyEvaluate -f $currentShape`;
        string $tempName[] = `polyToSubdiv -uvt 1 -maxPolyCount $polyTotal[0] $currentShape`;
        subdivDisplaySmoothness -smoothness 3; // smooth sub-div displ3     
        delete $currentShape;
        rename $tempName[0] $currentShape;
        break;
      case "subdiv":
        string $tempName[] = 
     `subdToPoly -ch off -aut on -format 3 -depth 0 -sampleCount 1 -maxPolys 1 -extractPointPosition 1 -shareUVs 1 -subdNormals 0 $currentShape`;  
        // convert, delete subd proxy, rename poly shape node to original name 
        delete ($currentShape+"|"+$shapeNode[0]);  
        string $subDShape[] = `listRelatives -s $currentShape`;
        polySoftEdge -ch 0 -a 0; // hardens edges
        rename ($subDShape[0]) ($shapeNode[0]);
        select -r ($shapeNode[0]);
        pickWalk -d up;
        break;
      default:
        print ("incorrect type\n");
        break;
    }
  }  
}


global proc makeGlobalStitch ()
{
  GlobalStitch;
} 


global proc makeCurveOnSurface ()
{
  ProjectCurveOnSurface;
} 


global proc uberNewCurve ()
{ // duplicates a selected Iso-Parm or activates the EP Curve Tool
  string $ifSelected[] = `ls -sl`;  
  if ($ifSelected[0] == "") EPCurveTool;
  else  DuplicateCurve;
}


global proc selectNurbEdge ()
{ // select one iso-parm repeated calls will toggle to the next iso_parm
  string $selectedNurbs[] = `ls -sl`;
  string $nurbShape[] = `listRelatives -s`;
  if ($nurbShape[0]=="")
  { // get minMax UV values  
    int $stringSize = size ($selectedNurbs[0]);
   //changing if statement test value - tricky
    $nurbShape[0]= substring($selectedNurbs[0],1,$stringSize-5);
    float $borderU[] = `getAttr ($nurbShape[0]+".minMaxRangeU")`;
    float $borderV[] = `getAttr ($nurbShape[0]+".minMaxRangeV")`; 
   // detemine which iso_parm is selected and rotate select
    string $whichDir = substring ($selectedNurbs[0],$stringSize-3,$stringSize-3);
    string $whichIso = substring ($selectedNurbs[0],$stringSize-1,$stringSize-1);
    if ($whichDir == "u")
    {
      if ($whichIso == "0") select -r ($nurbShape[0]+".v["+$borderV[0]+"]");
      else select -r ($nurbShape[0]+".v["+$borderV[1]+"]");
    }
    else
    {
      if ($whichIso == "0") select -r ($nurbShape[0]+".u["+$borderU[1]+"]");
      else select -r ($nurbShape[0]+".u["+$borderU[0]+"]");        
    }    
  }
  else
    select -r ($nurbShape[0]+".u[0]");
}


global proc selectAllNurbEdges ()
{ // select all iso-parms and edge of Nurb Surface
  string $selectedNurbs[] = `ls -sl`;
  for ($selectedNurb in $selectedNurbs)
  { // getshape node
    string $nurbShape[] = `listRelatives -s`;
    if ($nurbShape[0]=="")
    { // if null get shapenode back
      int $stringSize = size ($selectedNurbs[0]);
      //changing if statement test value - tricky
      $nurbShape[0]= substring($selectedNurbs[0],1,$stringSize-5);
    }
    // get minMax UV values    
    float $borderU[] = `getAttr ($nurbShape[0]+".minMaxRangeU")`;
    float $borderV[] = `getAttr ($nurbShape[0]+".minMaxRangeV")`; 
    select -r ($nurbShape[0]+".u["+$borderU[0]+"]");
    select -add ($nurbShape[0]+".v["+$borderV[0]+"]");
    select -add ($nurbShape[0]+".u["+$borderU[1]+"]");
    select -add ($nurbShape[0]+".v["+$borderV[1]+"]"); 
  }
}


global proc extrudenurbedge ()
{ //extrudes a nurb surface, nurb curve, or isoparam by duplication the geometry and lofting
  // assuming user selects one or the others
  // a move manipulator is added to the copy to simulate the poly version   
  string $activeSelection[] = `ls -sl`;
  string $nurbEdges[];
  string $newNurbEdges[];
  string $newSurfaces[];
  string $results[];
  int $curveTotal = 0;
  int $surfaceTotal = 0;;
  for ($currentSelection in $activeSelection)
  {// for each shape duplicate the shape and loft between it and the original
   // is it a shape?
    string $shapeBuffer[];
    tokenize($currentSelection,".",$shapeBuffer);
    string $nurbShape = $shapeBuffer[0];
    if ($shapeBuffer[1]=="")
    {// it is a shape
      string $shapeNode[] = `listRelatives -s $currentSelection`;
      string $currentNodeType = `nodeType $shapeNode`;
      switch ($currentNodeType)
      {// process shape
        case "nurbsCurve":
          $nurbEdges[$curveTotal] = $currentSelection;
          select -r $currentSelection;
          $results = `duplicate -rr`;
          $newNurbEdges[$curveTotal] = $results[0];
          $newCurvesEdges[$curveTotal] = $results[0];
          $curveTotal++;
          break;
        case  "nurbsSurface":
          select -r $currentSelection;  
          selectAllNurbEdges;
          string $isoParms[] = `ls -sl`;
          select -r $currentSelection; 
          $results = `duplicate -rr`;
          $newSurfaces[$surfaceTotal] = $results[0];
          $surfaceTotal++;
          selectAllNurbEdges;
          string $newIsoParms[] = `ls -sl`;
          int $curveIndex = 0;
          for ($isoParm in  $isoParms)
          { // store all iso-parms and duplicate in newedge array
	    $nurbEdges[$curveTotal] = $isoParm;    
	    $newNurbEdges[$curveTotal] = $newIsoParms[$curveIndex];
	    $curveIndex++;
	    $curveTotal++;
          }  
          break;
      }
    }  
    else 
    {  // iso-parm selection
      $nurbEdges[$curveTotal] = $currentSelection;
      select -r $currentSelection;
      $results = `duplicateCurve -ch 1 -rn 0 -local 1`;
      $newNurbEdges[$curveTotal] = $results[0];
      $curveTotal++;
    }
  } 
 // loft each set of curves
  for ($curveIndex = 0; $curveIndex < $curveTotal; $curveIndex++)
  { 
   //print ($nurbEdges[$curveIndex]+" "+$newNurbEdges[$curveIndex]+"\n");
    select -r $nurbEdges[$curveIndex];
    select -add $newNurbEdges[$curveIndex];
    loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true;
  }
 // after the loft reselect the duplicate curve  
  if (($curveTotal> 0) || ($surfaceTotal> 0))
  { 
    select -r $newSurfaces $newNurbEdges;
    if (($curveTotal> 1) && ($surfaceTotal== 0)) // if there are more than one edge, group them
      group;
  }
  xform -cp; // center pivot;
  setToolTo moveSuperContext; // select move tool
  manipMoveContext -e -mode 2 -orientAxes 0 0 0 Move;  // select manipulator axis to world 
}


global proc newNurbPatch ()
{ //inserts a knot into a curve or span into a nurb
  Boundary;
} 


global proc uberinsert ()
{ //inserts a knot into a curve or span into a nurb 
  string $currentSelections[] = `ls -sl`;
  for ($currentSelection in $currentSelections)
  {
    string $shapeNode[] = `listRelatives -p $currentSelection`;
    string $currentNodeType = `nodeType $shapeNode`;
    switch ($currentNodeType)
    {
      case "nurbsCurve":
        insertKnotCurve -ch 0 -cos on -nk 1 -add 1 -ib 0 -rpo 1 $currentSelection;
        break;
      case  "nurbsSurface":
        insertKnotSurface -ch 1 -nk 1 -add 1 -ib 0 -rpo 1 $currentSelection;
        break;
    }
  }      
}


global proc uberRebuildCurve ()
{  // rebuilds a single curve with twice the number of knots
   // or matches the knots of a group of curves to the last one selected
  string $selectedCurves[] = `ls -sl`;
  string $currentCurve;
  string $lastCurve[] = `ls -sl -tail 1`;
  int $curveDegree = `getAttr ($lastCurve[0]+".degree")`;
  int $spanTotal = `getAttr ($lastCurve[0]+".spans")`;
  if (size($selectedCurves)==1) // rebuild with uniform and twice the number of knots
      rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s ($spanTotal*2) -d $curveDegree -tol 0.01 $selectedCurves;
  else for ($currentCurve in $selectedCurves)
  { 
    if ($currentCurve!=$lastCurve[0]) // rebuild with matched knots
      rebuildCurve -ch 0 -rpo 1 -rt 2 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spanTotal -d $curveDegree -tol 0.01 $currentCurve $lastCurve;
  }
  select $selectedCurves;
}


global proc uberRebuildSurface ()
{  // rebuilds a single surface with twice the number of spans
   // or matches the spans of a group of surfaces to the last one selected
   // history is turned offbecause most curves don't have a construction history
  string $selectedSurfaces[] = `ls -sl`;
  string $currentSurface;
  string $lastSurface[] = `ls -sl -tail 1`;
  int $curveDegreeU = `getAttr ($lastSurface[0]+".degreeU")`;
  int $curveDegreeV = `getAttr ($lastSurface[0]+".degreeV")`;  
  int $spanTotalU = `getAttr ($lastSurface[0]+".spansU")`;
  int $spanTotalV = `getAttr ($lastSurface[0]+".spansV")`;  
  if (size($selectedSurfaces)==1) // rebuild with uniform and twice the number of spans
      rebuildSurface -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 1 -su ($spanTotalU*2) -du $curveDegreeU -sv ($spanTotalV*2) -dv $curveDegreeV -tol 0.01 -fr 0 -dir 2 $selectedSurfaces;
  else for ($currentSurface in $selectedSurfaces)
  { 
    if ($currentSurface!=$lastSurface[0]) // rebuild with matched knots
      rebuildSurface -ch 1 -rpo 1 -rt 2 -end 1 -kr 0 -kcp 0 -kc 1 -su ($spanTotalU*2) -du $curveDegreeU -sv ($spanTotalV*2) -dv $curveDegreeV -tol 0.01 -fr 0 -dir 2 $currentSurface $lastSurface;
  }
  select $selectedSurfaces;
}


global proc uberRebuildNurb ()
{ // determines if selection is curve or surface and makes the appropiate rebuild
  // possible rare if curves and surfaces are selected at the same time
  string $currentSelection[] = `ls -sl`;
  string $shapeNode[] = `listRelatives -s $currentSelection[0]`;
  string $currentNodeType = `nodeType $shapeNode`;
  switch ($currentNodeType)
  {
    case "nurbsCurve":
      uberRebuildCurve;
      break;
    case  "nurbsSurface":
      uberRebuildSurface;
      break;
  }     
}


global proc rebuildNurbOptions()
{ // opens the rebuild options for surfaces or curves depending on what's selected
  string $currentSelection[] = `ls -sl`;
  string $shapeNode[] = `listRelatives -s $currentSelection`;
  string $currentNodeType = `nodeType $shapeNode[0]`;
  if ($currentNodeType=="nurbsCurve")
    RebuildCurveOptions;
  if ($currentNodeType=="nurbsSurface")
    RebuildSurfacesOptions; 
}


global proc curveDegreeToggle ()
{ // toggle curve degree from 1 to 3 - curve is converted to uniform in the process
  // history is turned off because most curves don't have a construction history
  string $selectedCurves[] = `ls -sl`;
  string $currentCurve;
  for ($currentCurve in $selectedCurves)
  {
    int $curveDegree = `getAttr ($currentCurve+".degree")`;
    $curveDegree = 4 - $curveDegree; // toggle degrees from 3 to 1
    int $spanTotal = `getAttr ($currentCurve+".spans")`;
    rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $spanTotal -d $curveDegree -tol 0.01 $currentCurve;
  }
  select $selectedCurves;
}


global proc surfaceDegreeToggle ()
{ // toggle surface degree from 1 to 3 - surface is converted to uniform in the process
  string $selectedSurfaces[] = `ls -sl`;
  string $currentSurface;
  for ($currentSurface in $selectedSurfaces)
  {
    int $surfaceDegreeU = `getAttr ($currentSurface+".degreeU")`;
    int $surfaceDegreeV = `getAttr ($currentSurface+".degreeV")`;    
    $surfaceDegreeU = 4 - $surfaceDegreeU; // toggle degrees from 3 to 1 for U
    $surfaceDegreeV = 4 - $surfaceDegreeV; // toggle degrees from 3 to 1 for V
    int $spanTotalU = `getAttr ($currentSurface+".spansU")`;
    int $spanTotalV = `getAttr ($currentSurface+".spansV")`;    
    rebuildSurface -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kc 1 -su $spanTotalU -du $surfaceDegreeU -sv $spanTotalV -dv $surfaceDegreeV -tol 0.01 $currentSurface;
  }
  select $selectedSurfaces;
}


global proc nurbDegreeToggle ()
{ // determines if selection is curve or surface to switch from 1st to 3rd and visa versa
  // possible rare bug if curves and surfaces are selected at the same time
  string $currentSelection[] = `ls -sl`;
  string $shapeNode[] = `listRelatives -s $currentSelection[0]`;
  string $currentNodeType = `nodeType $shapeNode`;
  switch ($currentNodeType)
  {
    case "nurbsCurve":
      curveDegreeToggle;
      break;
    case  "nurbsSurface":
      surfaceDegreeToggle;
      break;
  }     
}


global proc delConstructShapes ()
{
  string $selectedShapes[] = `ls -sl -tr`;
  string $currentShape;
  string $currentHistory[];
  int $historyTotal;
  string $currentParent[0];
  for ($currentShape in $selectedShapes)
  { 
     $currentHistory = `listHistory $currentShape`;
     $historyTotal = size($currentHistory);
     for ( $i = 1; $i < $historyTotal; $i++ )
     { // check to see if node is a shape node by checking for a parent
       $currentParent = `listRelatives -p $currentHistory[$i]`;
       if ($currentParent[0]!="")
         delete $currentParent[0];
     }
  } 
  DeleteHistory;
}


global proc snapCVtoCenter ()
{ // expand selected CV list to be unique
  string $selectedCVs[] = `filterExpand -ex true -sm 28`;
  string $currentCV;
  int $currentCVindex = 0;
  float $xAve = 0.0 , $yAve = 0.0, $zAve = 0.0;
  float $currentPosition[3];
  for ($currentCV in $selectedCVs)
  {
    $currentPosition = pointPosition ($currentCV);
    $xAve = $xAve + $currentPosition[0];
    $yAve = $yAve + $currentPosition[1];
    $zAve = $zAve + $currentPosition[2];  
    $currentCVindex++;
  } // calculate average point
  $totalCV = $currentCVindex;
  $xAve = $xAve / $totalCV;  
  $yAve = $yAve / $totalCV;
  $zAve = $zAve / $totalCV;
  move -a $xAve $yAve $zAve;
}


global proc edgeToFacePath ()
{ // possible failure if more than one object selected
  string $currentHighlight[] = `ls -hl`;
  setToolTo selectSuperContext; 
  SelectFacePath;
 // the current highlighted object into facet mode for furthur editing
  doMenuComponentSelection($currentHighlight[0],"facet");
}


global proc loopToCurve ()
{
  string $selectededges[] = `ls -sl`;
  int $edgeList[];
  string $curveList[];
  int $curveIndex = 0;
  string $currentEdge;
  string $results[];
  string $results2[];  
  int $edgeNumber;
  string $firstCurve;
  string $newCurve[0];
  select -cl;
  for ($currentEdge in $selectededges)
  { // go thru list of selected edges
    tokenize ($currentEdge,"[]",$results);
    tokenize ($results[0],".",$results2);
    $edgeNumber = $results[1];  
    $edgeList = `polySelect -ns -el $edgeNumber ($results2[0])`;
    $isFirst = true;
    for ($edgeNumber in $edgeList)
    { // go thru selected edges associate with loop
      select -r ($results[0]+"["+$edgeNumber+"]");
      $newCurve = `duplicateCurve -ch 0 -rn 0 -local 0 ($results[0]+"["+$edgeNumber+"]")`;
      if ($isFirst) 
      {  
        $firstCurve = $newCurve[0];
        $isFirst = false;
      }
      else 
      { // attachCurves, connect, no mulitply knots, no history, replace original, name it to original curve
        attachCurve -m 0 -kmk 1 -ch 0 -rpo 1 -n $firstCurve $firstCurve $newCurve[0];
        delete $newCurve[0];    
      }
      
    } 
    $curveList[$curveIndex] = $curveList[$curveIndex] + $firstCurve;
    $curveIndex++;
  }
  select -r $curveList;
}


global proc attachNurbs()
{ // execute an attach surfaces or curves depending on what's selected 
  string $currentSelection[] = `ls -sl`;
  string $shapeNode[] = `listRelatives -s $currentSelection`;
  string $currentNodeTypeA = `nodeType $shapeNode[0]`;
  string $currentNodeTypeB = `nodeType $shapeNode[1]`;
  if (($currentNodeTypeA=="nurbsCurve") && ($currentNodeTypeB)=="nurbsCurve")
  {  
    select -r $currentSelection[0];
    for ($index = 1; $index < size ($currentSelection); $index++)
    {
      select -add $currentSelection[$index];
      AttachCurve;
      DeleteHistory;
    }  
  }
  if (($currentNodeTypeA=="nurbsSurface") && ($currentNodeTypeB)=="nurbsSurface")
    AttachSurfaces;
} 


global proc attachNurbsOptions()
{ // opens the attach options for surfaces or curves depending on what's selected
  string $currentSelection[] = `ls -sl`;
  string $shapeNode[] = `listRelatives -s $currentSelection`;
  string $currentNodeType = `nodeType $shapeNode[0]`;
  if ($currentNodeType=="nurbsCurve")
    AttachCurveOptions;
  if ($currentNodeType=="nurbsSurface")
    AttachSurfacesOptions; 
}


global proc int isBorderEdge(string $currentEdge)
{ // determines is selected edge is border
  // assumes a single selection
  int $borderEdge;
  string $results[];
  string $infoResult[] = `polyInfo -ef $currentEdge`;
  int $words = tokenize($infoResult[0],$results);
  if ($words == 3) $borderEdge = true;
  else $borderEdge = false;
  return $borderEdge;
}


global proc selectEdgeToolCtx()
{ // the appropiate edge completion tool based on the curent tool
  string $currentTool = `currentCtx`;
  if ($currentTool == "polySelectContext")
  {
    int $selectEdgeType = `polySelectCtx -q -mode polySelectContext`;
    switch ($selectEdgeType)
    {
      case 0: SelectEdgeRingTool; break;
      case 1: SelectBorderEdgeTool; break;
      case 2: SelectEdgeLoopTool; break;
    }
  }
  else SelectEdgeLoopTool;
}


global proc setLoopOptions()
{ //set the Loop Options globals used for spaces in a loop selection
  global string $spacingSliderGad;
  global string $offsetSliderGad;
  global int $loopSpacing;
  global int $loopOffset;
  selectType -allComponents 0 -polymeshEdge 1;
  $loopSpacing = `intField -q -v $spacingSliderGad`; 
  $loopOffset  = `intField -q -v $offsetSliderGad`; 
}


global proc resetLoopSpacing()
{ //reset the Loop Options globals default (0)
  global int $loopSpacing;
  global int $loopOffset;
  $loopSpacing = 0; 
  $loopOffset  = 0; 
}


global proc selectLoopRing(int $swapOn, int $growOn, int $patternOn)
{ // completes loop or border selection based on currently selected edge 
  // repeated clicks without changing the selection will toogle between loop/border and ring
  global string $iconPath;
  global string $lastSelectedEdges;
  global string $lastOriginalEdges[];
  global int $ringSelection;
  int $loopSpacing = `intField -q -v slSpacingFloat`;
  int $loopOffset = `intField -q -v slOffsetFloat`;
  string $loopArg;
  string $selectedEdges[] = `ls -sl -fl`;
  global int $didLoopSelect;
  if (size($selectedEdges)>0)
  {// something is selected
    selectType -allComponents 0 -polymeshEdge 1; //set select type to edges
    int $edgeList[];
    string $currentEdge;
    string $results[];
    string $results2[];  
    int $edgeNumber;
    int $edgePathNumber[];
    if (`gmatch $selectedEdges[0] "*.e*"`) // selected edges - complete loop/border
    {// if adjusting - swap ring selection value so that actual selection doesn't swap
      int $edgeCount = 0;
      string $SelectedEdgeString = stringArrayToString($selectedEdges,"");
      if ($growOn)
      {
        $lastSelectedEdges = "";    
      }
      if (`strcmp $SelectedEdgeString $lastSelectedEdges`==0)  // the selection hasn't changed
      { // get set toggle the function
        if ($swapOn)
        {
          $ringSelection = 1 - $ringSelection;
        }
        $selectedEdges = $lastOriginalEdges; //grab the original selection before a polyselect function
        select -cl; // clears out posible previous selection
      } 
      else 
      {
        if ($growOn)
          $ringSelection = 1 - $ringSelection;  
        else $ringSelection = 0;        
      }       
      if (size($selectedEdges)==2) // if two edges then calculate edge numbers for loop-ring-border path  
      {
        int $index = 0;
        for ($currentEdge in $selectedEdges)
        {
          tokenize ($currentEdge,"[]",$results);
          tokenize ($results[0],".",$results2);
          $edgePathNumber[$index] = $results[1];
          $index++;
        }
        if (isBorderEdge($currentEdge))
          if ($ringSelection)
            if ($patternOn) $loopArg = "-rpt";
            else $loopArg = "-erp";
          else 
            if ($patternOn) $loopArg = "-bpt";
            else $loopArg = "-ebp";
        else 
          if ($ringSelection)
            if ($patternOn) $loopArg = "-rpt";            
            else $loopArg = "-erp";
          else 
            if ($patternOn) $loopArg = "-lpt";           
            else $loopArg = "-elp";
         // set icon image   
        if (($loopArg == "-erp") || ($loopArg == "-rpt"))
        {
          shelfButton -e -ann "Select Loop or Border" -image ($iconPath + "selectloopbrd.xpm") xbutton2;
          shelfButton -e -image ($iconPath + "selectloopbrd.xpm") slSwapButton;          
        }
        else
        {
          shelfButton -e -ann "Select Ring" -image ($iconPath + "selectring.xpm") xbutton2;
          shelfButton -e -image ($iconPath + "selectring.xpm") slSwapButton;          
        }
        if ($loopSpacing<1)  // select whole loop/border/ring if spacing is 0
          $edgeList = `polySelect -add $loopArg $edgePathNumber[0] $edgePathNumber[1] ($results2[0])`;
        else 
        {
          $edgeList = `polySelect -ns $loopArg $edgePathNumber[0] $edgePathNumber[1] ($results2[0])`;
          for ($edgeItem in $edgeList)
          {// select every other edge based on edge Spacing
            if (($edgeCount+$loopOffset) % ($loopSpacing+1) < 1)
              select -add ($results2[0] + ".e["+ $edgeItem +"]");
            $edgeCount++;  
          }
        }
      }  
      if (size($edgeList)==0) // if loop-ring-border path wasn't successful
        for ($currentEdge in $selectedEdges)
        { // go thru list of selected edges
          if (isBorderEdge($currentEdge))
            if ($ringSelection)
              $loopArg = "-er";
            else $loopArg = "-eb";
          else 
            if ($ringSelection)
              $loopArg = "-er";
            else $loopArg = "-el";
         // set icon image   
          if ($loopArg == "-er")
        {
          shelfButton -e -ann "Select Loop or Border" -image ($iconPath + "selectloopbrd.xpm") xbutton2;
          shelfButton -e -image ($iconPath + "selectloopbrd.xpm") slSwapButton;          
        }  
          else
        {
          shelfButton -e -ann "Select Ring" -image ($iconPath + "selectring.xpm") xbutton2;
          shelfButton -e -image ($iconPath + "selectring.xpm") slSwapButton;          
        }   
          tokenize ($currentEdge,"[]",$results);
          tokenize ($results[0],".",$results2);
          $edgeNumber = $results[1];
          if ($loopSpacing<1)  // select whole loop/border/ring if spacing is 0
            $edgeList = `polySelect -add $loopArg $edgeNumber ($results2[0])`;
          else 
          {
            $edgeList = `polySelect -ns $loopArg $edgeNumber ($results2[0])`;
            for ($edgeItem in $edgeList)
            {// select every other edge based on Loop Spacing
              if (($edgeCount+$loopOffset) % ($loopSpacing+1) < 1)
                select -add ($results2[0] + ".e["+ $edgeItem +"]");
              $edgeCount++;  
            }
          }            
        }
      $lastSelectedEdges = stringArrayToString(`ls -sl -fl`,""); //save current selection for future comparions
      $lastOriginalEdges = $selectedEdges;  // save the original selection 
      $growOn = false;
      $didLoopSelect = true;
    } // if no edge is selected then go to loop selection tool 
    else selectEdgeToolCtx; // no components selected
  }
  else selectEdgeToolCtx; // nothing selected
}


global proc splitOnLoop()
{//split geometry along the loop
 // select loop
  selectLoopRing(1,0,0);
 // Convert to Vertex
  PolySelectConvert 3;
 // split vertice
  SplitVertex;
 // select object
  string $curObject[] = `ls -sl`;
  string $nameBuffer[];
  tokenize($curObject[0],".",$nameBuffer);
  select -cl;
  hilite -u $nameBuffer[0];
  select -r $nameBuffer[0]; 
 // separate, delete History and unGroup
  SeparatePolygon; DeleteHistory; pickWalk -d up; ungroup;  
 // merge each object with zero tolerance
  $curObject = `ls -sl`;
  for ($obj in $curObject)
  {
    select -r $obj;
    polyMergeVertex;
  }
 // reselect new objects
  select $curObject;
}


global proc mergetoNearest()
{//Take all selected vertices and does a merge to center with neareast neighbor
  string $selectedNodes[] = `ls -sl -fl`;
  int    $isMerged[];
  int    $isMatched[];  
  float  $vertXpos[];
  float  $vertYpos[];
  float  $vertZpos[];
  float  $curVertPos[];
  float  $shortestDist[];
  string  $currentNearest[];
  int $currentNearestIndex[];
  string $vertName[];
  int $vIndex = 0;
  int $vTest = 0;    
  int $matchIndex = -1;  
  if (size($selectedNodes)>0)
  {
    if (size(`listRelatives -s $selectedNodes[0]`)>0) // Is it a shape list?
    { // we got a shape list
      // convert selection to vertice mode and select all vertices
      
      $selectedNodes = `ls -sl -fl`;
    }
    for ($vert in $selectedNodes)
    {// loadvertex positions into lists
      $isMatched[$vIndex] = false;
      $isMerged[$vIndex] = false;
      $vertName[$vIndex] = $vert;
      $curVertPos = `pointPosition $vert`;
      $vertXpos[$vIndex] = $curVertPos[0];
      $vertYpos[$vIndex] = $curVertPos[1];      
      $vertZpos[$vIndex] = $curVertPos[2]; 
      $shortestDist[$vIndex] = -1;
      $currentNearest[$vIndex] = "";
      $currentNearestIndex[$vIndex] = -1;     
      $vIndex++;
    }  
    $vIndex = 0;    
    $matchIndex = -1;
    for ($vert in $selectedNodes)
    {// test vert with all others
      $vTest = 0;  
      if (!$isMatched[$vIndex])
      { // only look at vertices that haven't ben matched
        for ($vertTest in $selectedNodes)
        {
          if (($vertTest!=$vert)&&(!$isMatched[$vTest]))  
          { // don't test a vertice against itself or vertex that already been matched
            // calculate Distance
            float $currentXDist = $vertXpos[$vIndex] - $vertXpos[$vTest];
            float $currentYDist = $vertYpos[$vIndex] - $vertYpos[$vTest];
            float $currentZDist = $vertZpos[$vIndex] - $vertZpos[$vTest]; 
            float $currentDist = sqrt(($currentXDist*$currentXDist) +
                                      ($currentYDist*$currentYDist) +
                                      ($currentZDist*$currentZDist));
           // update shortest distance and current nearest Neighbor
            if (($currentDist<$shortestDist[$vIndex])||($shortestDist[$vIndex]<0))
            { 
              $shortestDist[$vIndex] = $currentDist;
              $currentNearest[$vIndex] = $vertName[$vTest];
              $currentNearestIndex[$vIndex] = $vTest;
              $matchIndex = $vTest;
            }
          }
          $vTest++;
        }   
        $isMatched[$vIndex] = true;
        $isMatched[$matchIndex]  = true;
      }
      $vIndex++;
    } 
   // snap pairs  together and then merge at the end
    $vIndex = 0; 
    for ($vert in $selectedNodes)
    {
      if (!$isMerged[$vIndex])
      { 
        float $currentPosition1[] = pointPosition ($vert);
        float $currentPosition2[] = pointPosition ($currentNearest[$vIndex]);        
        float $xAve = ($currentPosition1[0] + $currentPosition2[0]) * 0.5;        
        float $yAve = ($currentPosition1[1] + $currentPosition2[1]) * 0.5;
        float $zAve = ($currentPosition1[2] + $currentPosition2[2]) * 0.5;
        select -r $vert;
        select -add $currentNearest[$vIndex];
        move -a $xAve $yAve $zAve;        
       // don't merge again
        $isMerged[$vIndex] = true;
        int $nearest = $currentNearestIndex[$vIndex];
        $isMerged[$nearest] = true;        
      }      
      $vIndex++;
    }
  }
 // final merge
  select $selectedNodes;
  polyMergeVertex;
  select -clear;
  print ("Merge to nearest complete.\n");
}


global proc reverseEdgeDir()
{//Reverses Selected Edge Direction
  string $currentEdges[] = `ls -sl -fl`;
 // grab shape name
  string $shapeBuffer[];
  string $edgeBuffer[];
  string $polyInfo[];
  string $polyInfoBuffer[];
  string $edgeList[];
  string $testEdge1[]; 
  string $testEdge2[]; 
  string $oldVertList[];
  string $newVertList[];  
  string $firstVertexNumber, $firstVertexName;
  string $secondVertexNumber, $secondVertexName;
  float $oldVertPos[];
  string $faceNumber, $faceName;
  string $delFaceList[];
  string $delEdgeList[];
  int $delEdgeTotal = 0;
  int $delFaceTotal = 0;
  tokenize($currentEdges[0],".",$shapeBuffer);
  string $shapeName = $shapeBuffer[0];
 // get shape Node
  string $shapeNode[] = `listRelatives -s $shapeName`; 
  for ($edge in $currentEdges)
  {//get edge number
    tokenize($edge,".",$shapeBuffer);
    tokenize($shapeBuffer[1],"[]",$edgeBuffer);
    $oldEdgeNumber = $edgeBuffer[1];
   // get vertex info 
    $polyInfo = `polyInfo -ev $edge`;
    tokenize($polyInfo[0],$polyInfoBuffer);    
    $firstVertexNumber = $polyInfoBuffer[2]; 
    $firstVertexName = $shapeName + ".vtx[" + $polyInfoBuffer[2] + "]"; 
    $secondVertexNumber = $polyInfoBuffer[3];        
    $secondVertexName = $shapeName + ".vtx[" + $polyInfoBuffer[3] + "]";  
   // hold position of second vertice 
    $oldVertPos = `pointPosition $secondVertexName`;
   // get face number of any ajoining face
    $polyInfo = `polyInfo -ef $edge`;
    tokenize($polyInfo[0],$polyInfoBuffer);    
    $faceNumber = $polyInfoBuffer[2];
    $faceName = $shapeName + ".f[" + $polyInfoBuffer[2] + "]";  
   // get and store vertex of original face
    $polyInfo = `polyInfo -fv $faceName`;
    tokenize($polyInfo[0],$polyInfoBuffer);
    clear $oldVertList;    
    for ($e=2; $e<size($polyInfoBuffer); $e++)
      // store vertex list for later
      $oldVertList[$e-2] = $polyInfoBuffer[$e];
   // get a second edge from the face   
    $polyInfo = `polyInfo -fe $faceName`;
    tokenize($polyInfo[0],$polyInfoBuffer); 
    clear $testEdge1;
    for ($e=2; $e<size($polyInfoBuffer); $e++)
    {
      if ($polyInfoBuffer[$e]==$oldEdgeNumber)
      { //get neighboring edges
        if ($e==size($polyInfoBuffer)-1)
          $testEdge1[0] = $polyInfoBuffer[2];
        else
          $testEdge1[0] = $polyInfoBuffer[$e+1];
        if ($e==2)
	  $testEdge1[1] = $polyInfoBuffer[size($polyInfoBuffer)-1];
        else
          $testEdge1[1] = $polyInfoBuffer[$e-1];
      }    
    }
   // compare test edges with neighbors of second Vertice
    $polyInfo = `polyInfo -ve $secondVertexName`;
    tokenize($polyInfo[0],$polyInfoBuffer); 
    clear $testEdge2;
    for ($e=2; $e<size($polyInfoBuffer); $e++)
      $testEdge2[$e-2] = $polyInfoBuffer[$e];   
    if (stringArrayContains($testEdge1[0],$testEdge2))
      $newEdgeNumber = $testEdge1[0];
    else 
      $newEdgeNumber = $testEdge1[1];
   // select shape in object mode
    select -cl;
    hilite -u $shapeName;
    select -r $shapeName;
   // split edge from middle of new edge to first Vertice of old edge
    string $splitCommand = "polySplit -ep " + $newEdgeNumber + " 0.5 -ep " +  $oldEdgeNumber + " 0.0";
    eval($splitCommand);  
   // look for the new vertex  by comparing to the old face verts to new
   // get face again number - could be a new face number so we need to recalculate
    $polyInfo = `polyInfo -ef $edge`;
    tokenize($polyInfo[0],$polyInfoBuffer); 
    $faceName = $shapeName + ".f[" + $polyInfoBuffer[2] + "]";
   // get and store vertex of original face
    $polyInfo = `polyInfo -fv $faceName`;
    tokenize($polyInfo[0],$polyInfoBuffer);
    clear $newVertList;
    for ($e=2; $e<size($polyInfoBuffer); $e++)
     // store vertex list for later
      $newVertList[$e-2] = $polyInfoBuffer[$e];
     //remove old from new to reveal new vertice   
    string $newestVert[] = stringArrayRemove($oldVertList, $newVertList);
    string $newVertexName = $shapeName + ".vtx[" + $newestVert[0] + "]";
   // move new vertext to old position
    select -r $newVertexName;
    move $oldVertPos[0] $oldVertPos[1] $oldVertPos[2];  
   // delete old edge or face its a border edge
    if (isBorderEdge($edge))
    { // add new face to deletion to be deleted at end
      $delFaceList[$delFaceTotal] = $faceName;
      $delFaceTotal++;
    }
    else 
    {
      $delEdgeList[$delEdgeTotal] = $edge;
      $delEdgeTotal++;
    } 
  } // cleanup time
  if ($delFaceTotal>0)
  {
    select -r $delFaceList;
    delete;
  }
  if ($delEdgeTotal>0)
    polyDelEdge -cv false -ch 0  $delEdgeList;    
 // merge vertice
  select -cl;
  hilite -u $shapeName;
  select -r $shapeName;
  polyMergeVertex;
  select -r $shapeName;
}


global proc togglePolyNormals()
{ //user procedure toturn into name command
  ToggleFaceNormals;
}


global proc conformPolyNormals()
{ //user procedure toturn into name command
  ConformPolygonNormals;
}


global proc mergePolyVertices()
{ //user procedure to turn into name command
  global int $isMaya8Plus;
  if ($isMaya8Plus)
    PolyMerge;
  else MergeVertices;
}


global proc breakOfFace()
{ //user procedure toturn into name command
  quickExtractorUnGroup(false);
}


global proc smoothPolyMesh()
{ //user procedure toturn into name command 
  SmoothPolygon;
}


global proc freezeTransformNode()
{ //user procedure toturn into name command
  FreezeTransformations;
}


global proc changeNormalValue()
{ //changes normal size as a result of drag on slider
  polyOptions -sn `floatSlider -q -v nLengthSlider`;
}


global proc int xHelpNumber(int $index)
{ // returns the xtools button number show the match help window can be opened
  int $matchFunction[] = 
    {6,6,6,6,9,9,8,34,17,3,12,8,28,2,22,28,  //a-b
     3,19,19,8,29,11,14,10,2,2,2,36,2,29,29,36,8,16,23,24,29,  //c
     20,20,20,20,20,20,20,35,18,18,29,15,15,13,13,33, //d-e
     4,12,7,10,18,14,24,7,27,1,28,11,11,11,14,14,5,25,5, //f-n
     1,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,22,2,1,12,4,7,7,7,12,19,23,24, // o-s
     12,4,12,3,3,3};   
  return $matchFunction[$index-1];
}


global proc int xFindUI(int $index)
{ // returns the xtools UI number to help locate the function
  int $matchFunction[] = 
                   {3,	3,  3,	3,  30,	1, 30,  1,  1,	3,  3,	1,  3,	
                    2,	2,  1,	1,  30,	1,  2,	3,  3,	1,  2,	1,  2, 
                    3,	30, 60,	60,  1,	2,  1,  3,  3,  3,  1,  3,  3,
                    1,  1,  1,  1,   2, 3,  1,  3,  1,  2,  2,  3,  3,
                    3,  1,  1,  3,   2, 2,  2,  3, 60,  1, 60,	1,  60,	
                    60,	60, 1,  3,   2, 2,  3,  3, 30,  3, 60,  60, 3,
                    3,  2,  1,  1,   1, 1,  2,  1, 30,  1,  1,  3,  60,
                    3,  3,  3,  3,   3, 30, 1,  3, 3,   2,  3,  3,  3,	
                    1,  3,  2,  2,   3, 60, 3,	3, 3,   3,  2,  3,  3,
                    3,  1,  1,  1,  30,	 1, 3,  3, 3,   3,  3,  3,  3,
                    1,  2,  1,  30,  3,  3, 3,  3, 3,   3, 60,  3,  3,
                    3,  3,  30, 3,   3,  3, 3,	3, 3,   3,  3,  3,  3,
                    3,  3,  1,	3,   3,  3, 2,  2, 1,   1,  1,  1,  1,
                    1,  1,  1,  1,   1,	 1, 1,  1, 1,   1,  1,  1,  1,
                    1,  1,  1,	1,   1,  1, 1,  1, 1,  30,  3,	3,  1, 
                    1,	3,  1,  1,   3,	 3, 3,	1, 60,  2,  2,  3,  3,	
                    30,	3,  3,	1,   3,	 3, 3, 30, 30,  1, 30	
                    };
  return $matchFunction[$index-1];
}


global proc int xFindNumber(int $index)
{ // returns the xtools button number to help locate the function
  int $matchButton[] = 
                   {8, 10,  6,  5,  6,  6,  6,  9,  9,  17,  16, 8,  17,
                    9,  9, 17,  3, 12,  8,  8,  4,  3,   4,   2, 2,   8, 
                    16, 3, 19, 19,  8,  9, 11, 10,  7,   7,  14, 12,  9,
                    9,  2,  2,  2, 16, 13,  2,  4,  7,  16,   9, 10, 10,
                    16, 8, 16, 13,  3,  4,  9, 11, 20,  20,  20, 20, 20,
                    20,20, 20, 16, 10, 10,  4, 16,  4,   2,  18, 18,  7,
                    7,  9, 15, 15, 13, 13, 13,  3, 12,   8,  10, 10, 18,
                    14, 5,  4,  7,  6, 14,  2, 15,  8,   4,  16,  3,  3,
                    2,  3,  6,  6,  2, 1,  16, 16, 17,   2,   8, 15, 17,
                    13,11, 11, 11, 14,  9,  3,  4,  9,   9,   8,  6,  5,
                    5,  4,  5,  4,  5,  3, 15, 12, 14,  12,   1, 12,  7,
                    7,  7, 14,  5,  8, 16, 16,  8, 11,   2,   5, 17,  9,
                    4,  6,  7,  8,  4,  2,  2,  2,  1,   1,   1,  2,  2,
                    2,  1,  1,  1,  1,  1,  2,  2,  2,   1,   1,  1,  1,
                    1,  2,  2,	2,  1,  1,  1,  1,  1,  12,   4,  8,  4,  
                    7, 11,  7,  7,  8,  8, 17, 12, 19,   3,   4,  9,  6,
                    12, 6, 11,  4, 13,  6, 17, 12,  3,   3,   3
                    };
  return $matchButton[$index-1];
}


global proc xHelpButton(int $xToolButton, int $find)
{ //Displays basic for a Particular Function
  global string $iconPath; 
  string $XToolFuncName[] = 
                   {"X-Tools Help Mode is on.",
                    "Artisan Select Face",     "Loop Selection",   "Toggle View Display","Toggle Object Display","Toggle Normals",
                    "Align Manipulator","Edge Split",    "New Poly Geometry",       "Toggle Hardness", "Conform Normals", 
                    "Merge",            "Deforming (Tweeking)",     "Extrude Poly Component",        "Combine or Mirror",            "Extract or UnGroup",
                    "Polygon Shapes","Smooth Poly Mesh","Freeze Transforms","Center Pivot",         "Delete History",
                    
                    "Artisan Select CV",     "Iso-Parm Selection",   "Toggle View Display","Toggle Object Display","Reverse Nurb Normals",
                    "Align Manipulator","Insert Knot/Iso-Parm",    "New Nurb Geometry",       "New Curve", "Project Curve", 
                    "Stitch",            "Deforming (Tweeking)",     "Extrude Nurb Component",        "Attach Nurb",            "Nurb Break-A-Part",
                    "Nurb Shapes","Rebuild Nurb","Freeze Transforms","Center Pivot",         "Delete History",
                    
                    "Artisan Select Face",     "Make Joints",   "Mirror Skeleton", "Bind Shapes", "Add Constraint",
                    "Add Field", "Create Particles",    "Make Rigid Body",       "Make N-Cloth", "Create Fluid Shape", 
                    "Create UV Map",            "Paint Weight",     "Create Paint FX",        "New Fur Description",            "Create Hair System",
                    "Create Shader","Create Light","Freeze Transforms","Center Pivot",         "Delete History"};                    
                    
  string $XToolHotKey[] = 
                   {"---",
                    "Shift+A","Shift+L","Shift+V","Shift+O","Shift+N", 
                    "Shift+R","Shift+E","Shift+G","Shift+H","Shift+C",
                    "Shift+M","Shift+T","Shift+X","Shift+J","Shift+B",
                    "Shift+U","Shift+S","Shift+F","Shift+P","Shift+D",
                    
                    "Shift+A","None.  ","Shift+V","None.  ","None.  ", 
                    "None.  ","None.  ","None.  ","None.  ","None.  ",
                    "None.  ","Shift+T","None.  ","None.  ","None.  ",
                    "None.  ","None.  ","Shift+F","Shift+P","Shift+D",
                    
                    "Shift+A","None.  ","Shift+V","None.  ","None.  ", 
                    "None.  ","None.  ","None.  ","None.  ","None.  ",
                    "None.  ","Shift+T","None.  ","None.  ","None.  ",
                    "None.  ","None.  ","Shift+F","Shift+P","Shift+D"};                    

  string $XToolFuncClick1[] = 
                   {"Click on any X-Tool Button to get a full decription of all related functions.",
                    "Activates Paint Select Tool in Component Mode and X-Tools goes into Paint Select Mode. The default is face mode.\n\nPopup Menu:\nToggle View Selected.\nGo to Object Mode.\nSelect all Meshes.\nLasso Tool.\nComponent Finder.\nSelect Half Mesh.\n\nA double click opens the Paint Selection Tool Options.",
                    "One click selects the matching loop or border of a selected edge or activates the Loop Selection Tool if no edges are selected.\n\nIf two edges are selected, a Loop Path or Border Path will be selected between to original edges.\n\nA second click will switch the select the associated ring of the orignal selection, (or the Ring Path if 2 edges were selected).\n\nPopup Menu:\ndisplays loop spacing options\nConvert to FacePath.\nConvert to Contained Faces.\nConvert edge loop to Curve.\nConvert to Contained Vertices.\nEdge Pattern turns on pattern mode instead path modefor two edges.\nSeparate on Loop breaks apart a mesh on the loop of the selected edge.\n\nA double click opens the tool options the current tool.",
                    "Toggles Wireframe on Shaded mode for the currently active view.\n\nPopup Menu:\nToggle View Selected.\nToggle Poly Info.\nToggle Xray mode.\nshows Display Modes.\nShow Hidden Meshes.",
                    "Toggles Soft Edges and Border Edges for the currently active shape.\n\nPopup Menu:\nToggle Vertices.\nToggle SoftEdges.\nToggle FaceCenters.\nToggle Border Edges.\n\nA double click opens the Custom Poly Display Option Window.",
                    "Toggles Poly Face Normal display for any curently active shape.\n\nPopup Menu:\nHalf Normal Length.\nDouble Normal Length\nShort Normal Length.\nMed. Normal Length.\nLong Normal Length.\nTiny Normal Length.\n\nA double click opens a Normal Length slider controls.",
                    "ReAligns the Move Manipulator to match the direction of the current selected component.  In the case of multiple components, the direction is averaged.\n\nA second click, (without changing selection), will return to Move Manipulator to standard world space.\n\nPopup Menu:\nAlign Scale Pivot.\nAlign to Local.\nTransform/Move Component.\nAlign to Object.\nAlign Components.\n\nA double click opens the Options for Move Manipulator.",
                    "Splits any selected edge ring in half\n\nThe Interactive Insert Loop Tool is activated if no edges are selected.\n\nPopup Menu:\nPoly Split and Edge Split.\nCut Face Tool.\nInsert Loop Options\nEdge Tools.\nRadial Split.\nSplit Polygon Tool with options box\nCrease Edge.\nReverse Edge Direction\n\nA double click opens either the Tool Options for the curent tool.",
                    "Activates the Create Poly Tool if no shapes are currently selected or the Append Poly Tool if there and object selected.\n\nIn component modes, This Button will Chamfer a vertex, Bevel a shared edge, Fill a hole from a border edge or Bridge between two border edges (Maya 8.0 or higher).\n\nPopup Menu:\nFill Hole.\nBridge (Maya8).\nFace ToolBox.\nChamfer\nCreate Poly Shapes\nInteractive Toggle.\nMake Live Toggle.",
                    "Toggles a selected edges from hard to soft or visa versa.  The function works for multiple edges but the speed begins to slow with large number of edges so it is limited to 1000.\n\nIf more 1000 edges are selected, the user can choose are all made soft or hard.\n\nPopup Menu:\nAll Soft Edges.\nAll Hard Edges.\nHard Edges at 90.\nHard Edges at 60.\nHard Edges at 45.\nHard Edges at 30.\n\nA double click opens the Poly Soften/Harden Edge Edge Options.",
                    "Perform a Conform Normal funtion on all selected shapes.\n\nPopup Menu:\nReverse Normals.\nReset to Face.",
                    "Performs a Merge Vertice function on a an active shape.\n\nPopup Menu:\nMerge Vertice to Center.\nCollapse Edge Ring.\nMerge Edge Tool.\nCollapse Component.\nSelect Unmerged Vertices.\nMerge Options\nMerge to Nearest.\nSplit Vertice.\n\nA double click opens the Merge Vertice Options.",
                    "Activates the Sculpt Geometry Tool and X-Tools goes into Sculpt Mode.\n\nThe sculpt tool radius is automatically calculated based the on cameras distance from the selected object.\n\nPopup Menu:\nDisplays Deformers functions\nCreate Lattice.\nCreate Wrap.\nSoftmod\nPlace SoftMod at Selection.\n\nA Double click opens the Tool Options for the current tool.",
                    "Extrudes any selected component, (edges or faces).  This also works for Maya 7.0, where Extrude was separated into Extrude Face and Extrude Edge.\n\nPopup Menu:\nKeep Faces Together.",
                    "Mirrors Geometry if only one object selected or conbines selected meshes into one mesh, Deletes the History, Performs Merge Vertice and Confrom Normals operations.  \n\nPopup Menu:\nMirror Duplicate using Negative Scale.\nParent Objects.\nGroup Objects.\nMirror Geometry.",
                    "If Maya has faces selected in Component Mode, this button Extracts the selection into a new shape, deletes the history, selects the new shape, centers the pivot, and activates the Move Tool.\n\nIn Object this button will ungroup a selected parent node or unparent a selected child node.\n\nPopup Menu:\nKeep Faces Together Toggle.\nUnParent Objects.\nSeparate & Extract Duplicate Face.\nUnGroup Objects.\nExtract Half\nDuplicate Half\nSeparate on Loop break mesh apart on Edge's selection loop.",
                    "Creates a Polygon Shape.\n\nPopup Menu:\nDisplays more Shape Options.\nPoly Cleanup ...\nToggles Interactive Polyshape Creation on or off.",
                    "Performs a Poly Smooth function on the selected object.  The Smooth is based on the current saved paramters for the smooth operation.\n\nPopup Menu:\nAverage Vertice.\nSubDivide Faces.\nSmooth Proxy Options.\n\nA double click opens the smooth poly options",
                    "Performs a Freeze Tranformation operation on the selected shapes.\n\nPopup Menu:\nDuplicate Object.\nDuplicate Special.\nInstance Object.",
                    "Performs a Center Pivot operation the selected shapes.\n\nPopup Menu:\n\nMore Pivot Postions.\nStand on Grid.\nCopy Pivot Position.\nPaste Pivot Position.\n\nA second click centers the pivot point in world.",
                    "Deletes Shape's History operation all selected or highlighed shapes.\n\nThis allows you delete a shapes Contruction History even if you're component mode\n\nPopup Menu:\nDelete All History.\nDelete Loop.\nDelete Construct History.\nDelete Edge.\nDelete Half\nDelete Image Planes.\nDelete Empty Groups.",
                     
                    "Activates Paint Select Tool in CV Mode and X-Tools goes into Paint Select Mode.\n\nPopup Menu:\nSelect All Curves.\nGo to Object Mode.\nLasso Tool.\nSelect all Surfaces.\n\nA double click open the Paint Selection Tool Options.",
                    "Selects Nurb Boundary Edge of a selected Nurb surface.\n\n Repeated clicks will cycle through all 4 edges.\n\nPopup Menu:\nSelect All Edges.",
                    "Toggles Wireframe on Shaded mode.\n\nPopup Menu:\nToggle XRay Mode.\nToggle Curve Display.\nToggle Surface Display.\nShow Hidden Curves\nShow Hidden Surfaces.\n\nA double click displays Nurb Display options.",
                    "Toggles Nurb CV's.\n\nPopup Menu:\nToggle Hulls.\nToggle Normals.\nToggle PatchCenters.\nToggle Edit Points.\n\nA double click opens the Custom Nurb Display Options.",
                    "Reverses Curve or Surface Direction which reverses Nurb Normals.\n\nPopup Menu:\nAlign Scale Pivot.\nAlign to Local.\nAlign to world.\nAlign to Object.\n\nA double click opens the Reverse Surface options.",
                    "Activates Move Normal Tool.\n\nPopup Menu:\nAlign Scale Pivot.\nAlign to Local.\nTransform/Move Component.\nAlign to Object.\nAlign Components.\n\nA double click opens the Move tool options.",
                    "Performs a Knot or Iso-Parm insert.",
                    "Performs Nurb Boundary function.\n\nPopup Menu:\nSquare.\nLoft.\nRevolve.\nNurb Tools...",
                    "Creates a new curve from a surface Iso-parm selection or activates EP Curve Tool if nothing is selected.\n\nPopup Menu:\nCV Curve Tool.\nEP Curve Tool.\nCurve Tools...\nToggle Close Curve.",
                    "Performs Curve Projection.\n\nPopup Menu:\nTrim.\nIntersect Surfaces Tool.\nUntrim\nNurb Boolean Tool.",
                    "Performs a Nurb Stitch function.\n\nPopup Menu:\nSnap CV's to Center.\n\nA double click open the Global Stitch Options Window.",
                    "Activates the Sculpt Geometry Tool and X-Tools goes into Sculpt Mode.\n\nThe sculpt tool radius is automatically calculated based the on cameras distance from the selected object.\n\nPopup Menu:\nDisplays Deformers functions\nCreate Lattice.\nCreate Wrap.\nSoftmod\nPlace SoftMod at Selection.\n\nA Double click opens the Tool Options for the current tool.",
                    "Extrudes selected nurb components.\n\nPopup Menu:\nExtrude Nurb along path.",
                    "Performs a Curve or Surface Attach based on the current Attach Option settings.\n\nFor Curves, The function can handle more than two curves at a time.  Curves are connected in the order selected.\n\nPopup Menu:\nMirror Duplicate using Negative Scale.\nParent Objects.\nGroup Objects.",
                    "Performs a Curve or Surface Detach.\n\nPopup Menu:\nUnParent Objects.\nUnGroup Objects.",
                    "Creates a Nurb Shape.\n\nPopup Menu:\nDisplays more Shape Options.\nConvert Nurb to Polygon\nToggles Interactive Polyshape Creation on or off.",
                    "Performs a Nurb Rebuild function.  The function works for both Curves and Surfaces.\n\nIf multiple shapes are selected, the rebuild mode is match and all shapes a rebuilt to match the spans of the last shape.\n\nIf one shape is selected, the uniform mode is select and shape is rebuilt with twice the number of spans.\n\nPopup Menu:\nToggle Nurb Degree between 1st and 3rd.\n\nA double click opens Nurb Rebuild Options.",
                    "Performs a Freeze Tranformation.\n\nPopup Menu:\nDuplicate Object.\nDuplicate Special.\nInstance Object.\nCenter Selection Options.\nStand on Grid.",
                    "Performs a Center Pivot operation the selected shapes.\n\nPopup Menu:\n\nCenter Pivot Options Center Selection Options.\nStand on Grid.\nCopy Pivot Position.\nPaste Pivot Position.\n\nA second click centers the pivot point in world.",
                    "Deletes Shape's History.\n\nPopup Menu:\nDelete All History.\nDelete Construct History.\n ---\nDelete Image Planes.\nDelete Empty Groups.",

                    "Activates Paint Select Tool in CV Mode and X-Tools goes into Paint Select Mode.\n\nPopup Menu:\nSelect All Curves.\nGo to Object Mode.\nLasso Tool.\nSelect all Surfaces.\n\nA double click open the Paint Selection Tool Options.",
                    "Activates the Draw Bones tool\n\nPopup Menu:\nSet Bone Radius.\nPrefix Joints\nSearch and Replace Joint Names\nToggle Local Axis\n\nA double click opens the Draw Bones Tool Options.",
                    "Mirror Skeleton.\n\nPopup Menu:\nOrient Joint\nIK Handle.\nIK Spline Handle.\nInsert Joint.\n\n",
                    "Activate Soft Bind Function.\n\nPopup Menu:\nReturn to Bind Pose\nMirror Skin Weights.\nCopy Skin Weights.\nRigid Bind\nPune Weights.\nDetach Skin.\n\n",
                    "Creates Point Constraint.\n\nPopup Menu:\nAim Constraint.\nGeometry Contraint.\nOrient Constraint.\nParent Constraint.\n\n",
                    "Creates Gravity Field.\n\nPopup Menu:\nUniform Field.\nRadial Field.\nVolume Axis Field.\nNewton Field.\nTurbulance Field.\nAffect Selected\n\n",
                    "Creates an Omni Emitter.\n\nPopup Menu:\nCollide.\nCollision Event Editor.\nParticle Goal.\nParticle Instance.\n,Dynamic Relationship Editor.\nParticle Tool.\n\n",
                    "Creates a Rigid Body.\n\nPopup Menu:\nPassive Body.\nSoft Body.\nSprings.\nNail Constrait\nHinge Constraint\nPin Constraint\nSpring Constraint.\n\n",
                    "Creates an Active N-Cloth.\n\nPopup Menu:\nPassive N-Cloth.\nPoint to Surface Contraint.\nTransform Constraint.\nComponent to Component.\n\n",
                    "Creates a 2D Fluid Shape with an Emitter.\n\nPopup Menu:\n3D Fluid Shape.\nAdd an Emitter to a Fluid.\nCollide with Fluid.\n\n",
                    "Creates a Planar Projection.\n\nPopup Menu:\nCylinder Projection.\nSpherical Projection.\nU/V Editor.\n\n",
                    "Activates the Paint Weights Tool.\n\nPopup Menu:\nPaint N-Cloth.\nSoft Body.\nPaint Fuild.\nComponent Editor.\n\nA Double click opens the Tool Options for the Paint Weights Tool.",
                    "Activates the Paint FX Brush.\n\nPopup Menu:\nVisor Window.\nConvert to Polygon.\nMake Paintable.\nCurrent Brush Settings.\n\n",
                    "Create Fur Description.\n\nPopup Menu:\nPaint Fur Attributes.\n\n",
                    "Creates a Hair System.\n\nPopup Menu:\nPaint Follicles.\nMake Curves Dynamic.\n\n",
                    "Creates a Blinn Shader.\n\nPopup Menu:\nLayered Shader.\nAnsiotrophic Shader.\nLambert Shader.\nPhong Shader.\nPhong E Shader.\nHyperShader Window.\nDelete Unused Shaders.\n\n",
                    "Creates a Spot Light.\n\nPopup Menu:\nPoint Light.\nDirectional Light.\nAmbient Light.\nVolume Light.\nArea Light.\nMake Light Links.\nBreak Light Links.\nLink Editor.\n\n",
                    "Performs a Freeze Tranformation.\n\nPopup Menu:\nDuplicate Object.\nDuplicate Special.\nInstance Object.\nCenter Selection Options.\nStand on Grid.",
                    "Performs a Center Pivot operation the selected shapes.\n\nPopup Menu:\n\nCenter Pivot Options Center Selection Options.\nStand on Grid.\nCopy Pivot Position.\nPaste Pivot Position.\n\nA second click centers the pivot point in world.",
                    "Deletes Shape's History.\n\nPopup Menu:\nDelete All History.\nDelete Construct History.\n ---\nDelete Image Planes.\nDelete Empty Groups."};
                                                                                                                               
 // Help Text Begins 
  if ($xToolButton>0)
  {
    print ("\n<<Help Begins>>\n");     
    print ("Button Name: "+$XToolFuncName[$xToolButton]+"\n");
    print ("Hotkey: "); 
    print ($XToolHotKey[$xToolButton]+"\n");  
    print ("Description:\n"); 
    print ($XToolFuncClick1[$xToolButton]+"\n");
    if ($find)
      print ("<<Find Ends>> Click on highlighted button to continue.\n");
    else
      print ("<<Help Ends>> Press another button or uncheck \"Help Mode\" on Help Menu.\n\n");  
  }
  else
  { 
    print ($XToolFuncName[$xToolButton]+"\n");
    print ("Press an X-Tool button to see a description of related functions.\n");
  }
}


global proc createSculptPrimitive()
{ // creates a poly mesh with the correct geometry suitable for sculpting
  string $newShape[] = `polyCube -w 2.4 -h 2.4 -d 2.4 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1`;
  polySmooth  -mth 0 -dv 3 -c 1 -kb 1 -ksb 1 -khe 0 -kt 1 -kmb 1 -suv 1 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $newShape[0];
  select -r $newShape[0];
  DeleteHistory;
}


global proc xPolyMirror (int $direction)
{ // performs poly mirror and adjusts merge tolerance
  // move pivot point to the apropiate side of the bounding box
  string $currentShapes[] = `ls -sl`;
  float $currentMergeDist = `optionVar -q polyMergeVertexDistance`;
  if ($currentMergeDist < 0.001)
    $currentMergeDist = 0.001;
  for ($currentShape in $currentShapes)
  {// for each shape
   // move pivot point to the miroring side of box
    switch ($direction)
    {
      case 0:
        centerpivotconstrain(3);
        break;
      case 1:
        centerpivotconstrain(0);
        break;
      case 2:
        centerpivotconstrain(4);
        break;
      case 3:
        centerpivotconstrain(1);
        break;
      case 4:
        centerpivotconstrain(5);
        break;
      case 5:
        centerpivotconstrain(2);
        break;        
    }
    string $mirrorNode[] = `polyMirrorFace -ws 1 -direction $direction -mergeMode 1 -ch 1$currentShape`;
    setAttr ($mirrorNode[0]+".mergeThreshold") $currentMergeDist;
  }
}


global proc standOnGrid()
{ // stands object on grid by moving pivot to bottom of bounding box and moving up in Y
  centerpivotconstrain(1);
  move -rpr -y 0; 
}


global proc mirrorHalf(int $axis)
{ // duplicate selected objects across an axis with a negative scale
  // then performs the appropiate function to negate the negative transform
  string $currentSelection[] = `ls -sl`;
  for ($currentShape in $currentSelection)
  {
    string $newShape[] = `duplicate -rr`;
    switch ($axis)
    { // scale along the appropiate axis
      case 1:
        scale -r -1 1 1;
        break;  
      case 2:
        scale -r 1 -1 1;
        break;   
      case 3:
        scale -r 1 1 -1;
        break;           
    }
   // get shape type
    string $newShapeNode[] = `listRelatives -s`;  
    string $currentNodeType = `nodeType $newShapeNode[0]`;
   // set transforms to zero 
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $newShape[0];
    switch ($currentNodeType)
    {
      case "mesh":
        ReversePolygonNormals;
        select -r $newShape[0];
        DeleteHistory;
        break;
      case  "subdiv":
        ReversePolygonNormals;
        select -r $newShape[0];
        DeleteHistory;
        break; 
      case "nurbsCurve":
        reversePreset 1 1 0;
        break;
      case  "nurbsSurface":
        reversePreset 1 1 0;
        break;         
    }  
  }  
}


global proc saveUserShelf()
{ // write contents of User Shelves out two separate Files
  global string $scriptPath;
  global string $userXShelf;
  global string $userAltShelf;  
  print ("Saving "+ $scriptPath + "xTools_UserShelf.\n"); 
  saveShelf $userXShelf ($scriptPath + "xTools_UserShelf");
  print ("Saving "+ $scriptPath + "xTools_AltShelf.\n"); 
  saveShelf $userAltShelf ($scriptPath + "xTools_AltShelf");    
}


global proc addShelfFile (string $currentShelf, string $shelfFile)
{// add shelf file to X-Tools User Shelf 
//  global string $shelfPath;
  global string $scriptPath;
  if ($scriptPath=="")
    $scriptPath = `internalVar -userScriptDir`;
  if ($shelfFile == "") 
  {// if the file name is blank then prompt the user 
    $shelfFile = `fileDialog -dm ($scriptPath+"*.mel")`;
    if ($shelfFile == "")  // The user cancelled the dialog
      return;
  }
  else $shelfFile = $scriptPath + $shelfFile;
  string $buffer[];
  int $numTokens = `tokenize $shelfFile "/" $buffer`;
  string $shortFileName = $buffer[$numTokens - 1];  
 // The double backslash is to prevent the '.' from being used as a wildcard.
  string $shelfName = `substitute "\\.mel" $shortFileName ""`;  
 // The name of the shelf will be the name of the procedure without the shelf_ prefix	
  string $name = `substitute "shelf_" $shelfName ""`;
  if ($shelfName == "" || $name == "") 
  {
    error ("Not a valid shelf file.");
    return;
  } 
 // if file exists then source
  if (`filetest -f $shelfFile`)
  { // print memo
    if (`window -ex xsWindow`)
    {
      text -e -l "Starting X-Tools." xsText;
      progressBar -edit -step 1 xsProgressControl;  
    }
    else print ("Loading " + basename($shelfFile, ".mel" ) + ".\n");  
    string $shelfScriptCmd = "source \""+ $shelfFile+"\";";  
    eval ($shelfScriptCmd);
  } 
  else // write error
  {
    error ($shelfFile + " not found.\n Invalid name or script not in path.\n");
    return;
  }
 // load file into X-Tools User Shelf 
  setParent $currentShelf;
  eval ($shelfName);
}


// these Polyconstraint flags are tricky - edit with care
// -w flag needs to reset to zero after a polySelect or it may affect future call
global proc selectSpecialFaces(int $faceType)
{
  selectMode -component; 
  selectType -allComponents 0 -polymeshFace 1;
  if ($faceType < 4) //tris, quads, ngons
  {
    polySelectConstraint -m 3 -t 0x0008 -sz $faceType; 
    polySelectConstraint -m 0 -sz 0;
  }
  else  // non tri-angularible or lamina
  {  
    $faceType = $faceType -3;
    polySelectConstraint -m 3 -t 0x0008 -tp $faceType;
    polySelectConstraint -m 0 -tp 0;
  }
}


global proc selectSpecialEdges(int $edgeType)
{
  selectMode -component; 
  selectType -allComponents 0 -edge 1;
  polySelectConstraint -m 0 -bo true;  
  polySelectConstraint -m 3 -t 0x8000 -w 1 -bo true;
  polySelectConstraint -m 0 -bo false;  
  polySelectConstraint -m 0 -w 0;
}


global proc select2EdgedBrdr()
{ // selects border edges and they determines which are sharing vertices
  selectMode -component; 
  selectType -allComponents 0 -edge 1;
  polySelectConstraint -m 0 -bo true;  
  polySelectConstraint -m 3 -t 0x8000 -w 1 -bo true;
  polySelectConstraint -m 0 -bo false;  
  polySelectConstraint -m 0 -w 0;
  string $borderEdges[] = `ls -sl -fl`;
  string $twoEdgedBrdrs[];
  int $twoEBTotal = 0;
  for ($borderEdge in $borderEdges)
  {  //select each border edge an get edge and grab its connected border 
    string $borderList[] = `polySelect -add -eb $borderEdge`;
    if (size($borderList) ==2)
    {
      $twoEdgedBrdrs[$twoEBTotal] = $borderEdge;
      $twoEBTotal++;
    }
  }
  select -r $twoEdgedBrdrs;
}


global proc selectFlippedEdge()
{ //selects two faced edges that have oposing normals
  string $selectedNodes[] = `ls -sl -fl`;
  string $selectedEdges[] = `ls -sl -fl`;
  string $flippedEdges[];
  int $edgeTotal = 0;
  if (size($selectedNodes)>0)
  {
    if (size(`listRelatives -s $selectedNodes[0]`)>0) // Is it a shape list?
    { // we got a shape list so select the edges
      hilite -r $selectedNodes[0];
      selectMode -component; 
      selectType -allComponents 0 -polymeshEdge 1; //set select type to edges
      int $polyResults[] = `polyEvaluate -f $selectedNodes[0]`;
      select -r ($selectedNodes[0]+".e[0:"+$polyResults[0]+"]");
      $selectedEdges = `ls -sl -fl`;
    }
    for ($edge in $selectedEdges)
    {
     // get shared faces 
      string $sharedFaces[]  = `polyListComponentConversion -fe -tf $edge`;
      $sharedFaces = `filterExpand -sm 34 $sharedFaces`;
      if (size($sharedFaces)==2) // internal Edge
      {
        string $edgeVertices[] = `polyListComponentConversion -fe -tv $edge`;
       // get the face ordered of vertices of shared faces
        string $vertexBuffer0[];
        string $vertexBuffer1[];       
        string $vertexList0[] = `polyInfo -fn $sharedFaces[0]`;
        int $vertexWords0 = tokenize($vertexList0[0],$vertexBuffer0);
        string $vertexList1[] = `polyInfo -fn $sharedFaces[1]`;
        int $vertexWords1 = tokenize($vertexList1[0],$vertexBuffer1);             
        if ($vertexBuffer0[3]!=$vertexBuffer1[3])
        {
          $flippedEdges[$edgeTotal] = $edge;
          $edgeTotal++;
        }
      }
    }
    select -r $flippedEdges;
  }
}


global proc selectSpecialVertice(int $verticeType, int $borderType)
{ 
  selectMode -component; 
  selectType -allComponents 0 -vertex 1;
  if ($verticeType < 3)
  { //non stars
    if ($verticeType > 1)  
    { // winged vertices and orphans
      polySelectConstraint -m 3 -t 1 -w $borderType -or on -orb 0 2;  // to get vertices with 0 to 2 neighbors
      polySelectConstraint -m 0 -or off -w 0;	
    }
    else
    { // vertice types
      polySelectConstraint -m 3 -t 1 -w ($verticeType+1);
      polySelectConstraint -m 0 -w 0;
    }
  }  
  else
    if ($verticeType < 6)
    { // vertices with 3 or more neighbors
      polySelectConstraint -m 3 -t 1 -w $borderType -or on -orb $verticeType $verticeType;  // to get stars/poles of a specific number
      polySelectConstraint -m 0 -or off -w 0;	    
    }
    else
    {
      polySelectConstraint -m 3 -t 1 -w $borderType -or on -orb $verticeType 256;  // to get stars/poles of a specific number
      polySelectConstraint -m 0 -or off -w 0;	    
    }
}


global proc quickExtract (int $dupFaces)
{ // turns select faces into a separate mesh with manipulator on the object
  // if dupfaces is true the selected faces ae face duplicated before extraced
  // dupfaces flag is ignored if objects are selected
  if ($dupFaces) DuplicateFace;
  else ExtractFace; 
  DeleteHistory; 
  pickWalk -d up;
  string $parentNode[] = `ls -sl`;
  string $selectedMeshes[] = `listRelatives -c $parentNode[0]`;
  ungroup; 
  select -r $selectedMeshes;
  int $highestTotal = 0;
  string $biggestMesh;
  for ($currentMesh in $selectedMeshes)
  { // look for the resulting mesh with highest face total
    int $polyResults[] = `polyEvaluate -f $currentMesh`;
    if ($polyResults[0] > $highestTotal)
    {
      $biggestMesh = $currentMesh;
      $highestTotal = $polyResults[0];
    }
  }
 // deselect biggest mesh
  select -d $biggestMesh;
  xform -cp; 
  setToolTo moveSuperContext;
  manipMoveContext -e -mode 2 -orientAxes 0 0 0 Move;
}


global proc breakHierarchy ()
{ // objects are ungrouped or unparented based on if there is a parent node
  string $selectedObjects[] = `ls -sl`;
  string $currentObject;
  for ($currentObject in $selectedObjects)
  {
    string $anyParents[] = `listRelatives -p`;
    if (size($anyParents)==0) ungroup;
    else parent -w;
  }
}


global proc quickExtractorUnGroup (int $dupFaces)
{ // extracts faces or ungroups shapes depending if faces are selected or not  
  string $selectedItems[] = `ls -sl -fl`;
  // for each selected item is it group or face component
  if (`nodeType $selectedItems[0]` == "mesh") // Is it a face?
    quickExtract($dupFaces);
  else breakHierarchy;  
}


global proc detachNurbUngroup ()
{ //detaches a nurb/curve or ungroups/unparent based on the selection
  string $currentSelection[] = `ls -sl`;
  if ((size($currentSelection)>0)&&(`gmatch $currentSelection[0] "*.*"`)) // Is it a shape?
    DetachSurfaces;      
  else 
    breakHierarchy;
}


global proc uberSplitEdge ()
{ // splits any selected edges in half,  If there are no Edges selected, activate the interactive tool
  // the tool can also toggle between a split edge ring and a insert loop if the original selection doesn't change
  // this code also checks to see if an edge has been previous split because it is part of a ring of another
  // selected edge
  int $firstVertex[];
  int $secondVertex[];
  string $selectedEdges[] = `ls -sl -fl`;
  if ($selectedEdges[0]!="")
  {//something selected
    turnOffToolMessages; //turn off interactive Tool Messages
   // grab shape name
    string $shapeBuffer[];
    tokenize($selectedEdges[0],".",$shapeBuffer);
    string $shapeName = $shapeBuffer[0]; 
    $edgeIndex = 0;
    for ($selectedEdge in $selectedEdges)
      if (`gmatch $selectedEdge "*.e*"`) // selection is an edge
      {// grab vertices of the current edge a store for later comparison 
        string $vertexInfo[] = `polyInfo -ev $selectedEdge`;
        string $vertexBuffer[];
        string $currentEdgePoints[];
        tokenize($vertexInfo[0],$vertexBuffer);    
        $firstVertex[$edgeIndex] = $vertexBuffer[2]; 
        $secondVertex[$edgeIndex] = $vertexBuffer[3];
        $edgeIndex++;      
      }
    print ($edgeIndex+"\n");
    $edgeIndex = 0;  
    for ($selectedEdge in $selectedEdges)
      if (`gmatch $selectedEdge "*.e*"`) // selection is an edge 
      {// only split an edge if it's vertex numbers match the stored value-ie it hasn't been already split
        string $vertexInfo[] = `polyInfo -ev $selectedEdge`;
        string $vertexBuffer[];  
        tokenize($vertexInfo[0],$vertexBuffer); 
       // the vertex numbers match then split the edge
        if (($firstVertex[$edgeIndex]==$vertexBuffer[2])&&($secondVertex[$edgeIndex]==$vertexBuffer[3]))
        {// select current edge and ring split in half
          select -r $selectedEdge;  // select current Edge
          polyConvertToRingAndSplit;  // split selected ring in half    
        }
        $edgeIndex++;
      }
    if ($edgeIndex < 1) ;
       SplitEdgeRingTool; // no edges found
    restoreToolMessagesSettings; // restore Message setting to their previous state        
  }  
  else SplitEdgeRingTool; // nothing selected
}


global proc quadsFrom35Edge ()
{ // split any edge between a tri and a pentagon into 3 quads
  string $selectedEdges[] = `ls -sl`;
 // fliter expand selection
  $selectedEdges = `filterExpand -sm 32 $selectedEdges`;
  ConvertSelectionToVertices;
  string $oldVertices[] = `ls -sl`;  // holding onto old selected vertices
  select -r $selectedEdges; // reselecting edges
 // grab shape name
  string $shapeBuffer[];
  tokenize($selectedEdges[0],".",$shapeBuffer);
  string $shapeName = $shapeBuffer[0];
 // get old number of vertices 
  int $oldVerticeTotal[] = `polyEvaluate -v $shapeName`; 
  for ($selectedEdge in $selectedEdges)
  {// grab vertices of the curent edge
    string $vertexInfo[] = `polyInfo -ev $selectedEdge`;
    string $vertexBuffer[];
    string $currentEdgePoints[];
    tokenize($vertexInfo[0],$vertexBuffer);    
    $currentEdgePoints[0] = $shapeName + ".vtx[" + $vertexBuffer[2] + "]"; 
    $currentEdgePoints[1] = $shapeName + ".vtx[" + $vertexBuffer[3] + "]";
   // get shared faces 
    string $sharedFaces[] = `polyListComponentConversion -fe -tf $selectedEdge`;
    $sharedFaces = `filterExpand -sm 34 $sharedFaces`;
   // get vertices for the two faces
    string $firstFaceVertices[] = `polyListComponentConversion -ff -tv $sharedFaces[0]`;
    $firstFaceVertices = `filterExpand -sm 31 $firstFaceVertices`;
    string $secondFaceVertices[] = `polyListComponentConversion -ff -tv $sharedFaces[1]`;
    $secondFaceVertices = `filterExpand -sm 31 $secondFaceVertices`;   
    if ((size($firstFaceVertices)==3)&&(size($secondFaceVertices)==5)||
        (size($firstFaceVertices)==5)&&(size($secondFaceVertices)==3))
    { // splits the pent. from it's far vertice to it's shared edge
      string $thePentagon;
      if (size($firstFaceVertices)==3)
        $thePentagon = $sharedFaces[1];
      else 
        $thePentagon = $sharedFaces[0];
     // get the face ordered vertices of the pentagon 
      string $vertexResults[] = `polyInfo -fv $thePentagon`;
      int $vertexWords = tokenize($vertexResults[0],$vertexBuffer);
     // load results into a list
      string $sharedVertices[];
      for ($index = 2; $index < $vertexWords; $index++)
        $sharedVertices[$index-2] = ($shapeName+".vtx["+$vertexBuffer[$index]+"]");   
     // find vertex number in list that matches the first shared edge point 
      int $firstEdgePointIndex;
      int $secondEdgePointIndex;
     // selecting new vertice for the shared edge's first end point 
      for ($index = 0; $index < size($sharedVertices); $index++)
        if (`strcmp $currentEdgePoints[0] $sharedVertices[$index]` == 0)
          $firstEdgePointIndex = $index;
     // selecting new vertice for the shared edge's second end point
      for ($index = 0; $index < size($sharedVertices); $index++)
        if (`strcmp $currentEdgePoints[1] $sharedVertices[$index]` == 0)
          $secondEdgePointIndex = $index;
     // calculate the index of the far point
      $farPointIndex = $firstEdgePointIndex + 1;
      if ($farPointIndex == 5) $farPointIndex = 0;
      if ($farPointIndex == $secondEdgePointIndex)
        $farPointIndex = $farPointIndex + 2;
      else $farPointIndex++; 
      if ($farPointIndex > 4)  
        $farPointIndex = $farPointIndex - 5;
     // getting a shared edge for the far point
      string $farEdge[] = `polyListComponentConversion -fv -te $sharedVertices[$farPointIndex]`;
      $farEdge = `filterExpand -sm 32 $farEdge`;
     // used first edge for splitting and get vertex info to calc ep value
      string $vertexInfo[] = `polyInfo -ev $farEdge[0]`;
     // converting first point into vertex format
      tokenize($vertexInfo[0],$vertexBuffer);    
      $testVertex = $shapeName + ".vtx[" + $vertexBuffer[2] + "]"; 
     // calculating faredgepoint value 
      float $farEdgePointValue;
      if ($sharedVertices[$farPointIndex] == $testVertex) // if first new vertice matches first test vertice then value is 0.0
        $farEdgePointValue = 0.0;
      else $farEdgePointValue = 1.0;  // else set to 1.0
     // strip out all but edge numbers
      string $results[];      
      tokenize ($farEdge[0],"[]",$results);
      string $farEdgeNumber = $results[1]; 
      tokenize ($selectedEdge,"[]",$results);
      string $selectedEdgeNumber = $results[1]; 
      string $splitCommand = "polySplit -ep " + $farEdgeNumber + " " + $farEdgePointValue + ".0 -ep " + $selectedEdgeNumber + " 0.5";
      eval($splitCommand);
    } // end if a valid split loop
  } // end for selected loop
 // redisplay saved vertices
  select -r $oldVertices; 
 // get new vertices 
  int $newVerticeTotal[] = `polyEvaluate -v $shapeName`;
  string $selectionString = $shapeName + ".vtx[" + $oldVerticeTotal[0] + ":" + ($newVerticeTotal[0]-1) + "]";
  select -add $selectionString;
  ConvertSelectionToContainedEdges;
}


global proc radialEdgeSplit ()
{ // produces a radial edge split around selected components
  string $faceBuffer[];
  string $edgeBuffer[];
  string $shapeBuffer[];
  int $sortedCount = 0;
  string $myIntersector = `stringArrayIntersector`;
  int $isVertices = false;  
 // build selection of attached edges
 // if selection is vertices then convert to contained faces
  if (size(`filterExpand -sm 31`) > 0)
  { $isVertices = true;
    ConvertSelectionToContainedFaces;
  }
  ConvertSelectionToEdges;
  if (!$isVertices)
  {
    string $innerEdges[] = `ls -sl -fl`;
    GrowPolygonSelectionRegion;
    select -d $innerEdges;
  }
  string $unsortedEdges[] = `ls -sl -fl`;
  string $sortedEdges[];
 // grab shape name
  tokenize($unsortedEdges[0],".",$shapeBuffer);
  string $shapeName = $shapeBuffer[0];
 // calculates vertice total 
  int $oldVerticeTotal[] = `polyEvaluate -v $shapeName`; 
  int $sortedTotal = 0;
  while (size($unsortedEdges) > 0)
  { // build an order list that be sent the poly split command
    $sortedEdges[0] = $unsortedEdges[0];
    for ($currentEdge in $unsortedEdges)
    { // find a border Edge if there is one
      if (isBorderEdge($currentEdge))
      { // if found sorted edge becomes start of sorted list
        $sortedEdges[0] = $currentEdge;
        break; break;
      }
    }   
   // remove sorted edges from unsorted list
    $unsortedEdges = stringArrayRemove($sortedEdges, $unsortedEdges);
   // initializing next edge 
    $sortedCount = 1;
    $sortedEdges[1] = "";
    string $lastFace = "";
    int $loopNotDone = true;
   // repeat edge building out of edges, or border edge is detected
    while (($loopNotDone) || ($sortedCount < 2))
    { 
     // grab connected faces and format
      string $faceResults[] = `polyInfo -ef $sortedEdges[$sortedCount-1]`;
      $faceWords = tokenize($faceResults[0], $faceBuffer);
     // taking results and formating them into proper name strings
      string $sharedFaces[];
      string $currentFace;
      for ($index = 2; $index < $faceWords; $index++ )
        $sharedFaces[$index-2] = ($shapeName+".f["+$faceBuffer[$index]+"]");
     // pick a face - make sure it hasn't been used   
      $currentFace = $sharedFaces[0]; 
      if ($lastFace == $sharedFaces[0])
        $currentFace = $sharedFaces[1];
     // get shared edges of the face 
      string $edgeResults[] = `polyInfo -fe $currentFace`;
     // setting current face as used 
      $lastFace = $currentFace;
      $edgeWords = tokenize($edgeResults[0], $edgeBuffer);
      string $newEdges[];
      for ($index = 2; $index < $edgeWords; $index++ )
        $newEdges[$index-2] = ($shapeName+".e["+$edgeBuffer[$index]+"]");
      stringArrayIntersector -edit -intersect $unsortedEdges $myIntersector;
      stringArrayIntersector -edit -intersect $newEdges      $myIntersector;
      string $commonEdges[] = `stringArrayIntersector -query $myIntersector`;
      stringArrayIntersector -edit -reset $myIntersector;
     // test if loop complete - if no edge found in the unsorted list then the list is complete
      if ($commonEdges[0]=="")
        $loopNotDone = false;
      else // add edge to sorted list 
      {
        $sortedCount++;
        $sortedEdges[$sortedCount-1] = $commonEdges[0];
       // if border edge then done
        if (isBorderEdge($commonEdges[0]))
          $loopNotDone = false;          
      } // end while loop to build loop
     // remove sorted edges from unsorted list 
      $unsortedEdges = stringArrayRemove($sortedEdges, $unsortedEdges);
    } // end while loop to build possilbe other loops
   // if it's not a border then then add to list again to repeat and close loop 
    if (!isBorderEdge($sortedEdges[$sortedCount-1])) 
    {
      $sortedEdges[$sortedCount] = $sortedEdges[0]; 
      $sortedCount++;    
    } 
   //polySplit with sorted edge list numbers  
    string $splitCommand = "polySplit -ch on -s 1 ";
    for ($index = 0; $index < $sortedCount; $index++ )
    { 
      string $results[];
      tokenize ($sortedEdges[$index],"[]",$results);
     //tokenize ($results[0],".",$results2);
      string $edgeNumber = $results[1];  
      $splitCommand = $splitCommand + "-ep " + $edgeNumber + " 0.5 ";
    }
   // exeecute split command 
    eval($splitCommand);    
  } 
 // delete string intersection structure 
  deleteUI $myIntersector;
  select -cl;
 // select new loop 
  int $newVerticeTotal[] = `polyEvaluate -v $shapeName`;
  string $selectionString = $shapeName + ".vtx[" + $oldVerticeTotal[0] + ":" + ($newVerticeTotal[0]-1) + "]";
  select -r $selectionString;
  ConvertSelectionToContainedEdges;
}


global proc toggleEdgeHardness ()
{// finds out if a edge ia hard or soft and then sets it opposite value
 // create string interesect object
  global int $makeSoft;
  string $myIntersector = `stringArrayIntersector`;
  string $selectedNodes[] = `ls -sl -fl`;
  if (size($selectedNodes)>0)
  {
    if (size(`listRelatives -s $selectedNodes[0]`)>0) // Is it a shape list?
    { // we got a shape list
      for ($currentShape in $selectedNodes)
      { // make each object soft on the first click and hard on the second
        select -r $currentShape;
        if ($makeSoft)
          polySoftEdge -a 180;
        else polySoftEdge -a 0;
      }
      $makeSoft = 1 - $makeSoft; 
      select -r $selectedNodes;
    }
    else if (size($selectedNodes)< 1000) // if more that a thousand edges
    { // use polySelect to determine edge hardness and toggle
      // this following loop is fast for what it does but more than 1,000 is not instant anymore
      string $selectedEdges[] = $selectedNodes;
      polySelectConstraint -m 3 -t 0x8000 -sm 1;  
      string $oldHardEdges[] = `ls -sl -fl`;
      polySelectConstraint -m 3 -t 0x8000 -sm 2;      
      string $oldSoftEdges[] = `ls -sl -fl`;
      polySelectConstraint -sm 0;
     // intersect lists to find selected hard or soft and the appropiate command to flip their value
      stringArrayIntersector -edit -intersect $selectedEdges $myIntersector;
      stringArrayIntersector -edit -intersect $oldHardEdges  $myIntersector;
      string $hardSelectedEdges[] = `stringArrayIntersector -query $myIntersector`;
      if (size($hardSelectedEdges) > 0)
        polySoftEdge -a 180 $hardSelectedEdges;  // make soft
      stringArrayIntersector -edit -reset $myIntersector;
      stringArrayIntersector -edit -intersect $selectedEdges $myIntersector;
      stringArrayIntersector -edit -intersect $oldSoftEdges  $myIntersector;
      string $softSelectedEdges[] = `stringArrayIntersector -query $myIntersector`;
      if (size($softSelectedEdges) > 0)
        polySoftEdge -a 0 $softSelectedEdges;  // make hard
      select -r $selectedEdges;  
      deleteUI $myIntersector;
      select -cl;
    }
    else 
    {
      setAltToggleEdgeOverlay(0); // sets toggle edge to regular intension - toggle Edge Hardness
      toggleEdgeOverlay(1);  // brings up toggle edge overlay if selected edge total is too high
    }
  }
}

global proc xSpinChoser ()
{// small procedure to determine if one or multiple edges are selected
 // it chooses the approapiate xSpin function
  int $edgeTotal[] = `polyEvaluate -ec`;
  if ($edgeTotal[0] > 1)
    xSpinEdge;
  else xSpinOneEdge;
}


global proc xSpinOneEdge ()
{// spin an edge - Optimized for spinning one edge only
  string $selectedEdges[] = `ls -sl`;
 // fliter expand selection to get one edge
  $selectedEdges = `filterExpand -sm 32 $selectedEdges`; 
 // grab shape name
  string $shapeBuffer[];
  tokenize($selectedEdges[0],".",$shapeBuffer);
  string $shapeName = $shapeBuffer[0];
  string $firstEdgeVertex; 
  string $secondEdgeVertex;
  string $sharedVertexList[];
 // grab the end point vertex info and the vertex info of the shared faces - then delete the edge
 // grab vertices of the curent edge
  string $vertexInfo[] = `polyInfo -ev $selectedEdges[0]`;
  string $vertexBuffer[];
 //string $currentEdgePoints[];
  tokenize($vertexInfo[0],$vertexBuffer);    
  $firstEdgeVertex = $shapeName + ".vtx[" + $vertexBuffer[2] + "]";    
  $secondEdgeVertex = $shapeName + ".vtx[" + $vertexBuffer[3] + "]";        
 // get shared faces 
  string $sharedFaces[] = `polyListComponentConversion -fe -tf $selectedEdges[0]`;
  $sharedFaces = `filterExpand -sm 34 $sharedFaces`;
 // testing for two faces, each being a quad or better 
  int $vertTotal[];
  int $faceTotal = 0;
  string $vertFaceTotal[];
  for ($sharedFace in $sharedFaces) // testing for two faces, each being a quad or better 
  {// calculating vertice totals per face and number of shared faces
    $vertFaceTotal = `polyListComponentConversion -ff -tv $sharedFace`;
    $vertFaceTotal = `filterExpand -sm 31 $vertFaceTotal`;
    $vertTotal[$faceTotal] = size($vertFaceTotal);
    $faceTotal ++;
  }
  if (($faceTotal==2) && ($vertTotal[0]>3) && ($vertTotal[1]>3)) // two quads or bigger
  {// get the values of vertices of shared faces
    string $sharedVertices[] = `polyListComponentConversion -ff -tv $sharedFaces`;  
    $sharedVertices = `filterExpand -sm 31 $sharedVertices`;
    polyDelEdge $selectedEdges[0];
   // calculate a new spin split edge for of the original selected edge
   // get value of remaining face
    string $sharedFaces[] = `polyListComponentConversion -fv -tf -in $sharedVertices`;
    string $remainingSharedFace = $sharedFaces[0];
   // get face ordered vertex list   
    string $vertexResults[] = `polyInfo -fv $remainingSharedFace`;
    int $vertexWords = tokenize($vertexResults[0],$vertexBuffer);
   // load results into a list 
    for ($index = 2; $index < $vertexWords; $index++)
      $sharedVertices[$index-2] = ($shapeName+".vtx["+$vertexBuffer[$index]+"]");   
   // find vertex number in list that matches old edge a get the next one in the list 
    string $newEdgeVertices[];
   // selecting new vertice for the edge's first end point 
    for ($index = 0; $index < size($sharedVertices); $index++)
      if (`strcmp $firstEdgeVertex $sharedVertices[$index]` == 0)
        if ($index == size($sharedVertices)-1)
          $newEdgeVertices[0] = $sharedVertices[0];
        else $newEdgeVertices[0] = $sharedVertices[$index+1];
   // selecting new vertice for the edge's second end point         
    for ($index = 0; $index < size($sharedVertices); $index++)
      if (`strcmp $secondEdgeVertex $sharedVertices[$index]` == 0)
        if ($index == size($sharedVertices)-1)
          $newEdgeVertices[1] = $sharedVertices[0];
        else $newEdgeVertices[1] = $sharedVertices[$index+1];        
   // determine new edge to split based the original edges end points and new edge vertices
    string $firstSplitEdge[] = `polyListComponentConversion -fv -te -in $firstEdgeVertex $newEdgeVertices[0]`;
    string $secondSplitEdge[] = `polyListComponentConversion -fv -te -in $secondEdgeVertex $newEdgeVertices[1]`; 
   // getting vertice order of common edge to determine -ep value for poly split
   // getting value for first edge
    string $vertexInfo[] = `polyInfo -ev $firstSplitEdge[0]`;
   // converting first point into vertex format
    tokenize($vertexInfo[0],$vertexBuffer);    
    $testVertex = $shapeName + ".vtx[" + $vertexBuffer[2] + "]"; 
   // calculating first edgepoint value 
    float $firstEdgePointValue;
    if ($newEdgeVertices[0] == $testVertex) // if first new vertice matches first test vertice then value is 0.0
      $firstEdgePointValue = 0.0;
    else $firstEdgePointValue = 1.0;  // else set to 1.0
   // getting value for second edge 
    $vertexInfo = `polyInfo -ev $secondSplitEdge[0]`;
   // converting second point into vertex format
    tokenize($vertexInfo[0],$vertexBuffer);
    $testVertex = $shapeName + ".vtx[" + $vertexBuffer[2] + "]";
   // calculating second edgepoint value 
    float $secondEdgePointValue;
    if ($newEdgeVertices[1] == $testVertex) // if second new vertice matches second test vertice then value is 0.0
      $secondEdgePointValue = 0.0;
    else $secondEdgePointValue = 1.0;  // else set to 1.0 
   // strip everything except edge number
    string $results[];
    tokenize ($firstSplitEdge[0],"[]",$results);
    string $firstEdgeNumber = $results[1]; 
    tokenize ($secondSplitEdge[0],"[]",$results);
    string $secondEdgeNumber = $results[1]; 
    string $splitCommand = "polySplit -ep " + $firstEdgeNumber + " " + $firstEdgePointValue + ".0 -ep " + $secondEdgeNumber + " " + $secondEdgePointValue + ".0 ";
    eval($splitCommand);
   // get value of new edge
    string $newEdgeResults[] = `polyListComponentConversion -fv -te -in $newEdgeVertices`;
   // selecting the new Edge(s)
    select -r $newEdgeResults[0];
  } // end of for splitting loop
}


global proc xSpinEdge ()
{// spin an edge - will work with multiple selections but could have unpredicatible results with neighboring edges
  string $selectedEdges[] = `ls -sl`;
 // fliter expand selection
  $selectedEdges = `filterExpand -sm 32 $selectedEdges`; 
 // grab shape name
  string $shapeBuffer[];
  tokenize($selectedEdges[0],".",$shapeBuffer);
  string $shapeName = $shapeBuffer[0];
  string $firstEdgeVertex[]; 
  string $secondEdgeVertex[];
  string $sharedVertexList[];
  string $vertexBuffer[];
  string $newEdgeList[];
  int $splitTotal = 0;
  string $deletedEdges[]; //used to keep track of the bad edges that cant be spun
  int $deletedTotal;
  for ($selectedEdge in $selectedEdges)
  { // for each edge grab the end point vertex info and the vertex info of the shared faces - then delete the edge
   // grab vertices of the curent edge
    string $vertexInfo[] = `polyInfo -ev $selectedEdge`;
    //string $currentEdgePoints[];
    tokenize($vertexInfo[0],$vertexBuffer);    
    $firstEdgeVertex[$splitTotal] = $shapeName + ".vtx[" + $vertexBuffer[2] + "]";    
    $secondEdgeVertex[$splitTotal] = $shapeName + ".vtx[" + $vertexBuffer[3] + "]";        
   // get shared faces 
    string $sharedFaces[] = `polyListComponentConversion -fe -tf $selectedEdge`;
    $sharedFaces = `filterExpand -sm 34 $sharedFaces`;
   // testing for two faces, each being a quad or better 
    int $vertTotal[];
    int $faceTotal = 0;
    string $vertFaceTotal[];
    for ($sharedFace in $sharedFaces) // testing for two faces, each being a quad or better 
    { // calculating vertice totals per face and number of shared faces
      $vertFaceTotal = `polyListComponentConversion -ff -tv $sharedFace`;
      $vertFaceTotal = `filterExpand -sm 31 $vertFaceTotal`;
      $vertTotal[$faceTotal] = size($vertFaceTotal);
      $faceTotal ++;
    }
    if (($faceTotal==2) && ($vertTotal[0]>3) && ($vertTotal[1]>3)) // two quads or bigger
    {// get the values of vertices of shared faces
      string $sharedVertices[] = `polyListComponentConversion -ff -tv $sharedFaces`;  
      $sharedVertices = `filterExpand -sm 31 $sharedVertices`;
     // compress the results into one index string 
      $sharedVertexList[$splitTotal] = stringArrayToString ($sharedVertices," ");
      $splitTotal++;
    }
    else // edge can't be spun so remove from list
    { 
      $deletedEdges[$deletedTotal] = $selectedEdge;
      $deletedTotal++;
    }
  } 
 // delete all valid edges at the same time 
  $selectedEdges = stringArrayRemove($deletedEdges,$selectedEdges);
  if ($splitTotal>0) polyDelEdge $selectedEdges; 
  for ($splitIndex = 0; $splitIndex < $splitTotal; $splitIndex++)
  { // work through the split list and calculate and a new split for of the original selected edges
   // uncompress string to work with shared vertices
      string $sharedVertices[] = stringToStringArray ($sharedVertexList[$splitIndex]," ");
   // get value of remaining face
    string $sharedFaces[] = `polyListComponentConversion -fv -tf -in $sharedVertices`;
    string $remainingSharedFace = $sharedFaces[0];
   // get face ordered vertex list   
    string $vertexResults[] = `polyInfo -fv $remainingSharedFace`;
    int $vertexWords = tokenize($vertexResults[0],$vertexBuffer);
   // load results into a list 
    for ($index = 2; $index < $vertexWords; $index++)
      $sharedVertices[$index-2] = ($shapeName+".vtx["+$vertexBuffer[$index]+"]");   
   // find vertex number in list that matches old edge a get the next one in the list 
    string $newEdgeVertices[];
   // selecting new vertice for the edge's first end point 
    for ($index = 0; $index < size($sharedVertices); $index++)
      if (`strcmp $firstEdgeVertex[$splitIndex] $sharedVertices[$index]` == 0)
        if ($index == size($sharedVertices)-1)
          $newEdgeVertices[0] = $sharedVertices[0];
        else $newEdgeVertices[0] = $sharedVertices[$index+1];
   // selecting new vertice for the edge's second end point         
    for ($index = 0; $index < size($sharedVertices); $index++)
      if (`strcmp $secondEdgeVertex[$splitIndex] $sharedVertices[$index]` == 0)
        if ($index == size($sharedVertices)-1)
          $newEdgeVertices[1] = $sharedVertices[0];
        else $newEdgeVertices[1] = $sharedVertices[$index+1];        
   // determine new edge to split based the original edges end points and new edge vertices
    string $firstSplitEdge[] = `polyListComponentConversion -fv -te -in $firstEdgeVertex[$splitIndex] $newEdgeVertices[0]`;
    string $secondSplitEdge[] = `polyListComponentConversion -fv -te -in $secondEdgeVertex[$splitIndex] $newEdgeVertices[1]`; 
   // getting vertice order of common edge to determine -ep value for poly split
   // getting value for first edge
    string $vertexInfo[] = `polyInfo -ev $firstSplitEdge[0]`;
   // converting first point into vertex format
    tokenize($vertexInfo[0],$vertexBuffer);    
    $testVertex = $shapeName + ".vtx[" + $vertexBuffer[2] + "]"; 
   // calculating first edgepoint value 
    float $firstEdgePointValue;
    if ($newEdgeVertices[0] == $testVertex) // if first new vertice matches first test vertice then value is 0.0
      $firstEdgePointValue = 0.0;
    else $firstEdgePointValue = 1.0;  // else set to 1.0
   // getting value for second edge 
    $vertexInfo = `polyInfo -ev $secondSplitEdge[0]`;
   // converting second point into vertex format
    tokenize($vertexInfo[0],$vertexBuffer);
    $testVertex = $shapeName + ".vtx[" + $vertexBuffer[2] + "]";
   // calculating second edgepoint value 
    float $secondEdgePointValue;
    if ($newEdgeVertices[1] == $testVertex) // if second new vertice matches second test vertice then value is 0.0
      $secondEdgePointValue = 0.0;
    else $secondEdgePointValue = 1.0;  // else set to 1.0 
   // strip everything except edge number
    string $results[];
    tokenize ($firstSplitEdge[0],"[]",$results);
    string $firstEdgeNumber = $results[1]; 
    tokenize ($secondSplitEdge[0],"[]",$results);
    string $secondEdgeNumber = $results[1]; 
    string $splitCommand = "polySplit -ep " + $firstEdgeNumber + " " + $firstEdgePointValue + ".0 -ep " + $secondEdgeNumber + " " + $secondEdgePointValue + ".0 ";
    eval($splitCommand);
   // get value of new edge
    string $newEdgeResults[] = `polyListComponentConversion -fv -te -in $newEdgeVertices`;
   // add edge to new edge list 
    $newEdgeList[$splitIndex] = $newEdgeResults[0];
  } // end of for splitting loop
 // selecting the new Edge(s)
  select -add $newEdgeList;
}


global proc selectZeroLengthEdges()
{//selects edges with zero length
  polySelectConstraint -m 3 -t 0x8000 -l 1 -lb 0.0 0.001; 
  polySelectConstraint -m 0 -l 0;
  selectMode -component; 
  selectType -allComponents 0 -e 1;
}


global proc selectUnMergedVerts()
{ //looks at entire mesh and selects vertices that have almost identical positions
  float $currentMergeDist = `optionVar -q polyMergeVertexDistance`;
  string $selectedVertices[] = `ls -sl -fl`;
  string $shapeBuffer[];
  tokenize($selectedVertices[0],".",$shapeBuffer);
  string $shapeName = $shapeBuffer[0];
  hilite $shapeName;
 //select all vertices 
  polySelectConstraint -m 3 -t 1;
  $selectedVertices = `ls -sl -fl`;
  if (size($selectedVertices)>1000) 
    print("This may take a second.\n");
  if (size($selectedVertices)>10000) 
    print("Actually, it may take more than a second.\n");    
  selectMode -component; 
  selectType -allComponents 0 -v 1;
  string $nonMergedVertices[];
  string $nonMergedVerticeString; 
  float $currentPosition[3];
  float $comparePosition[3];
  select -cl;
  for ($currentVertice in $selectedVertices)
  { // go through all selected vertices
    $currentPosition = pointPosition ($currentVertice);
    $poX = $currentPosition[0];
    $poY = $currentPosition[1];
    $poZ = $currentPosition[2];    
    polySelectConstraint -m 3 -t 1 -d 1 -db 0 $currentMergeDist -dp $poX $poY $poZ;
    $tempCount = `ls -sl -fl`;
    if (size($tempCount)>1)
    {
     //  converting additional vertices lists into strings for addition   
      string $currentResults[] = `ls -sl -fl`;
      string $currentResultsString = stringArrayToString($currentResults," ");
     // combining strings 
      $nonMergedVerticeString = $nonMergedVerticeString + " " + $currentResultsString;
    }
    select -cl;
  }
 // converting to string Array for clean up and display 
  $nonMergedVertices = stringToStringArray($nonMergedVerticeString," ");
 // cleaning out duplicates 
  $nonMergedVertices = stringArrayRemoveDuplicates($nonMergedVertices);
 //reseting PolyConstraints 
  polySelectConstraint -m 0 -t 1 -d 0;
  polySelectConstraint -m 0 -t 0;
 // display results if not empty 
  if ((size($nonMergedVertices)>0)&&(size($nonMergedVertices[0])>0))
    select -r $nonMergedVertices;
}


global proc saveXPrefs () 
{// writes or rewrites UI preference file
  global string $scriptPath;
  global int $hotkeysOn;
  global int $toolMessages;
  global int $brushScripts;
  global int $shelfSet;     // 0 = None , 1 = poly, 2 = nurb, 3 = General, 5 = all (old Default) - removed 3.9.6
  global int $shelfOn;  
  print ("Saving X-Tool Preferences.\n");
  string $prefFileName = ($scriptPath+"xTools_UserPrefs.mel");
  $fileId=`fopen $prefFileName "w"`;
  fprint $fileId "// X-Tools_UserPrefs.\n";
  fprint $fileId "// Generated by X-Tools3.\n";
  fprint $fileId "// Edit with care.\n";
  fprint $fileId "global proc xTools_UserPrefs ()\n";
  fprint $fileId "{\n";
  fprint $fileId ("global int $hotkeysOn = " + $hotkeysOn + "; // off by default.\n");
  fprint $fileId ("global int $toolMessages = " + $toolMessages + "; // off by default.\n");    
  fprint $fileId ("global int $brushScripts = " + $brushScripts + "; // off by default.\n");  
  fprint $fileId ("global int $shelfSet = " +$shelfSet + "; //  1 = poly, 2 = nurb, 3 = General \n");  
  fprint $fileId ("global int $shelfOn = " + $shelfOn + "; // off by default.\n");
  fprint $fileId "}\n";
  fprint $fileId "// XTools_UserPrefs Ends.\n";  
  fclose $fileId;
}

global proc drawJoint () 
{// adds a joint to a selected joint or starts a new chain
  string $selectedJoint[] = `ls -sl`;
  if ($selectedJoint[0]=="")
    JointTool;
  else
  {
    JointTool;
    select -r $selectedJoint[0];
  }
}


global proc addShader()
{
  createAndAssignShader blinn "";
}


global proc deleteUnusedShader()
{//deletes Unusued Shaders
  string $materialList[] = `ls -mat`;
  for ($shader in $materialList)
  {// find the shading group
    string $shadingGroup[] = `listConnections -t "shadingEngine" $shader`;
   // are there any tranform
    string $nodeConnections[] = `listConnections -d 0 $shadingGroup[0]`;
   // if ShadingGroup is only attached to its shader than it is unused
    if (size($nodeConnections)<2)
    {// delete shader and shaderGroup
      if (($shader!="lambert1")&&($shader!="particleCloud1"))
      delete $shader;
      delete $shadingGroup[0];     
    }   
  }
}


global proc addLight()
{
  CreateSpotLight;
}


global proc addParticle()
{
  CreateEmitter;
}


global proc addRigid()
{
  CreateActiveRigidBody;
}


global proc addNCloth()
{
  nClothCreate;
}


global proc addFur()
{
  HfCreateAndAssignHD 0;
}  
  

global proc addHair()
{
  CreateHair;
}

global proc addField()
{
  Gravity;
}  
  
 
global proc addUVMap()
{
  performPolyProjectionArgList "1" {"0", "Planar", "ls -selection", "0"} "";
}


global proc addFluid()
{
  Create2DContainerEmitter;
}


global proc uberPaintWeights()
{// activate the appropiate paint tool based the select type
  //bind geometry soft body nocloth fluid shape
  string $selectedShape[] = `ls -sl`;
  string $currentShape = $selectedShape[0];
  print ("a");
  if (nodeType ($currentShape) == "transform") 
  $shapeNode = `listRelatives -s $currentShape`;
  else $shapeNode[0] = $currentShape; 
    print ("b");
  string $currentNodeType = `nodeType $shapeNode[0]`;
    print ("c");
  switch ($currentNodeType)
  { 
    case "fluidShape":
      PaintFluidsToolOptions;
      break;
    case "mesh":
      print ("here");
      string $connectedNodes[] = `listConnections $shapeNode[0]`;
      print $connectedNodes;
      print (" we ");
      for ($currentNode in $connectedNodes)
      { 
        string $shapeTest[] = `listRelatives -s $currentNode`;  
        print $shapeTest;
        if ($shapeTest[0]!="")
        {
          string $nodeType2 = `nodeType $shapeTest[0]`;
          switch ($nodeType2)
          {
            case "nCloth":
              setNClothMapType("thickness","",1); 
              artAttrNClothToolScript 4 thickness;
              break;
            case "particle":
              artAttrToolScript 3 "particle";
              break;
            case "skinCluster":
              ArtPaintSkinWeightsToolOptions;  
              break;
          }
        }
      }
      break;       
    default:
      print ("Incorrect type for a Paint Tool\n");
      break;
  }  
}
