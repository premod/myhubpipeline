/*
abAutoRig.mel 2.8
brendan ross 04.14.2007
www.supercrumbly.com

use:

A simple skeleton builder and autorigger.

directions:

See website for now

updates:

v. 1.1 -- HeelLocs axes, and therefore foot Ik control curves, are now properly aligned.
v. 1.2 -- Went back to my previous way of doing stretch on arms and legs that I think is more flexible.  Fk stretch is no longer limited by the ik maxStretch attribute.  Exposed stretch value on arms and legs.
v. 1.21 -- Exposed stretch value for spine on cog ctrl.
v. 1.22 -- Ikhandle fix.
v. 1.23 -- Fk to Ik snap now fully implemented on legs.  Stretch value now displays the correct value when used on an arm or leg with split joints.
v. 1.3 -- Added optional ik fingers to hand rig.  Space switching on mirrored controls now works properly (leg and arm IK, hand).  PV controls will now follow their ik curves when their space is set as such.  Updated Fk to Ik snap to work when a character's rig group has been regrouped or moved in the scene hierarchy.  Fk/ik snap also now supports references via the namespace optionMenu and works with previously built characters.
v. 1.4 -- Split joints now work properly.  Master control can be rotated without any problems.  Added split joint rotation ratios to spineSplit ctrl (the visibility of which is now located on the root ctrl).  Fixed the way scale is determined so pv control wires will now mirror properly.  Added popup to select target object when wire mirroring encounters multiple mirror objects.
v. 1.4.1 -- Made a small change to the way finger IK ctrls are scaled.
v. 1.5 -- Weight spine joints now rotate correctly with rootCon rotations.  Thanks to Josh Yoder for finding this.
v. 1.6 -- Under "Tools" menu added "Save Wires to Shelf" (with its own icon) and "Rig Remover", both of which should make for easier updates.  IK and PV controls are now aligned along the world axes.  Improved default rotation order on control curves.  Script will now attempt to repopulate UI fields (hidden and non) automatically, which, among other things, means that parts of the rig can be added after the UI has been closed and opened again without a problem.  Added scale slider and four new shapes (tweaked others) to ReplaceWire UI.  Improved error handling (the script now checks for an existing rig upon creation).  Slight improvements to the default skeleton.  Killed a few bugs.
v. 1.7 -- Fixed the hand IK rotation problem by adding "Align Hand IK to World Axes" checkbox to the Arm tab.  Leaving the checkbox blank will align the IK control to the wrist joint and allow it to rotate the hand.  Enabling it will freeze the control's transforms and lock and hide the rotation channels.  Modified default LRA alignment on arm, wrist and hand joints to make IK control a bit more intuitive.  IK finger rig now blends properly between FK and IK.  Added curl attributes for each finger as well as midCurlAmt and tipCurlAmt, which determine how much the respective joints will rotate relative to the base joint when using masterFist and fingerCurl attributes.  Added masterSpread to hands and individual finger spreadAmount attributes to spineCtrlCrv to specify the amount each finger is affected by masterSpread.  Wire replacer should now work more reliably overall.  Adjusted the object centers of curves which should eliminate drifting when replacing wires.  Replaced wire scale slider with a float field, which can be control-LMB MMB or RMB dragged on to interactively scale the selected wire.  Creating wires along the -z axis now works as expected.  UI field auto fill is now more comprehensive (be aware that it fills mirrorable object fields (upArm, upLeg, the hand fields etc) with the left objects by default).  Added the ability to rig mirror limbs at the same time (The options menu finally has a child).  Lot's of other small stuff.
v. 1.7.5 -- Added ability to select hand joint rotation axes under Options > Hand Options
v. 1.8 -- Added "Stretchy Spline From Curve" to tools menu to make quick and dirty IK spline joint chains.  The knees once again stretch as they should (oops).  UI field auto fill now includes the number of split joints.
v. 1.8.1 -- Added individual up and low limb stretch attributes to legs and arms (works with limbStretch on foot and wrist controls).
v. 1.8.2 -- Added rigScale to the stretchy spine.
v. 1.8.3 -- Less flipping when sliding IK/FK blend on leg and arm joints.  They'll still flip occassionally when the root ctrl has lots of rotations, but only when the IK and FK limbs are in matching positions and the ikFkBlend is between 0 and 1.  It shouldn't be a problem.
v. 1.9 -- Rig is now scaleable.  Added true IK to spine controls (enable "useRootSpace" attribute on the control curve).  Added translate control to the head, which can also be used in IK mode (enable "ikCtrlVis" on head ctrl to see the control).  Added utility to match ctrl positions across space switches ("Space Switch Matcher" in tools menu).  Added snapIKtoFK and hugely improved SnapFKtoIk (both can be found in the character shelf button).  Unfortunately, older snapFKtoIK buttons won't work anymore, which is not a huge problem because it wasn't really working that well anyway.  FK controls with align attribute now auto align with the root ctrl (<- this is awesome for those of us who love the align att).  Rig Remover will now work with multiple characters in a scene.  Improved stretchy splines (made with "makeStretchySpline") scaling.  Removed World space from space switch options as it was pointless.  Disabling all of the spaces does the same thing.  Fixed spine stretch value.
v. 1.9.1 -- Very small fix.  IK/FK snap button now works when rig_grp position has changed in the rig hierarchy (placed in a new group).  To fix a button made with 1.9, just copy the button command into a text editor and replace ">|" with ">" and "&|" with "&".  Replace your current command (of the IK/FK snapping shelf button) with the modified version and you should be good to go.
v. 1.9.3 -- Weight Spine joints are now created in the skeleton grp.  They won't be deleted when you remove the rig, so you won't have to reattach and weight them when you update the rig.  Added "Reset Character to Default Pose" (which can be also be called with "abRTResetCharPose(1)") and "Reset Selected Control Curves to Default" (call with "abRTResetCharPose(0)") to Tools menu.  Added ability to lock proxy controls to prevent troublesome translations and rotations.  Added a warning when building the skeleton about snap to PV not working under certain conditions.
v. 1.9.4 -- The script now supports feet that have been rotated out of the YZ plane.  When building your skeleton, match the foot locators (ankle, ball, and toe) to your mesh by moving them in their local YZ planes (no X) and rotating the "lf_foot_grpLoc" in Y.  If you want to use an existing skeleton you'll have to orient the ankle and ball joints first.  To do so, select left and right ankle and ball joints and run "joint -e -orientJoint xyz -sao ydown;" in the command line.
v. 1.9.5 -- Skeletons on layers can now be rigged.  IK and FK joints won't be colored, though, so you're better off keeping it off of a layer until the rig has been created.  Added a spine_end group control to the proxy skeleton.
v. 2.0 -- The skeleton created by skeleton builder is now mirrored in behavior instead of orientation (except for the eyes and, optionally, the legs).  I had to update hand rigging (among other things) to accomodate the change, so I've added a new a menu item (Options > Hand Options > Reverse Right Curl) which should be enabled when rigging skeletons created with earlier (pre 2.0) versions of the script.  Added "Mirror Leg Behavior" menu item to the skeletonMaker UI (enabled by default).  Disable it to mirror the leg joints by orientation.
v. 2.0.1 -- Arm IK controls are aligned properly (again).  Changed the way "Align Hand IK to World Axes" works.
v. 2.0.2 -- The UI autofill feature was missing some important hidden fields which kept certain spaces (like handCtrl for finger IK controls) from being created.  Now that it's fixed, the finger IK curves travel with the hand as they should (they're constrained to handCtrl space by default).  I also add the option to skeletonMaker to specify the number of fingers on the proxy.  Note that if you recall a saved skeleton from a shelf button, it will respect the current finger num value if the skeletonMaker UI is open.  Neck and head joints are now aligned so their control curves rotate the same way as the spine curves.
v. 2.1 -- Proxies saved to the shelf now have local transforms preserved (including scale on the rootLoc).  Feet rotated out of Z should now rig correctly when there are Y rotations on the leg_grpLoc.
v. 2.1.1 -- Fixed a bug with weightSpineGrp that prevented multiple character spines from being created in the same scene.
v. 2.2 -- Added Joint Orient Rotation Tool to Tools menu.
v. 2.2.1 -- Improved skeletonBuilder's orientation of joints in legs and feet when the limb has been rotated in Z.
v. 2.2.2 -- Added tool to add weight joints to a skeleton (useful for the lower leg), Tools > Add Weight Joint Tool.  Removed snap to PV warning for legs (they work when rotated -- the arms still don't).
v. 2.2.3 -- Leg split joints now rotate properly when the knee is brought above the waist.
v. 2.2.4 -- Fixed rt_thumb_grpLoc default skeleton proxy positioning.
v. 2.2.5 -- Added djx's fix to GroupFreeze procs.  Character name must now be unique before a proxy can be skeletonized.
v. 2.3 -- Changed min value on armStretch and legStretch attributes to -9.9 (arms and legs can now stretch negatively).  Improved default finger joint LRA orientation.
v. 2.4 -- Added "Align Control Curves to Spine" button on the Spine tab.  If enabled the mid and high spine controls will align to their respective joints; otherwise they'll lie on the XZ plane (the previous default).
v. 2.5 -- rt_thumb_a_loc is now properly parented in proxy (to rt_thumb_grpLoc).  Added "Quick Create Character Set" to tools menu.  Select a control curve on your rig and then run it.
v. 2.6 -- Added "Change Rotation Order Tool" to tools menu.  It will change the rotation order on the selected curves and maintain their orientation.  It won't work on transforms with incoming connections on any of the rotation channels.
v. 2.7 -- Simplified the spine.  It should be a lot less flippy now.  Note that although the spineRot control curve no longer holds spine twist attributes, it's still used as an attribute holder for the arm, leg and hand setups (so don't delete it).
v. 2.7.1 -- Fixed an issue with IK/FK arm snapping.
v. 2.7.2 -- Soft selection is now disabled before creating a rig.  It can cause an issue on 2009 and up (thanks bm jo).
v. 2.8 -- Fixed issue with limbs flipping when sliding IKFKBlend attribute values (finally!!)

*/


global proc abRTInit(){
	// inits globals
	
	global int $abRTInit;
	
	abRTGlobals();
	$abRTInit = true;
}


global proc string[] abRTGetHierarchy(string $startJnt, string $endJnt, int $retEmptyOnFork){
	/*
	returns all joints in direct hierarchy (including startJnt and endJnt)
	leave $endJnt as "" to crawl return jnts all the way to the bottom of the hierarchy
	if there are downward facing forks or if the joints aren't connected, an empty array will be returned, unless $retEmptyOnFork is false.
	*/
	
	$startJnt = longNameOf($startJnt);
	$endJnt = longNameOf($endJnt);
	
	string $aAllRel[] = `listRelatives -ad -type joint -fullPath $startJnt`;
	string $aRel[], $aRet[], $jnt, $aStr[];
	int $i;
	
	$jnt = $startJnt;
	$aRet = {$jnt};
	
	for ($i=0;$i<size($aAllRel);$i++){
		$aRel = `listRelatives -c -type joint -fullPath $jnt`;
		if (size($aRel) == 1){
			$jnt = $aRel[0];
			$aRet[size($aRet)] = $jnt;
			if ($endJnt != "" && $jnt == $endJnt){
				// we found our joint
				break;
			}else{
				continue;
			}
		}else if (size($aRel) > 1){
			// downward fork
			if ($retEmptyOnFork) clear $aRet;
			break;
		}else{
			// no children -- we made it to the end
			break;
		}
	}
	
	return $aRet;
}


global proc abRTQuickGroupFreeze(){
	// select target object followed by object to snap to -- no constraints will be created
	
	string $obj;
	string $aSel[] = `ls -sl -type transform`;
	for ($obj in $aSel) abRTGroupFreeze($obj, 1);
	
}


global proc abRTPointConnect(string $target, string $follower, int $type){
	/*
	creates something like a point constraint by connecting translation attribtutes of $follower to $target
	$type is x=1 y=2 z=4 -- add them together to specify which atts you want connected xy would be 3, zx would be 5, etc
	*/
	
	if (($type % 2) == 1 && !(`isConnected ($target+".tx") ($follower+".tx")`)) connectAttr ($target+".tx") ($follower+".tx");
	if ($type != 4 && $type != 5 && $type != 1 && !(`isConnected ($target+".ty") ($follower+".ty")`)) connectAttr ($target+".ty") ($follower+".ty");
	if ($type >= 4 && !(`isConnected ($target+".tz") ($follower+".tz")`)) connectAttr ($target+".tz") ($follower+".tz");
}


global proc abRTOrientConnect(string $target, string $follower, int $type){
	/*
	creates something like an orient constraint by connecting translation attribtutes of $follower to $target
	$type is x=1 y=2 z=4 -- add them together to specify which atts you want connected xy would be 3, zx would be 5, etc
	*/
	
	if (($type % 2) == 1 && !(`isConnected ($target+".rx") ($follower+".rx")`)) connectAttr ($target+".rx") ($follower+".rx");
	if ($type != 4 && $type != 5 && $type != 1 && !(`isConnected ($target+".ry") ($follower+".ry")`)) connectAttr ($target+".ry") ($follower+".ry");
	if ($type >= 4 && !(`isConnected ($target+".rz") ($follower+".rz")`)) connectAttr ($target+".rz") ($follower+".rz");
}


global proc abRTQuickLine(){
	// select two transforms, call this proc, and a line is created from the first selected to the second
	
	string $aSel[] = `ls -sl -type transform`;
	if (size($aSel) == 2) abRTConnectWithLine($aSel[0], $aSel[1]);
	
}


global proc string abRTGroupFreeze(string $obj, int $delete){
	/*
	parents $obj under a group snapped and oriented to its position to zero out transforms
	delete: 0 -- keep created constraints
	delete: 1 -- delete both constraints
	delete: 2 -- keep point constraint
	delete: 3 -- keep orient constraint
	returns name of created null
	*/
	
	string $gpName = "|"+(`group -em -name (abRTStripPath($obj)+"_frzGrp")`);
	select -r $obj $gpName;
	abRTPointOrient($delete);
	select -clear;
	string $aRel[] = `listRelatives -p -fullPath -type transform $obj`;
	if (size($aRel) > 0) $gpName = abRTParent($gpName, $aRel[0]);
	parent $obj $gpName;
	
	return $gpName;
}


global proc string abRTGroupFreezeReturnObj(string $obj, int $delete){
	/*
	same function as above, but returns new obj path
	*/
	
	string $gpName = "|"+(`group -em -name (abRTStripPath($obj)+"_frzGrp")`);
	select -r $obj $gpName;
	abRTPointOrient($delete);
	select -clear;
	string $aRel[] = `listRelatives -p -fullPath -type transform $obj`;
	if (size($aRel) > 0) $gpName = abRTParent($gpName, $aRel[0]);
	$obj = abRTParent($obj, $gpName);
	
	return $obj;
}


global proc abRTPointOrient(int $delete){
	/*
	delete: 0 -- keep created constraints
	delete: 1 -- delete both constraints
	delete: 2 -- keep point constraint
	delete: 3 -- keep orient constraint
	*/
	
	string $aPointCons[], $aOrientCons[], $pointCons, $orientCons;
	
	$aPointCons = `pointConstraint -offset 0 0 0 -weight 1`;
	if ($delete == 1 || $delete == 3) for ($pointCons in $aPointCons) delete $pointCons;
	$aOrientCons = `orientConstraint -offset 0 0 0 -weight 1`;
	if ($delete || $delete == 2) for ($orientCons in $aOrientCons) delete $orientCons;
}


global proc abRTConnectMirrorTrans(string $obj1, string $obj2, int $axis){
	// connects $obj1 and $obj2 translation on $axis axis to mirror across the origin ($axis: 0,1,2 = x,y,z)
	
	string $aAxisStr[] = {"x", "y", "z"};
	string $axisStr = ".t"+$aAxisStr[$axis];
	
	string $revNode = `createNode plusMinusAverage -n "abRTMirrorTransPlsMns"`;
	setAttr ($revNode+".operation") 2;
	setAttr ($revNode+".input1D[0]") 0;
	connectAttr -f ($obj1+$axisStr) ($revNode+".input1D[1]");
	connectAttr -f ($revNode+".output1D") ($obj2+$axisStr);
	
}


global proc abRTConnectMirrorRot(string $obj1, string $obj2, int $axis){
	// connects $obj1 and $obj2 translation on $axis axis to mirror across the origin ($axis: 0,1,2 = x,y,z)
	
	string $aAxisStr[] = {"x", "y", "z"};
	string $axisStr = ".r"+$aAxisStr[$axis];
	
	string $revNode = `createNode plusMinusAverage -n "abRTMirrorRotPlsMns"`;
	setAttr ($revNode+".operation") 2;
	setAttr ($revNode+".input1D[0]") 0;
	connectAttr -f ($obj1+$axisStr) ($revNode+".input1D[1]");
	connectAttr -f ($revNode+".output1D") ($obj2+$axisStr);
	
}


global proc string abRTStripPath(string $obj){
	// returns basename of a transform without path
	
	string $aName[], $name;
	$aName = stringToStringArray($obj, "|");
	return ($aName[size($aName)-1]);
}


global proc string abRTStripRoot(string $obj){
	// returns basename of a transform without initial "|"
	
	if (startsWith($obj, "|")) $obj = `substring $obj 2 (size($obj))`;
	return $obj;
}


global proc string abRTConnectWithLine(string $obj1, string $obj2){
	// connects two transforms with a line
	
	// unparent children
	string $aObj2Children[], $aObj2UpChildren[], $lineShape, $aStr[], $aRel[], $obj2Parent, $origName, $origPath, $tObjPath, $taChildrenPath[], $tGrp, $tGrp2;
	$aObj2Children = `listRelatives -children -type transform -fullPath $obj2`;
	if (size($aObj2Children) > 0) $aObj2UpChildren = `parent -w $aObj2Children`;
	// done
	
	string $lineName;
	float $xForm[], $aCenter1[];
	
	string $annLoc = abRTMakeLocator(((abRTStripPath($obj2))+"_annLoc"));
	pointConstraint $obj2 $annLoc;
	setAttr ($annLoc+".v") 0;
	$lineShape = `annotate -tx "" $annLoc`;
	parent $annLoc $obj2;
	
	$aStr = `listRelatives -p -type transform $lineShape`;
	if (size($aStr) == 1) $lineName = $aStr[0];
	
	// problem when obj2 has been frozen
	
	parent $lineName $obj1;
	
	select -r $obj1 $lineName;
	abRTPointOrient(1);
	select -clear;
	
	setAttr ($lineShape+".overrideEnabled") 1;
	setAttr ($lineShape+".overrideDisplayType") 2;
	
	// reparent children
	if (size($aObj2Children) > 0){
		int $i;
		$aObj2UpChildren = `parent $aObj2UpChildren $obj2`;
		
		for ($i=0;$i<size($aObj2UpChildren);$i++){
			$origName = abRTStripPath($aObj2Children[$i]);
			if ($aObj2UpChildren[$i] != $origName) rename $aObj2UpChildren[$i] $origName;
		}
	}
	// done
	
	select -clear;
	
	$lineName = `rename $lineName ("abRTLine_"+abRTStripPath($obj1))`;
	return $lineName;
}


global proc abRTOutputLocStructure(string $rootLoc){
	
	string $aLoc[] = abRTEncodeLocStructure($rootLoc);
	string $locStr = stringArrayToString($aLoc, "\",\"");
	$locStr = "{\""+$locStr+"\"}";
	
	print $locStr;
	
}


global proc string[] abRTEncodeLocStructure(string $rootLoc){
	/*
	given the root loc of a proxy rig (under which all others are parented) this will arrange the locs in an array that can be used to 
	rebuild the hierarchy.
	return string form is {locator1Name, locator1Parent, locator2Name, locator2Parent} -- if parent is $rootLoc, locatorParent will be represented with "*"
	string will be returned in order so that parents of locators are created before their children, so, if you create locs starting with the 
	beginning of the array, you'll never parent a loc to a nonexistent node
	returns (locName, locParent, locTransString("tx|ty|tz&rx|ry|rz&sx|sy|sz"), frozen(bool))
	as of v 2.1 of the script, the return string also includes the current offsets tacked on to the end of the locTransString, so it now looks like "tx|ty|tz&rx|ry|rz&sx|sy|sz|cbTx|cbTy|cbTz&cbRx|cbRy|cbRz&cbSx|cbSy|cbSz" where "cb" prefix stands for the channelBox value of an attribute (not the ws value)
	*/
	
	string $aRet[];
	
	if (`objExists $rootLoc`){
		
		string $aChildren[], $aParents[], $aRel[], $objPath, $objName, $parent, $baseName;
		string $aTempSort[]; // used to sort locs by the depth of their path
		
		string $aSel[] = `listRelatives -allDescendents -fullPath -type transform $rootLoc`;
		
		for ($objPath in $aSel){
			if (endsWith($objPath, "_loc") || endsWith($objPath, "_grpLoc")){
				$baseName = abRTStripPath($objPath);
				if (!startsWith($baseName, "abRTLine_")) $aChildren[size($aChildren)] = $objPath;
			}
		}
		
		// sort locs by the depth of their path
		for ($objPath in $aChildren){
			// ignore line related transforms
			$objName = abRTStripPath($objPath);
			
			// size of $aParents will never be smaller than 2
			$aParents = stringToStringArray($objPath, "|");
			$parent = $aParents[size($aParents)-2];
			if ($parent == $rootLoc) $parent = "*";
			
			$aTempSort[size($aTempSort)] = $objPath;
			$aTempSort[size($aTempSort)] = $objName;
			$aTempSort[size($aTempSort)] = $parent;
			$aTempSort[size($aTempSort)] = size($aParents) - 2;
		}
		
		string $aTemp[], $locTransStr, $locColorIndex, $aRel[], $shape, $varType, $aRestoreTransTable[], $aLockedAtts[], $aConnectedAtts[], $att, $objAttStr, $attSfd;
		int $i, $depth, $cDepth;
		int $aOverride[];
		float $aTrans[], $aRot[], $aScale[], $aCbTrans[], $aCbRot[], $aCbScale[];
		string $aLockCheckAtts[] = {"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
		string $aConnectedCheckAtts[] = {"tx","ty","tz","rx","ry","rz","s"};
		$cDepth = 0;
		
		// save rootLoc transform atts
		float $aRootLocScale[] = `getAttr ($rootLoc+".s")`;
		setAttr ($rootLoc+".s") 1 1 1;
		
		$aRet[size($aRet)] = $rootLoc;
		$aRet[size($aRet)] = "0";
		$aRet[size($aRet)] = "0|0|0&0|0|0&1|1|1&0|0|0&0|0|0&"+$aRootLocScale[0]+"|"+$aRootLocScale[1]+"|"+$aRootLocScale[2];
		$aRet[size($aRet)] = "1";
		
		// have to disconnect all connected objs first, otherwise resetting the positive x t, r, and s attributes will similarly affect the connected objs
		for ($i=0;$i<size($aTempSort);$i+=4){
			
			$objPath = $aTempSort[$i];
			
			// disconnect conected atts and save them to reconnect when save is complete
			for ($att in $aConnectedCheckAtts){
				$objAttStr = $objPath+"."+$att;
				
				// check for connected attributes
				$attSfd = `connectionInfo -sourceFromDestination $objAttStr`;
				if ($attSfd != ""){
					$aConnectedAtts[size($aConnectedAtts)] = $attSfd+">"+$objAttStr;
					disconnectAttr $attSfd $objAttStr;
				}
			}
		}
		// done
		
		string $tLoc = abRTMakeLocator("abRTEncodeStructureLoc");
		
		while (size($aTempSort) > 0){
			
			clear($aTemp);
			
			for ($i=0;$i<size($aTempSort);$i+=4){
				
				$objPath = $aTempSort[$i];
				$objName = $aTempSort[$i+1];
				$parent = $aTempSort[$i+2];
				$depth = $aTempSort[$i+3];
				
				if ($depth == $cDepth){
					
					$aRel = `listRelatives -type shape $objPath`;
					$shape = (size($aRel) > 0) ? $aRel[0] : "";
					
					// set the $obj channelBox trans, rot, and scale atts back to 0 and save those values as offsets (so when skeleton is recalled its local t, r, and s values are preserved)
					$aCbTrans = `getAttr ($objPath+".t")`;
					$aCbRot = `getAttr ($objPath+".r")`;
					$aCbScale = `getAttr ($objPath+".s")`;
					
					// save cb atts to restore once proxy has been saved ("objPath&tx|ty|tz&rx|ry|rz&sx|sy|sz"
					$aRestoreTransTable[size($aRestoreTransTable)] = $objPath+"&"+$aCbTrans[0]+"|"+$aCbTrans[1]+"|"+$aCbTrans[2]+"&"+$aCbRot[0]+"|"+$aCbRot[1]+"|"+$aCbRot[2]+"&"+$aCbScale[0]+"|"+$aCbScale[1]+"|"+$aCbScale[2];
					
					// unlock locked attributes and save them to lock again once save is complete
					for ($att in $aLockCheckAtts){
						$objAttStr = $objPath+"."+$att;
						
						// check for locked attributes
						if (`getAttr -lock $objAttStr`){
							$aLockedAtts[size($aLockedAtts)] = $objAttStr;
							setAttr -lock false $objAttStr;
						}
					}
					
					// set atts to default
					setAttr ($objPath+".t") 0 0 0;
					setAttr ($objPath+".r") 0 0 0;
					setAttr ($objPath+".s") 1 1 1;
					
					// make loc trans string
					select -r $objPath $tLoc;
					abRTPointOrient(1);
					select -clear;
					
					// now get the absolute values
					$aTrans = `xform -q -ws -t $tLoc`;
					$aRot = `xform -q -os -ro $tLoc`;
					$aScale = `xform -q -r -s $objPath`;
					
					$locTransStr = $aTrans[0]+"|"+$aTrans[1]+"|"+$aTrans[2]+"&"+$aRot[0]+"|"+$aRot[1]+"|"+$aRot[2]+"&"+$aScale[0]+"|"+$aScale[1]+"|"+$aScale[2]+"&"+$aCbTrans[0]+"|"+$aCbTrans[1]+"|"+$aCbTrans[2]+"&"+$aCbRot[0]+"|"+$aCbRot[1]+"|"+$aCbRot[2]+"&"+$aCbScale[0]+"|"+$aCbScale[1]+"|"+$aCbScale[2];
					
					$aRet[size($aRet)] = $objName;
					$aRet[size($aRet)] = $parent;
					$aRet[size($aRet)] = $locTransStr;
					$aRet[size($aRet)] = "1";
					
				}else{
					$aTemp[size($aTemp)] = $objPath;
					$aTemp[size($aTemp)] = $objName;
					$aTemp[size($aTemp)] = $parent;
					$aTemp[size($aTemp)] = $depth;
				}
			}
			$aTempSort = $aTemp;
			$cDepth++;
		}
		
		delete $tLoc;
		
		// restore channelBox attribute values		
		string $data, $aData[], $aTransData[], $aRotData[], $aScaleData[];
		for ($data in $aRestoreTransTable){
			
			$aData = stringToStringArray($data, "&");
			
			$objPath = $aData[0];
			
			// retrieve cb values
			$aTransData = stringToStringArray($aData[1], "|");
			$aRotData = stringToStringArray($aData[2], "|");
			$aScaleData = stringToStringArray($aData[3], "|");
			
			// restore cb values
			setAttr ($objPath+".t") (float($aTransData[0])) (float($aTransData[1])) (float($aTransData[2]));
			setAttr ($objPath+".r") (float($aRotData[0])) (float($aRotData[1])) (float($aRotData[2]));
			setAttr ($objPath+".s") (float($aScaleData[0])) (float($aScaleData[1])) (float($aScaleData[2]));
			
		}
		
		// relock previously locked atts
		for ($att in $aLockedAtts) setAttr -lock true $att;
		
		// reconnected previously connected atts
		for ($data in $aConnectedAtts){
			$aData = stringToStringArray($data, ">");
			connectAttr $aData[0] $aData[1];
		}
		
		// reset rootLoc scale att
		setAttr ($rootLoc+".s") $aRootLocScale[0] $aRootLocScale[1] $aRootLocScale[2];
		
	}
	
	return $aRet;
	
}


global proc string abRTRecallLocStructure(string $aData[]){
	// recalls a given loc structure ($aData which is created by abRTEncodeLocStructure)
	// returns rootLoc
	
	string $objName, $parent, $locTransStr, $locColorIndex, $aStr[], $aSubStr[], $loc, $aRel[], $ret, $baseName, $aRestoreAttTable[], $restoreAttData;
	float $aTrans[], $aRot[], $aScale[];
	int $i, $frozen, $colorInd;
	
	int $rootLocColorInd = 13;
	int $grpLocColorInd = 13;
	int $locColorInd = 15;
	
	// need to offset scale for wire controller proc -- which bases size relative to global scale
	float $so;
	float $gScale = float(abRTGetGlobal("globalScale"));
	if ($gScale == 0) $so = 1;
	else $so = 1/$gScale;
	
	string $rootLocName = "skeleton_proxy_grpLoc";
	
	if (`objExists $rootLocName`) delete $rootLocName;
	string $rootLoc = abRTMakeLocator($rootLocName);
	
	abRTHideAttr($rootLoc, {"tx","ty","tz","rx","ry","rz","v"});
	
	$aRel = `listRelatives -type shape $rootLoc`;
	
	setAttr ($aRel[0]+".overrideEnabled") true;
	setAttr ($aRel[0]+".overrideColor") $rootLocColorInd;
	
	string $aXAxisUpCircleJnts[] = {"lf_upArm_loc","lf_elbow_loc","lf_wrist_loc","rt_upArm_loc","rt_elbow_loc","rt_wrist_loc"};
	float $aXAxisLocSize[] = {6,5,4,6,5,4};
	string $aYAxisUpCircleJnts[] = {"hip_loc","spine_low_loc","spine_mid_loc","spine_hi_loc","lf_upLeg_loc","lf_knee_loc","lf_ankle_loc","rt_upLeg_loc","rt_knee_loc","rt_ankle_loc","neck_loc","head_a_loc"};
	float $aYAxisLocSize[] = {14,16,17,18,10,7,6,10,7,6,8,12};
	string $aZAxisUpCircleJnts[] = {"lf_ball_loc","rt_ball_loc"};
	float $aZAxisLocSize[] = {4,4};
	int $axisUpIndex;
	float $wireScale, $aRootLocScale[];
	float $locScale = float(abRTGetGlobal("proxyLocScale"));
	
	int $fingerNum = (`window -q -exists abRTSklMkrWin`) ? `intSliderGrp -q -v abRTSklMkrFingerNumIntSldrGrp` : 5;
	int $delRingCup = false;
	int $delPinkyCup = false;
	string $aFingersToDelete[];
	switch ($fingerNum){
		case 2: $aFingersToDelete = {"middle", "ring", "pinky"}; $delRingCup = $delPinkyCup = true; break;
		case 3: $aFingersToDelete = {"middle", "ring"}; $delRingCup = true; break;
		case 4: $aFingersToDelete = {"ring"}; $delRingCup = true; break;
	}
	
	// check first four items in $aData contain info about rootLoc scale (only in saves made with versions 2.1 and up) -- if it does it needs to be removed from $aData
	if (size($aData) > 4){
		if ($aData[1] == "0"){
			
			// yep, this is a post 2.1 save -- get the scale info and remove these first four items from $aData
			$aStr = stringToStringArray($aData[2], "&");
			$aSubStr = stringToStringArray($aStr[5], "|");
			$aRootLocScale = {float($aSubStr[0]), float($aSubStr[1]), float($aSubStr[2])};
			
			// now remove first four items (rootLoc info) from $aData
			clear($aStr);
			for ($i=0;$i<size($aData);$i+=4){
				if ($i > 0){
					$aStr[size($aStr)] = $aData[$i];
					$aStr[size($aStr)] = $aData[$i+1];
					$aStr[size($aStr)] = $aData[$i+2];
					$aStr[size($aStr)] = $aData[$i+3];
				}
			}
			
			$aData = $aStr;
		}
	}
	
	
	for ($i=0;$i<size($aData);$i+=4){
		
		$objName = $aData[$i];
		$parent = $aData[$i+1];
		$locTransStr = $aData[$i+2];
		$frozen = int($aData[$i+3]);
		
		// get baseName
		$aStr = stringToStringArray($objName, "_");
		if (size($aStr) == 3) $baseName = $aStr[1];
		else $baseName = "";
		
		if ($parent == "*") $parent = $rootLoc;
		
		if (!objExists($parent)) continue;
		
		if ($delRingCup && $baseName == "ringCup") continue;
		if ($delPinkyCup && $baseName == "pinkyCup") continue;
		
		if (endsWith($objName, "_grpLoc")){
			
			// need to compare baseName of current obj with items in $aFingersToDelete -- if this finger is in $aFingersToDelete then skip it
			if (size($aFingersToDelete) > 0) if (abRTGetPosInStrArray($baseName, $aFingersToDelete) != -1) continue;
			
			$loc = abRTWireContoller("sphere", 1, {}, 1.5*$so, false);
			$aStr = abRTRename($loc, $objName);
			$loc = $aStr[1];
		}else if (abRTGetPosInStrArray($objName, $aYAxisUpCircleJnts) != -1){
			$axisUpIndex = abRTGetPosInStrArray($objName, $aYAxisUpCircleJnts);
			$wireScale = $aYAxisLocSize[$axisUpIndex];
			$loc = abRTWireContoller("circle", 1, {}, $wireScale*$so, false);
			$aStr = abRTRename($loc, $objName);
			$loc = $aStr[1];
		}else if (abRTGetPosInStrArray($objName, $aXAxisUpCircleJnts) != -1){
			$axisUpIndex = abRTGetPosInStrArray($objName, $aXAxisUpCircleJnts);
			$wireScale = $aXAxisLocSize[$axisUpIndex];
			$loc = abRTWireContoller("circle", 0, {}, $wireScale*$so, false);
			$aStr = abRTRename($loc, $objName);
			$loc = $aStr[1];
		}else if (abRTGetPosInStrArray($objName, $aZAxisUpCircleJnts) != -1){
			$axisUpIndex = abRTGetPosInStrArray($objName, $aZAxisUpCircleJnts);
			$wireScale = $aZAxisLocSize[$axisUpIndex];
			$loc = abRTWireContoller("circle", 2, {}, $wireScale*$so, false);
			$aStr = abRTRename($loc, $objName);
			$loc = $aStr[1];
		}else{
			$loc = abRTMakeLocator($objName);
			$aStr = `listRelatives -type shape $loc`;
			if (size($aStr) == 1) setAttr ($aStr[0]+".localScale") $locScale $locScale $locScale;
		}
		
		// recall locTransStr
		$aStr = stringToStringArray($locTransStr, "&");
		
		// trans
		$aSubStr = stringToStringArray($aStr[0], "|");
		setAttr ($loc+".t") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		// rot
		$aSubStr = stringToStringArray($aStr[1], "|");
		setAttr ($loc+".r") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		// scale
		$aSubStr = stringToStringArray($aStr[2], "|");
		setAttr ($loc+".s") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		$loc = abRTParent($loc, $parent);
		
		if ($frozen) makeIdentity -apply true -t 1 -r 1 -s 1 $loc;
		
		// save the control attributes values (if any) to restore once the loc structure has been completely recreated
		if (size($aStr) >= 6) $aRestoreAttTable[size($aRestoreAttTable)] = $objName+"&"+$aStr[3]+"&"+$aStr[4]+"&"+$aStr[5];
		
		// color the controls
		$aRel = `listRelatives -type shape $loc`;
		if (size($aRel) == 1){
			if (endsWith($objName, "_grpLoc")) $colorInd = $grpLocColorInd;
			else $colorInd = $locColorInd;
			
			setAttr ($aRel[0]+".overrideEnabled") true;
			setAttr ($aRel[0]+".overrideColor") $colorInd;
		}
	}
	
	// can now restore control attributes values (if any)
	for ($restoreAttData in $aRestoreAttTable){
		$aStr = stringToStringArray($restoreAttData, "&");
		$objName = $aStr[0];
		
		// trans
		$aSubStr = stringToStringArray($aStr[1], "|");
		setAttr ($objName+".t") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		// rot
		$aSubStr = stringToStringArray($aStr[2], "|");
		setAttr ($objName+".r") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
		// scale
		$aSubStr = stringToStringArray($aStr[3], "|");
		setAttr ($objName+".s") (float($aSubStr[0])) (float($aSubStr[1])) (float($aSubStr[2]));
		
	}
	
	if (size($aRootLocScale) > 0) setAttr ($rootLoc+".s") $aRootLocScale[0] $aRootLocScale[1] $aRootLocScale[2];
	
	return $rootLoc;
	
}


global proc abRTConnectLocStructure(string $rootLoc){
	// if $rootLoc exists, this proc will make the connections and draw the lines to make it a real true proxy skeleton
	
	if (`objExists $rootLoc`){
		
		string $data, $obj, $aSub[], $startLoc, $endLoc, $aStr[];
		int $i;
		int $lockAxes = int(abRTGetGlobal("lockProxyCtlAxes"));
		
		// draw lines
		
		string $aLineConnections[] = {
			"hip_loc>spine_low_loc>spine_mid_loc>spine_hi_loc>spine_end_loc>neck_loc>head_a_loc>head_b_loc",
			"head_a_loc>lf_eye_loc",
			"head_a_loc>rt_eye_loc",
			
			"spine_end_loc>lf_clavicle_loc>lf_upArm_loc>lf_elbow_loc>lf_wrist_loc",
			"lf_wrist_loc>lf_thumb_a_loc>lf_thumb_b_loc>lf_thumb_c_loc>lf_thumb_d_loc",
			"lf_wrist_loc>lf_index_a_loc>lf_index_b_loc>lf_index_c_loc>lf_index_d_loc",
			"lf_wrist_loc>lf_middle_a_loc>lf_middle_b_loc>lf_middle_c_loc>lf_middle_d_loc",
			"lf_wrist_loc>lf_ringCup_loc>lf_ring_a_loc>lf_ring_b_loc>lf_ring_c_loc>lf_ring_d_loc",
			"lf_wrist_loc>lf_pinkyCup_loc>lf_pinky_a_loc>lf_pinky_b_loc>lf_pinky_c_loc>lf_pinky_d_loc",
			
			"spine_end_loc>rt_clavicle_loc>rt_upArm_loc>rt_elbow_loc>rt_wrist_loc",
			"rt_wrist_loc>rt_thumb_a_loc>rt_thumb_b_loc>rt_thumb_c_loc>rt_thumb_d_loc",
			"rt_wrist_loc>rt_index_a_loc>rt_index_b_loc>rt_index_c_loc>rt_index_d_loc",
			"rt_wrist_loc>rt_middle_a_loc>rt_middle_b_loc>rt_middle_c_loc>rt_middle_d_loc",
			"rt_wrist_loc>rt_ringCup_loc>rt_ring_a_loc>rt_ring_b_loc>rt_ring_c_loc>rt_ring_d_loc",
			"rt_wrist_loc>rt_pinkyCup_loc>rt_pinky_a_loc>rt_pinky_b_loc>rt_pinky_c_loc>rt_pinky_d_loc",
			
			"hip_loc>lf_upLeg_loc>lf_knee_loc>lf_ankle_loc>lf_ball_loc>lf_toe_loc",
			"hip_loc>rt_upLeg_loc>rt_knee_loc>rt_ankle_loc>rt_ball_loc>rt_toe_loc"
		};
		
		for ($data in $aLineConnections){
			$aSub = stringToStringArray($data, ">");
			for ($i=0;$i<(size($aSub)-1);$i++){
				// connect locs with lines
				
				$startLoc = $aSub[$i];
				$endLoc = $aSub[$i+1];
				if (objExists($startLoc) && objExists($endLoc)) abRTConnectWithLine($startLoc, $endLoc);
			}
		}
		
		string $aMirrorObj[] = {"lf_arm_grpLoc", "lf_hand_grpLoc", "lf_pinkyCup_loc", "lf_ringCup_loc", "lf_pinky_grpLoc", "lf_pinky_d_loc", "lf_pinky_c_loc", "lf_pinky_a_loc", "lf_pinky_b_loc", "lf_ring_grpLoc", "lf_ring_d_loc", "lf_ring_c_loc", "lf_ring_b_loc", "lf_ring_a_loc", "lf_middle_grpLoc", "lf_middle_d_loc", "lf_middle_c_loc", "lf_middle_b_loc", "lf_middle_a_loc", "lf_index_grpLoc", "lf_index_a_loc", "lf_index_b_loc", "lf_index_c_loc", "lf_index_d_loc", "lf_thumb_grpLoc", "lf_thumb_b_loc", "lf_thumb_c_loc", "lf_thumb_d_loc", "lf_thumb_a_loc", "lf_cup_loc", "lf_wrist_loc", "lf_elbow_loc", "lf_upArm_loc", "lf_clavicle_loc", "lf_eye_loc", "lf_leg_grpLoc", "lf_foot_grpLoc", "lf_toe_loc", "lf_ball_loc", "lf_ankle_loc", "lf_knee_loc", "lf_upLeg_loc"};
		
		string $mObj;
		for ($obj in $aMirrorObj){
			$mObj = `substitute "lf_" $obj "rt_"`;
			if (`objExists $mObj`){
				abRTConnectMirrorTrans($obj, $mObj, 0);
				abRTPointConnect($obj, $mObj, 6);
				
				abRTConnectMirrorRot($obj, $mObj, 1);
				abRTConnectMirrorRot($obj, $mObj, 2);
				abRTOrientConnect($obj, $mObj, 1);
				
				if (endsWith($obj, "_grpLoc")){
					// connect grpLoc scale with mirror
					connectAttr ($obj+".s") ($mObj+".s");
				}
				
			}
		}
		
		string $aOriginObj[] = {"head_grpLoc","head_b_loc","spine_grpLoc","spine_end_grpLoc","head_a_loc","neck_loc","hip_loc","spine_low_loc","spine_mid_loc","spine_hi_loc","spine_end_loc"};
		for ($obj in $aOriginObj){
			// lock off tx
			if (objExists($obj)) setAttr -lock true ($obj+".tx");
		}
		
		if ($lockAxes){
			string $aLockTX[] = {"lf_foot_grpLoc","lf_index_a_loc","lf_upLeg_loc","lf_knee_loc","lf_ankle_loc","lf_ball_loc","lf_toe_loc"};
			string $aLockTY[] = {"lf_hand_grpLoc","lf_upArm_loc","lf_elbow_loc","lf_wrist_loc"};
			string $aLockTZ[] = {"lf_index_a_loc","lf_index_b_loc","lf_index_c_loc","lf_index_d_loc","lf_index_b_loc","lf_index_c_loc","lf_index_d_loc","lf_middle_a_loc","lf_middle_b_loc","lf_middle_c_loc","lf_middle_d_loc","lf_ring_a_loc","lf_ring_b_loc","lf_ring_c_loc","lf_ring_d_loc","lf_pinky_a_loc","lf_pinky_b_loc","lf_pinky_c_loc","lf_pinky_d_loc"};
			
			for ($obj in $aLockTX) if (objExists($obj)) setAttr -lock true ($obj+".tx");
			for ($obj in $aLockTY) if (objExists($obj)) setAttr -lock true ($obj+".ty");
			for ($obj in $aLockTZ) if (objExists($obj)) setAttr -lock true ($obj+".tz");
			
			string $aLockRX[] = {"lf_arm_grpLoc","spine_end_grpLoc"};
			string $aLockRY[] = {"spine_grpLoc","spine_end_grpLoc","head_grpLoc"};
			string $aLockRZ[] = {"spine_grpLoc","spine_end_grpLoc","head_grpLoc","lf_leg_grpLoc","lf_foot_grpLoc"};
			
			for ($obj in $aLockRX) if (objExists($obj)) setAttr -lock true ($obj+".rx");
			for ($obj in $aLockRY) if (objExists($obj)) setAttr -lock true ($obj+".ry");
			for ($obj in $aLockRZ) if (objExists($obj)) setAttr -lock true ($obj+".rz");
			
		}
	}
}


global proc string[] abRTMakeSpineJntsFromCurve(string $curve, string $aJntNames[], string $grp){
	/*
	makes size($aJntNames) joints following $curve and places them in $grp (if it exists)
	returns new joint paths
	*/
	
	int $numJnts = size($aJntNames);
	string $aRet[];
	
	if (size($aJntNames) >= 2){
		
		select -clear;
		
		string $aJnts[], $jnt;
		float $aTrans[], $aParam[];
		
		int $i;
		
		for ($i=0;$i<($numJnts-1);$i++){
			if ($i == 0) $aParam[$i] = 0;
			else $aParam[$i] = float($i)/($numJnts-1);
		}
		
		$aParam[size($aParam)] = 1;
		
		// rebuild curve
		
		string $jntPath;
		for ($i=0;$i<size($aParam);$i++){
			
			$param = $aParam[$i];
			$aTrans = `pointOnCurve -turnOnPercentage true -parameter $param -position $curve`;
			
			$jnt = `joint -p $aTrans[0] $aTrans[1] $aTrans[2] -n $aJntNames[$i]`;
			
			if ($i == 0 && $grp != "" && `objExists $grp`) $jnt = abRTParent($jnt, $grp);
			else $jnt = $jntPath+"|"+$jnt;
			
			$aJnts[size($aJnts)] = $jnt;
			$aRet[size($aRet)] = $jnt;
			
			$jntPath = $jnt;
		}
		
		$aRet = $aJnts;
		
	}
	
	return $aRet;
	
}


global proc abRTOrientJoints(string $aJnts[], string $orient, string $sao){
	// orients joints.  $orient is value of joint -orientJoint ("xyz") and $sao is value of joint -sao ("zdown")
	
	string $jnt, $aRel[];
	for ($jnt in $aJnts){
		$aRel = `listRelatives -c -type joint $jnt`;
		if (size($aRel) > 0){
			xform -ro 0 0 0 $jnt;
			joint -e -orientJoint $orient -sao $sao $jnt;
		}
	}
}


global proc abRTSkeletonMaker(){
	// ui to build a skeleton
	
	int $autoSaveSkel = int(abRTGetGlobal("autoSaveSkeleton"));
	int $lockProxyCtlAxes = int(abRTGetGlobal("lockProxyCtlAxes"));
	int $mirrorLegsBehavior = int(abRTGetGlobal("legMirrorBehavior"));
	
	if (`window -exists abRTSklMkrWin`){
		deleteUI -window abRTSklMkrWin;
	}
	
	window -t "abSkeletonMaker" -w 190 -h 272 -menuBar true -minimizeButton false -maximizeButton false abRTSklMkrWin;
	
	int $lmargin = 3;
	int $rmargin = 3;
	
	menu -label "Options";
 	menuItem -label "Lock Proxy Control Axes" -checkBox $lockProxyCtlAxes  -c ("abRTSetGlobal(\"lockProxyCtlAxes\", (string(`menuItem -q -checkBox abRTSklMkrLckPrxyCtlAxMnIt`)));") abRTSklMkrLckPrxyCtlAxMnIt;
	menuItem -label "Autosave Skeleton on Build" -checkBox $autoSaveSkel  -c ("abRTSetGlobal(\"autoSaveSkeleton\", (string(`menuItem -q -checkBox abRTSklMkrAutoSaveMnIt`)));") abRTSklMkrAutoSaveMnIt;
	menuItem -label "Mirror Leg Behavior" -checkBox $mirrorLegsBehavior  -c ("abRTSetGlobal(\"legMirrorBehavior\", (string(`menuItem -q -checkBox abRTSklMkrMirLegBehaviorMnIt`)));") abRTSklMkrMirLegBehaviorMnIt;
	
	formLayout -numberOfDivisions 100 abRTSklMkrForm;
	
	intSliderGrp -label "Finger Num:" -min 2 -max 5 -v 5 -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrFingerNumIntSldrGrp;
	
	button -l "Make Proxy Skeleton" -h 28 -c "abRTMakeProxySkeleton();" abRTSklMkrPrxyBn;
	separator abRTSklMkrSep1;
	button -l "Save Proxy to Shelf" -c "abRTSaveProxySkeleton();" abRTSklMkrSavePrxyBn;
	separator abRTSklMkrSep2;
	
	intSliderGrp -label "UpLeg Split:" -min 0 -max 2 -v 0 -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrUpLegSpltIntSldrGrp;
	intSliderGrp -label "UpArm Split:" -min 0 -max 2 -v 0 -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrUpArmSpltIntSldrGrp;
	intSliderGrp -label "ForeArm Split:" -min 0 -max 2 -v 0 -field true -columnWidth3 80 30 100 -adjustableColumn3 3 abRTSklMkrForeArmSpltIntSldrGrp;
	button -l "Build Skeleton" -h 28 -c "abRTSkeletonizeProxy();" abRTSklMkrBldBn;
	
	formLayout -e
	
	-af abRTSklMkrPrxyBn "top" 6
	-af abRTSklMkrPrxyBn "left" $lmargin
	-af abRTSklMkrPrxyBn "right" $rmargin
	
	-ac abRTSklMkrFingerNumIntSldrGrp "top" 5 abRTSklMkrPrxyBn
	-af abRTSklMkrFingerNumIntSldrGrp "left" $lmargin
	-af abRTSklMkrFingerNumIntSldrGrp "right" $rmargin
	
	-ac abRTSklMkrSep1 "top" 4 abRTSklMkrFingerNumIntSldrGrp
	-af abRTSklMkrSep1 "left" $lmargin
	-af abRTSklMkrSep1 "right" $rmargin
	
	-ac abRTSklMkrSavePrxyBn "top" 5 abRTSklMkrSep1
	-af abRTSklMkrSavePrxyBn "left" $lmargin
	-af abRTSklMkrSavePrxyBn "right" $rmargin
	
	-ac abRTSklMkrSep2 "top" 5 abRTSklMkrSavePrxyBn
	-af abRTSklMkrSep2 "left" $lmargin
	-af abRTSklMkrSep2 "right" $rmargin
	
	-ac abRTSklMkrUpLegSpltIntSldrGrp "top" 5 abRTSklMkrSep2
	-af abRTSklMkrUpLegSpltIntSldrGrp "left" $lmargin
	-af abRTSklMkrUpLegSpltIntSldrGrp "right" $rmargin
	
	-ac abRTSklMkrUpArmSpltIntSldrGrp "top" 5 abRTSklMkrUpLegSpltIntSldrGrp
	-af abRTSklMkrUpArmSpltIntSldrGrp "left" $lmargin
	-af abRTSklMkrUpArmSpltIntSldrGrp "right" $rmargin
	
	-ac abRTSklMkrForeArmSpltIntSldrGrp "top" 5 abRTSklMkrUpArmSpltIntSldrGrp
	-af abRTSklMkrForeArmSpltIntSldrGrp "left" $lmargin
	-af abRTSklMkrForeArmSpltIntSldrGrp "right" $rmargin
	
	-ac abRTSklMkrBldBn "top" 6 abRTSklMkrForeArmSpltIntSldrGrp
	-af abRTSklMkrBldBn "left" $lmargin
	-af abRTSklMkrBldBn "right" $rmargin
	
	abRTSklMkrForm;
	
	showWindow abRTSklMkrWin;
	
}


global proc abRTMakeProxySkeleton(){
	// makes a proxy skeleton
	
	string $aData[] = {"hip_loc","*","0|28.78353936|-0.03793848382&0|0|0&1|1|1","1","spine_grpLoc","*","0|31.15716066|-0.04843504669&0|0|0&1|1|1","1","lf_leg_grpLoc","*","3.013497598|27.54369647|-0.07347699371&0|0|0&1|1|1","1","rt_leg_grpLoc","*","-3.013326526|27.54369647|-0.07347699371&0|0|0&1|1|1","1","spine_low_loc","spine_grpLoc","0|31.15716066|-0.04843504669&0|0|0&1|1|1","1","spine_mid_loc","spine_grpLoc","0|35.13522079|-0.295672241&0|0|0&1|1|1","1","spine_hi_loc","spine_grpLoc","0|40.30690808|-0.5424012602&0|0|0&1|1|1","1","spine_end_grpLoc","spine_grpLoc","0|43.19712444|-0.5424012602&0|0|0&1|1|1","1","lf_knee_loc","lf_leg_grpLoc","3.013497598|14.85122758|0.336829834&0|0|0&1|1|1","1","lf_upLeg_loc","lf_leg_grpLoc","3.013497598|27.54369647|-0.07347699371&0|0|0&1|1|1","1","lf_foot_grpLoc","lf_leg_grpLoc","3.013497598|2.032517305|-0.09561233996&0|0|0&1|1|1","1","rt_knee_loc","rt_leg_grpLoc","-3.013326526|14.85122758|0.336829834&0|0|0&1|1|1","1","rt_upLeg_loc","rt_leg_grpLoc","-3.013497598|27.54369647|-0.07347699371&0|0|0&1|1|1","1","rt_foot_grpLoc","rt_leg_grpLoc","-3.013497598|2.032517305|-0.09561233996&0|0|0&1|1|1","1","spine_end_loc","spine_end_grpLoc","0|43.19712444|-0.5424012602&0|0|0&1|1|1","1","lf_arm_grpLoc","spine_end_grpLoc","6.034036297|44.76636291|-0.1956620128&0|0|0&1|1|1","1","lf_clavicle_loc","spine_end_grpLoc","2.576254409|44.09779615|-0.5424012602&0|0|0&1|1|1","1","rt_clavicle_loc","spine_end_grpLoc","-2.576254368|44.09779615|-0.5424012602&0|0|0&1|1|1","1","rt_arm_grpLoc","spine_end_grpLoc","-6.033693755|44.76636291|-0.1956620128&0|0|0&1|1|1","1","neck_loc","spine_end_grpLoc","0|45.81468835|-0.08889763514&0|0|0&1|1|1","1","head_grpLoc","spine_end_grpLoc","0|49.64237862|0.4188537574&0|0|0&1|1|1","1","lf_toe_loc","lf_foot_grpLoc","3.013497598|0.3777597796|9.104148301&0|0|0&1|1|1","1","lf_ball_loc","lf_foot_grpLoc","3.013497598|0.4743170541|5.743069406&0|0|0&1|1|1","1","lf_ankle_loc","lf_foot_grpLoc","3.013497598|2.032517305|-0.09561233996&0|0|0&1|1|1","1","rt_ankle_loc","rt_foot_grpLoc","-3.013326526|2.032517305|-0.09561233996&0|0|0&1|1|1","1","rt_ball_loc","rt_foot_grpLoc","-3.013326526|0.4743170541|5.743069406&0|0|0&1|1|1","1","rt_toe_loc","rt_foot_grpLoc","-3.013326526|0.3777597796|9.104148301&0|0|0&1|1|1","1","lf_hand_grpLoc","lf_arm_grpLoc","18.2687344|44.75524492|-0.0747203956&0|0|0&1|1|1","1","lf_elbow_loc","lf_arm_grpLoc","12.64889295|44.75524492|-0.3871783966&0|0|0&1|1|1","1","lf_upArm_loc","lf_arm_grpLoc","6.034036297|44.75524492|-0.1956620128&0|0|0&1|1|1","1","rt_hand_grpLoc","rt_arm_grpLoc","-18.2687344|44.75524492|-0.0747203956&0|0|0&1|1|1","1","rt_elbow_loc","rt_arm_grpLoc","-12.64889295|44.75524492|-0.3871783966&0|0|0&1|1|1","1","rt_upArm_loc","rt_arm_grpLoc","-6.034036297|44.75524492|-0.1956620128&0|0|0&1|1|1","1","rt_eye_loc","head_grpLoc","-1.736123706|51.70815386|3.848839017&0|0|0&1|1|1","1","lf_eye_loc","head_grpLoc","1.736222268|51.70815386|3.848839017&0|0|0&1|1|1","1","head_b_loc","head_grpLoc","0|55.38444037|1.660166238&0|0|0&1|1|1","1","head_a_loc","head_grpLoc","0|49.64237862|0.4188537574&0|0|0&1|1|1","1","lf_pinky_grpLoc","lf_hand_grpLoc","21.52003688|44.73346199|-1.893816526&0|0|0&1|1|1","1","lf_ring_grpLoc","lf_hand_grpLoc","21.76014178|45.09340754|-0.8076245475&0|0|0&1|1|1","1","lf_middle_grpLoc","lf_hand_grpLoc","21.96855005|45.20015917|0.2817956095&0|0|0&1|1|1","1","lf_index_grpLoc","lf_hand_grpLoc","21.80772721|44.95734133|1.502138942&0|0|0&1|1|1","1","lf_thumb_grpLoc","lf_hand_grpLoc","19.45185783|44.18055371|1.157473975&0|0|0&1|1|1","1","lf_pinkyCup_loc","lf_hand_grpLoc","19.3014657|44.733462|-1.532765356&0|0|0&1|1|1","1","lf_ringCup_loc","lf_hand_grpLoc","19.28052447|44.943256|-0.6885645133&0|0|0&1|1|1","1","lf_wrist_loc","lf_hand_grpLoc","18.2687344|44.75524492|-0.0747203956&0|0|0&1|1|1","1","rt_pinky_grpLoc","rt_hand_grpLoc","-21.51886348|44.73346199|-1.893890243&0|0|0&1|1|1","1","rt_ring_grpLoc","rt_hand_grpLoc","-21.75895369|45.09340754|-0.807699187&0|0|0&1|1|1","1","rt_middle_grpLoc","rt_hand_grpLoc","-21.96735674|45.20015917|0.2817206422&0|0|0&1|1|1","1","rt_index_grpLoc","rt_hand_grpLoc","-21.80653866|44.95734133|1.502064273&0|0|0&1|1|1","1","rt_thumb_grpLoc","rt_hand_grpLoc","-19.45185783|44.18055371|1.157473975&0|0|0&1|1|1","1","rt_thumb_a_loc","rt_thumb_grpLoc","-19.45080372|44.18055371|1.157407751&0|0|0&1|1|1","1","rt_pinkyCup_loc","rt_hand_grpLoc","-19.31901425|44.73346199|-1.812093471&0|0|0&1|1|1","1","rt_ringCup_loc","rt_hand_grpLoc","-19.29775338|45.09380611|-0.9628052863&0|0|0&1|1|1","1","rt_wrist_loc","rt_hand_grpLoc","-18.26775156|44.75524492|-0.07478214142&0|0|0&1|1|1","1","lf_pinky_d_loc","lf_pinky_grpLoc","25.02529979|44.69431483|-1.673600608&0|0|0&1|1|1","1","lf_pinky_c_loc","lf_pinky_grpLoc","23.75070357|44.77365816|-1.753676307&0|0|0&1|1|1","1","lf_pinky_a_loc","lf_pinky_grpLoc","21.52003688|44.73346199|-1.893816526&0|0|0&1|1|1","1","lf_pinky_b_loc","lf_pinky_grpLoc","22.64430958|44.84741279|-1.823184807&0|0|0&1|1|1","1","lf_ring_d_loc","lf_ring_grpLoc","26.29234302|45.01729861|-0.5228918798&0|0|0&1|1|1","1","lf_ring_c_loc","lf_ring_grpLoc","24.86857543|45.0968095|-0.6123391755&0|0|0&1|1|1","1","lf_ring_b_loc","lf_ring_grpLoc","23.27618811|45.1723294|-0.7123798984&0|0|0&1|1|1","1","lf_ring_a_loc","lf_ring_grpLoc","21.76014178|45.09340754|-0.8076245475&0|0|0&1|1|1","1","lf_middle_d_loc","lf_middle_grpLoc","26.63216727|45.11943681|0.5697624576&0|0|0&1|1|1","1","lf_middle_c_loc","lf_middle_grpLoc","25.16365461|45.19873565|0.477323395&0|0|0&1|1|1","1","lf_middle_b_loc","lf_middle_grpLoc","23.76832148|45.29663976|0.390826788&0|0|0&1|1|1","1","lf_middle_a_loc","lf_middle_grpLoc","21.96855005|45.20015917|0.2817956095&0|0|0&1|1|1","1","lf_index_a_loc","lf_index_grpLoc","21.80772721|44.95734133|1.502138942&0|0|0&1|1|1","1","lf_index_b_loc","lf_index_grpLoc","23.49126975|45.06165807|1.607906433&0|0|0&1|1|1","1","lf_index_c_loc","lf_index_grpLoc","24.88645214|44.95647455|1.695557882&0|0|0&1|1|1","1","lf_index_d_loc","lf_index_grpLoc","26.14595354|44.87742857|1.774685258&0|0|0&1|1|1","1","lf_thumb_b_loc","lf_thumb_grpLoc","20.28999093|43.60887316|2.621890191&0|0|0&1|1|1","1","lf_thumb_c_loc","lf_thumb_grpLoc","21.53770845|43.17885332|3.373828551&0|0|0&1|1|1","1","lf_thumb_d_loc","lf_thumb_grpLoc","22.99811726|42.54857357|3.761570831&0|0|0&1|1|1","1","lf_thumb_a_loc","lf_thumb_grpLoc","19.45185783|44.18055371|1.157473975&0|0|0&1|1|1","1","rt_pinky_d_loc","rt_pinky_grpLoc","-25.02393697|44.69431483|-1.673686224&0|0|0&1|1|1","1","rt_pinky_c_loc","rt_pinky_grpLoc","-23.74940126|44.77365816|-1.753758121&0|0|0&1|1|1","1","rt_pinky_a_loc","rt_pinky_grpLoc","-21.51886348|44.73346199|-1.893890243&0|0|0&1|1|1","1","rt_pinky_b_loc","rt_pinky_grpLoc","-22.64307236|44.84741279|-1.823262533&0|0|0&1|1|1","1","rt_ring_d_loc","rt_ring_grpLoc","-26.29095591|45.01729861|-0.5229790206&0|0|0&1|1|1","1","rt_ring_c_loc","rt_ring_grpLoc","-24.86724902|45.0968095|-0.6124225034&0|0|0&1|1|1","1","rt_ring_b_loc","rt_ring_grpLoc","-23.27492696|45.1723294|-0.7124591276&0|0|0&1|1|1","1","rt_ring_a_loc","rt_ring_grpLoc","-21.75895369|45.09340754|-0.807699187&0|0|0&1|1|1","1","rt_middle_d_loc","rt_middle_grpLoc","-26.63074355|45.11943681|0.5696730164&0|0|0&1|1|1","1","rt_middle_c_loc","rt_middle_grpLoc","-25.16229159|45.19873565|0.4772377667&0|0|0&1|1|1","1","rt_middle_b_loc","rt_middle_grpLoc","-23.76702376|45.29663976|0.3907452617&0|0|0&1|1|1","1","rt_middle_a_loc","rt_middle_grpLoc","-21.96735674|45.20015917|0.2817206422&0|0|0&1|1|1","1","rt_index_a_loc","rt_index_grpLoc","-21.80653866|44.95734133|1.502064273&0|0|0&1|1|1","1","rt_index_b_loc","rt_index_grpLoc","-23.48998563|45.06165807|1.607825761&0|0|0&1|1|1","1","rt_index_c_loc","rt_index_grpLoc","-24.88510295|44.95647455|1.695473123&0|0|0&1|1|1","1","rt_index_d_loc","rt_index_grpLoc","-26.14454389|44.87742857|1.774596701&0|0|0&1|1|1","1","rt_thumb_b_loc","rt_thumb_grpLoc","-20.28887489|43.60887316|2.621820078&0|0|0&1|1|1","1","rt_thumb_c_loc","rt_thumb_grpLoc","-21.53652678|43.17885332|3.373754315&0|0|0&1|1|1","1","rt_thumb_d_loc","rt_thumb_grpLoc","-22.9968509|42.54857357|3.761491275&0|0|0&1|1|1","1"};
	
	string $rootLoc = abRTRecallLocStructure($aData);
	abRTConnectLocStructure($rootLoc);
	
}


global proc abRTSaveProxySkeleton(){
	// save current proxy skeleton to a shelf button
	
	string $aLoc[] = abRTEncodeLocStructure("skeleton_proxy_grpLoc");
	if (size($aLoc) != 0){
		string $aData = stringArrayToString($aLoc, "\",\"");
		$aData = "{\""+$aData+"\"}";
		
		string $cmd = "string $gStr = abRTRecallLocStructure(\n"+$aData+"\n);\n";
		$cmd += "abRTConnectLocStructure($gStr);\n";
		$cmd += "if (!`window -q -exists abRTSklMkrWin`) abRTSkeletonMaker();\n";
		
		textToShelf("Skel", $cmd);
	}
}


global proc abRTSkeletonizeProxy(){
	// creates a skeleton from a skeleton proxy
	
	if (!(`objExists "skeleton_proxy_grpLoc"`)){
		warning "You need to create a proxy skeleton first.";
		return;
	}
	
	// save the proxy
	int $autoSaveSkel = int(abRTGetGlobal("autoSaveSkeleton"));
	if ($autoSaveSkel) abRTSaveProxySkeleton();
	
	string $aJntConnections[] = {
		"hip_loc>spine_low_loc>spine_mid_loc>spine_hi_loc>spine_end_loc>neck_loc>head_a_loc>head_b_loc",
		"head_a_loc>lf_eye_loc",
		
		"spine_end_loc>lf_clavicle_loc>lf_upArm_loc>lf_elbow_loc>lf_wrist_loc>lf_hand_loc",
		"lf_hand_loc>lf_thumb_a_loc>lf_thumb_b_loc>lf_thumb_c_loc>lf_thumb_d_loc",
		"lf_hand_loc>lf_index_a_loc>lf_index_b_loc>lf_index_c_loc>lf_index_d_loc",
		"lf_hand_loc>lf_middle_a_loc>lf_middle_b_loc>lf_middle_c_loc>lf_middle_d_loc",
		"lf_hand_loc>lf_ringCup_loc>lf_ring_a_loc>lf_ring_b_loc>lf_ring_c_loc>lf_ring_d_loc",
		"lf_hand_loc>lf_pinkyCup_loc>lf_pinky_a_loc>lf_pinky_b_loc>lf_pinky_c_loc>lf_pinky_d_loc",
		
		"hip_loc>lf_upLeg_loc>lf_knee_loc>lf_ankle_loc>lf_ball_loc>lf_toe_loc"
	};
	
	string $subStr, $aSub[], $aNames[], $loc, $tGrp, $obj, $aJnts[], $jnt, $aStr[], $rootJnt, $hipJnt, $baseName, $prefix, $aJntsToMirror[], $elbow, $clavicle, $eye, $upArm, $upLeg, $knee, $wrist, $ankle, $ball, $aHeadNeck[], $aFingers[], $aFingerJnts[];
	int $i, $k, $end, $nonExistantLoc, $int, $ind;
	
	// throw warning if pv snap att won't work
	float $aTrans[], $aTransLast[];
	float $pvCheckTol = .001;
	int $showWarning = false;
	
	$aFingerJnts = {"lf_index_a_loc","lf_index_b_loc","lf_index_c_loc","lf_index_d_loc","lf_middle_a_loc","lf_middle_b_loc","lf_middle_c_loc","lf_middle_d_loc","lf_ringCup_loc","lf_ring_a_loc","lf_ring_b_loc","lf_ring_c_loc","lf_ring_d_loc","lf_pinkyCup_loc","lf_pinky_a_loc","lf_pinky_b_loc","lf_pinky_c_loc","lf_pinky_d_loc"};
	
	//string $aPvLocCheck[] = {"1&lf_upArm_loc&lf_elbow_loc&lf_wrist_loc","0&lf_upLeg_loc&lf_knee_loc&lf_ankle_loc"}; // form of "axisThatItemsMustShare&item1&item2&item3&etc"
	string $aPvLocCheck[] = {"1&lf_upArm_loc&lf_elbow_loc&lf_wrist_loc"}; // form of "axisThatItemsMustShare&item1&item2&item3&etc"
	for ($i=0;$i<size($aPvLocCheck);$i++){
		$aStr = stringToStringArray($aPvLocCheck[$i], "&");
		if (size($aStr) <= 1) continue;
		
		$ind = int($aStr[0]); // index to compare loc translations upon -- 0 = x, 1 = y, 2 = z
		
		for ($k=2;$k<size($aStr);$k++){
			
			$aTrans = `xform -q -ws -rp $aStr[$k]`;
			$aTransLast = `xform -q -ws -rp $aStr[$k-1]`;
			
			if (abs($aTrans[$ind] - $aTransLast[$ind]) > $pvCheckTol){
				$showWarning = true;
				break;
			}
		}
	}
	
	if ($showWarning){
		//string $confirm = `confirmDialog -title "Confirm" -message "The leg and arm joints must lie on the same plane (YZ and\nXY respectively) for the knee and elbow snap to PV function\nto work properly.  The rest of the rig should work fine.\n\nDo you want to continue building the skeleton?" -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
		string $confirm = `confirmDialog -title "Confirm" -message "The arm joints must lie on the same YZ plane for\nthe elbow snap to PV function to work properly.\nThe rest of the rig should work fine.\n\nDo you want to continue building the skeleton?" -button "Yes" -button "No" -defaultButton "Yes" -cancelButton "No" -dismissString "No"`;
		if ($confirm == "No") return;
	}
	// done with warning
	
	// capture arm (z) and leg (y) grpLoc rotation
	float $aLArmRot[] = `getAttr lf_arm_grpLoc.r`;
	float $aRArmRot[] = `getAttr rt_arm_grpLoc.r`;
	float $aLLegRot[] = `getAttr lf_leg_grpLoc.r`;
	float $aRLegRot[] = `getAttr rt_leg_grpLoc.r`;
	float $aLAnkleRot[] = `getAttr lf_foot_grpLoc.r`;
	float $aRAnkleRot[] = `getAttr rt_foot_grpLoc.r`;
	
	
	string $name = abRTGetGlobal("name");
	if ($name == "") $name = "abSkel";
	
	string $skelGrpName = $name+"_Skeleton_grp";
	
	if (objExists($skelGrpName)){
		warning ("A skeleton with the base name \""+$name+"\" already exists in this scene.  Try another name.");
		return;
	}
	
	string $skelGrp = `group -em -w -name $skelGrpName`;
	
	// first need to create handLoc at wrist loc position
	$aStr = `duplicate -name "lf_hand_loc" "lf_wrist_loc"`;
	$aStr = `listRelatives -c -fullPath $aStr[0]`;
	if (size($aStr) > 0) delete $aStr;
	
	for ($i=0;$i<size($aJntConnections);$i++){
		
		$subStr = $aJntConnections[$i];
		$aSub = stringToStringArray($subStr, ">");
		clear($aNames);
		$nonExistantLoc = false;
		
		if ($i == 0){
			$tGrp = $skelGrp;
		}else{
			
			// remove the first item from all but the first subArray because it already exists, and we want to parent the rest of the joints in $aSub under it.
			$baseName = $aSub[0];
			if (startsWith($aSub[0], "lf")){
				$prefix = "l";
				$baseName = `substring $baseName 4 (size($baseName))`;
			}else{
				$prefix = "";
			}
			
			$baseName = `substring $baseName 1 (size($baseName) - 4)`;
			$tGrp = abRTRigNamer($baseName, $prefix, "jnt", true);
			$aSub = stringArrayRemoveExact({$aSub[0]}, $aSub);
			
		}
		
		for ($loc in $aSub){
			
			if (!`objExists $loc`) $nonExistantLoc = true;
			
			$baseName = $loc;
			if (startsWith($loc, "lf")){
				$prefix = "l";
				$baseName = `substring $baseName 4 (size($baseName))`;
			}else{
				$prefix = "";
			}
			
			// remove "loc" from end of name
			$baseName = `substring $baseName 1 (size($baseName) - 4)`;
			$aNames[size($aNames)] = abRTRigNamer($baseName, $prefix, "jnt", true);
			
			// keep upJoints for potential split joints and other reasons
			if ($baseName == "upLeg"){
				$upLeg = $aNames[size($aNames)-1];
			}else if ($baseName == "clavicle"){
				$clavicle = $aNames[size($aNames)-1];
			}else if ($baseName == "knee"){
				$knee = $aNames[size($aNames)-1];
			}else if ($baseName == "eye"){
				$eye = $aNames[size($aNames)-1];
			}else if ($baseName == "upArm"){
				$upArm = $aNames[size($aNames)-1];
			}else if ($baseName == "elbow"){
				$elbow = $aNames[size($aNames)-1];
			}else if ($baseName == "wrist"){
				// keep wrist to duplicate and make hand jnt
				$wrist = $aNames[size($aNames)-1];
			}else if ($baseName == "neck" || $baseName == "head_a"){
				// keep head and neck to change orientation for controls
				$aHeadNeck[size($aHeadNeck)] = $aNames[size($aNames)-1];
			}else if ($baseName == "ankle"){
				$ankle = $aNames[size($aNames)-1];
			}else if ($baseName == "ball"){
				$ball = $aNames[size($aNames)-1];
			}else if (abRTGetPosInStrArray($baseName, $aFingerJnts) > 0){
				$aFingers[size($aFingers)] = $aNames[size($aNames)-1];
			}
			
		}
		
		if ($nonExistantLoc) continue;
		$aStr = abRTDuplicateJointHierarchy($aSub, $aNames, $tGrp);
		
		// save root joint path
		if ($i == 0){
			$hipJnt = $aStr[0];
			$rootJnt = $aStr[1];
		}
		
	}
	
	// parent hip jnt under spine jnt
	$rootJnt = abRTParent($rootJnt, $skelGrp);
	$hipJnt = abRTParent($hipJnt, $rootJnt);
	$aJnts = `listRelatives -ad -fullPath -type joint $rootJnt`;
	
	// do radius
	float $float, $length;
	float $maxTx = 0;
	for ($jnt in $aJnts){
		$float = `getAttr ($jnt+".tx")`;
		$maxTx = max($maxTx, $float);
	}
	
	string $aRel[];
	float $minRad = .5;
	for ($jnt in $aJnts){
		if ($jnt == $hipJnt){
			setAttr ($jnt+".radius") 1;
		}else{
			$aRel = `listRelatives -c -type joint $jnt`;
			if (size($aRel) > 0){
				$length = `getAttr ($aRel[0]+".tx")`;
				$float = ($length/$maxTx)*(1-$minRad) + $minRad;
				setAttr ($jnt+".radius") $float;
			}else{
				setAttr ($jnt+".radius") $minRad;
			}
		}
	}
	// done with radius
	
	
	// orient joints
	$aJnts = `listRelatives -ad -fullPath -type joint $rootJnt`;
	$aJnts = stringArrayRemove({$hipJnt}, $aJnts);
	abRTOrientJoints($aJnts, "xyz", "zdown");
	
	// orient special case joints differently
	abRTOrientJoints($aHeadNeck, "yzx", "zup");
	abRTOrientJoints({$upLeg, $ankle, $ball}, "xyz", "ydown");
	abRTOrientJoints({$knee}, "xyz", "yup");
	
	// orient finger joints
	abRTOrientJoints($aFingers, "xzy", "yup");
	
	// done orienting
	
	
	// insert split joints
	int $upLegSplit = `intSliderGrp -q -v abRTSklMkrUpLegSpltIntSldrGrp`;
	int $upArmSplit = `intSliderGrp -q -v abRTSklMkrUpArmSpltIntSldrGrp`;
	int $foreArmSplit = `intSliderGrp -q -v abRTSklMkrForeArmSpltIntSldrGrp`;
	
	if ($upLegSplit > 0){
		clear($aNames);
		for ($i=0;$i<$upLegSplit;$i++) $aNames[size($aNames)] = abRTRigNamer(("upLegSplit"+($i+1)), "l", "jnt", true);
		abRTInsertJoints($upLeg, $aNames);
	}
	
	if ($upArmSplit > 0){
		clear($aNames);
		for ($i=0;$i<$upArmSplit;$i++) $aNames[size($aNames)] = abRTRigNamer(("upArmSplit"+($i+1)), "l", "jnt", true);
		abRTInsertJoints($upArm, $aNames);
	}
	
	if ($foreArmSplit > 0){
		clear($aNames);
		for ($i=0;$i<$foreArmSplit;$i++) $aNames[size($aNames)] = abRTRigNamer(("foreArmSplit"+($i+1)), "l", "jnt", true);
		abRTInsertJoints($elbow, $aNames);
	}
	
	// replace hand joints with duplicate of wrist to preserve alignment and reparent children
	string $hand, $newWrist;
	
	if (`objExists $wrist`){
		
		// realign arm joints
		string $aArmJnts[] = abRTGetHierarchy($clavicle, $wrist, true);
		abRTOrientJoints($aArmJnts, "xyz", "yup");
		
		$aRel = `listRelatives -c -fullPath $wrist`;
		$hand = $aRel[0];
		
		$aStr = `duplicate $wrist`;
		$newWrist = $aStr[0];
		$newWrist = abRTParent($newWrist, $wrist);
		$aRel = `listRelatives -c -fullPath $newWrist`;
		if (size($aRel) > 0) delete $aRel;
		
		$aRel = `listRelatives -c -fullPath $hand`;
		for ($i=0;$i<size($aRel);$i++){
			abRTParent($aRel[$i], $newWrist);
		}
		
		delete $hand;
		abRTRename($newWrist, abRTStripPath($hand));
		
	}
	
	// reorient the ankle and ball joints if there's y rotation on the footGrploc (ankle group loc)
	if ($aLAnkleRot[1] > .001) abRTOrientJoints({$ankle, $ball}, "xyz", "ydown");
	
	// mirror the skeleton.  Mirror behavior on clavicle and upleg and plane on eye
	mirrorJoint -mirrorBehavior -searchReplace "lf_" "rt_" $clavicle;
	mirrorJoint -mirrorYZ -searchReplace "lf_" "rt_" $eye;
	if ((int(abRTGetGlobal("legMirrorBehavior")))){
		mirrorJoint -mirrorBehavior -searchReplace "lf_" "rt_" $upLeg;
	}else{
		mirrorJoint -mirrorYZ -searchReplace "lf_" "rt_" $upLeg;
	}
	
	
	// add creation roation data to upArm and upLeg joints
	string $mUpArm = abRTSubstituteAll("lf", $upArm, "rt");
	string $mUpLeg = abRTSubstituteAll("lf", $upLeg, "rt");
	string $mAnkle = abRTSubstituteAll("lf", $ankle, "rt");
	//string $mBall = abRTSubstituteAll("lf", $ball, "rt");
	
	addAttr -dt float3 -hidden true -keyable false -longName "createRot" $upArm;
	setAttr -type float3 ($upArm+".createRot") $aLArmRot[0] $aLArmRot[1] $aLArmRot[2];
	
	addAttr -dt float3 -hidden true -keyable false -longName "createRot" $mUpArm;
	setAttr -type float3 ($mUpArm+".createRot") $aRArmRot[0] $aRArmRot[1] $aRArmRot[2];
	
	addAttr -dt float3 -hidden true -keyable false -longName "createRot" $upLeg;
	setAttr -type float3 ($upLeg+".createRot") $aLLegRot[0] $aLLegRot[1] $aLLegRot[2];
	
	addAttr -dt float3 -hidden true -keyable false -longName "createRot" $mUpLeg;
	setAttr -type float3 ($mUpLeg+".createRot") $aRLegRot[0] $aRLegRot[1] $aRLegRot[2];
	
	addAttr -dt float3 -hidden true -keyable false -longName "createRot" $ankle;
	setAttr -type float3 ($ankle+".createRot") $aLAnkleRot[0] $aLAnkleRot[1] $aLAnkleRot[2];
	
	addAttr -dt float3 -hidden true -keyable false -longName "createRot" $mAnkle;
	setAttr -type float3 ($mAnkle+".createRot") $aRAnkleRot[0] $aRAnkleRot[1] $aRAnkleRot[2];
	
	// delete the proxy
	if (`objExists skeleton_proxy_grpLoc`) delete skeleton_proxy_grpLoc;
	
	// update UI items
	if (`window -q -ex abRTWin`) abRTClearUIItems();
	
	select -clear;
}


global proc abRTAddWeightJointUI(){
	// creates UI for adding a weight joint
	
	global string $aAbRTSpaceSwitchData[];
	
	int $lmargin = 2;
	int $rmargin = 2;
	int $lCol = 80;
	
	if (`window -exists abRTAWJWin`) deleteUI -window abRTAWJWin;
	
	window -t "abAddWeightJoint" -w 216 -h 96 -menuBar false -minimizeButton false -maximizeButton false abRTAWJWin;
		
	formLayout -numberOfDivisions 100 abRTAWJForm;
	
	floatSliderGrp -label "Joint Position:" -min 0 -max 1 -v .5 -field true -columnWidth3 $lCol 40 100 -adjustableColumn3 3 abRTAWJPosFltSldrGrp;
	button -label "Create Weight Joints" -h 28 -command "abRTServiceAddWeightJointUI(\"create\");" abRTAWJCreateBn;
	
	formLayout -e
	
	-af abRTAWJPosFltSldrGrp "top" 6
	-af abRTAWJPosFltSldrGrp "left" $lmargin
	-af abRTAWJPosFltSldrGrp "right" ($rmargin*3)
	
	-ac abRTAWJCreateBn "top" 7 abRTAWJPosFltSldrGrp
	-af abRTAWJCreateBn "left" $lmargin
	-af abRTAWJCreateBn "right" $rmargin
	
	abRTAWJForm
	;
	
	showWindow abRTAWJWin;
	
}


global proc abRTServiceAddWeightJointUI(string $caller){
	// services abRTAddWeightJointUI
	
	if ($caller == "create"){
		
		string $jnt, $child, $aRel[], $aChildRoot[], $bnStr, $chosenObj, $cmd, $aUpJnts[], $aDnJnts[];
		int $arrayPos, $i;
		float $pos;
		
		$aSel = `ls -sl -type joint`;
		if (size($aSel) == 0){
			warning "Select a joint or joints to which you wish to add a weight joint.";
			return;
		}
		
		// make sure joints have at least one child joint
		for ($jnt in $aSel){
			$aRel = `listRelatives -fullPath -c -type joint $jnt`;
			if (size($aRel) == 0){
				warning ((abRTStripPath($jnt))+" does not have a child joint.  Skipping it and moving on.");
				continue;
			}else if (size($aRel) > 1){
				
				$bnStr = "";
				for ($child in $aRel){
					$aChildRoot[size($aChildRoot)] = abRTStripPath($child);
					$bnStr += " -button \""+($aChildRoot[size($aChildRoot)-1])+"\"";
				}
				
				$cmd = "confirmDialog -title \"Multiple Child Joints\" -message \"Select the child joint of "+(abRTStripPath($jnt))+" that you wish to split.\" "+$bnStr+" -button \"Cancel\" -defaultButton \"Cancel\" -cancelButton \"Cancel\" -dismissString \"Cancel\"";
				
				$chosenObj = eval($cmd);
				if ($chosenObj != "Cancel"){
					
					$arrayPos = abRTGetPosInStrArray($chosenObj, $aChildRoot);
					if ($arrayPos == -1){
						warning ((abRTStripPath($jnt))+" skipped.");
						continue;
					}
					
					$aUpJnts[size($aUpJnts)] = $jnt;
					$aDnJnts[size($aDnJnts)] = $aRel[$arrayPos];
					
				}else{
					warning ((abRTStripPath($jnt))+" skipped.");
				}
				
				continue;
				
			}else{
				$aUpJnts[size($aUpJnts)] = $jnt;
				$aDnJnts[size($aDnJnts)] = $aRel[0];
			}
		}
		
		// get info from UI
		$position = `floatSliderGrp -q -v abRTAWJPosFltSldrGrp`;
		
		// do it
		for ($i=0;$i<size($aUpJnts);$i++) abRTAddWeightJoint($aUpJnts[$i], $aDnJnts[$i], $position);
		
	}
	
}


global proc abRTAddWeightJoint(string $upJnt, string $downJnt, float $position){
	// adds a weight joint to a bone parented to $upJnt that translates (but doesn't rotate) with $downJnt ($downJnt must be a child of $upJnt).  $pos is a value from 0 to 1 that determines the placement of the joint, 0 at the $upJnt and 1 at the $downJnt.
	// $aimAxis is an int value from 0 to 2 (x,y,z) that specifies the axis that points down the joint
	
	string $weightJntGrpName = "weightJnt_grp";
	
	string $obj, $aStr[], $aRel[], $weightJnt, $weightJntFrzGrp, $baseName, $weightRigGrp, $weightRigGrp;
	string $prefix = abRTGetObjSide($upJnt);
	string $rootJnt = abRTGetRootFromJoint($upJnt);
	string $rigGrp = firstParentOf($rootJnt);
	
	// create $weightRigGrp if it doesn't exist
	if (objExists($rigGrp) && !objExists($rigGrp+"|"+$weightJntGrpName)){
		
		$weightRigGrp = `group -em -w`;
		$weightRigGrp = abRTParent($weightRigGrp, $rigGrp);
		$aStr = abRTRename($weightRigGrp, $weightJntGrpName);
		$weightRigGrp = $aStr[1];
		
	}else if (objExists($rigGrp+"|"+$weightJntGrpName)){
		$weightRigGrp = $rigGrp+"|"+$weightJntGrpName;
	}
	
	//make baseName
	$aStr = stringToStringArray(abRTStripPath($upJnt), "_");
	$baseName = tolower($aStr[2]);
	$aStr = stringToStringArray(abRTStripPath($downJnt), "_");
	$baseName += capitalizeString($aStr[2]);
	
	// get full path of downJnt
	$aStr = `ls -l $downJnt`;
	$downJnt = $aStr[0];
	
	// make sure $downJnt is child of $upJnt.  If not, return
	$aRel = `listRelatives -type joint -fullPath $upJnt`;
	if (abRTGetPosInStrArray($downJnt, $aRel) == -1) return;
	
	// duplicate and unparent upJnt
	$aStr = `duplicate $upJnt`;
	$weightJnt = $aStr[0];
	$aStr = `parent -w $weightJnt`;
	$weightJnt = $aStr[0];
	
	// rename it
	$aStr = abRTRename($weightJnt, abRTRigNamer(($baseName+"Weight"), $prefix, "jnt", true));
	$weightJnt = $aStr[1];
	
	$aRel = `listRelatives -ad -fullPath $weightJnt`;
	for ($obj in $aRel) delete $obj;
	
	// put it in the $weightRigGrp
	if (objExists($rigGrp)) $weightJnt = abRTParent($weightJnt, $weightRigGrp);
	
	// freeze group it
	$weightJnt = abRTGroupFreezeReturnObj($weightJnt, true);
	$weightJntFrzGrp = firstParentOf($weightJnt);
	
	// create constraints
	parentConstraint -mo $upJnt $weightJntFrzGrp;
	string $aPointConst[] = `pointConstraint $upJnt $downJnt $weightJnt`;
	string $aWeightAtts[] = `pointConstraint -q -weightAliasList $aPointConst[0]`;
	
	// connect pointConstraint weights to jointPosition attribute
	addAttr -ln "jointPosition" -at "float" -dv $position -keyable true -min 0 -max 1 $weightJnt;
	string $reverseNode = abRTCreateNode("reverse", $baseName, $prefix, "");
	
	connectAttr ($weightJnt+".jointPosition") ($reverseNode+".inputX");
	connectAttr ($reverseNode+".outputX") ($aPointConst[0]+"."+$aWeightAtts[0]);
	
	connectAttr ($weightJnt+".jointPosition") ($aPointConst[0]+"."+$aWeightAtts[1]);
	
	// hide atts
	abRTHideAttr($weightJnt, {"tx","ty","tz","rx","ry","rz","sx","sy","sz"});
	
}


global proc abRTInsertJoints(string $upJnt, string $aNames[]){
	// inserts size($aNames) joints named $aNames (respectively) below $upJnt (which can only have one child)
	
	string $aRel[] = `listRelatives -c -fullPath -type joint $upJnt`;
	
	if (size($aRel) == 1){
		
		int $numJnts = size($aNames);
		string $dnJnt = $aRel[0];
		float $length = `getAttr ($dnJnt+".tx")`;
		
		float $splitDist = $length/float($numJnts+1);
		
		int $i;
		string $aStr[], $splitJnt, $aSplitJnts[], $parentJnt, $childJnt; 
		for ($i=0;$i<$numJnts;$i++){
			
			$aStr = `duplicate $upJnt`;
			$splitJnt = $aStr[0];
			
			$aRel = `listRelatives -c -fullPath $splitJnt`;
			if (size($aRel) > 0) delete $aRel;
			$splitJnt = abRTParent($splitJnt, $upJnt);
			
			setAttr ($splitJnt+".tx") ($splitDist*(float($i+1)));
			
			$aStr = abRTRename($splitJnt, $aNames[$i]);
			$splitJnt = $aStr[1];
			
			$aSplitJnts[size($aSplitJnts)] = $splitJnt;
		}
		
		for ($i=0;$i<size($aSplitJnts);$i++){
			
			if ($i == 0){
				$parentJnt = $upJnt;
				$childJnt = $aSplitJnts[$i];
			}else{
				$parentJnt = $splitJnt;
				$childJnt = $aSplitJnts[$i];	
			}
			
			$splitJnt = abRTParent($childJnt, $parentJnt);
			
			if ($i == (size($aSplitJnts)-1)) abRTParent($dnJnt, $splitJnt);
			
		}
	}
}


global proc abRTSpaceSwitchWindow(){
	// creates window for space switch tool
	
	global string $aAbRTSpaceSwitchData[];
	
	if (`window -exists abRTSSWin`) deleteUI -window abRTSSWin;
	
	window -t "abSpaceSwitchMatcher" -w 125 -h 90 -menuBar false -minimizeButton false -maximizeButton false abRTSSWin;
		
	formLayout -numberOfDivisions 100 abRTSSForm;
	
	button -label "Copy Position" -h 25 -command "abRTSpaceSwitchCopyPaste(0);" abRTSSCopyBn;
	button -label "Paste Position" -h 25 -en (size($aAbRTSpaceSwitchData) > 0) -command "abRTSpaceSwitchCopyPaste(1);" abRTSSPasteBn;
	
	int $lmargin = 2;
	int $rmargin = 2;
	
	formLayout -e
	
	-af abRTSSCopyBn "top" 3
	-af abRTSSCopyBn "left" $lmargin
	-af abRTSSCopyBn "right" $rmargin
	
	-ac abRTSSPasteBn "top" 4 abRTSSCopyBn
	-af abRTSSPasteBn "left" $lmargin
	-af abRTSSPasteBn "right" $rmargin
	
	abRTSSForm
	;
	
	showWindow abRTSSWin;
	
}


global proc abRTSpaceSwitchCopyPaste(int $action){
	// used to match controls that have had their space switched
	// first, select the controls on the item at the frame that you want to match and call this function with action=0 to copy its position
	// then go to the frame where you want to match the control position after a space switch and paste the saved position (call this function with action=1)
	// $action = 0 is copy, $action = 1 is paste
	
	global string $aAbRTSpaceSwitchData[];
	
	// form of {"controlPath|Lots|Of|*tx,ty,tz*rx,ry,rz","controlPath|Lots|Of|*tx,ty,tz*rx,ry,rz"}
	
	if ($action == 0 || $action == 1){
		
		string $ctrl, $data, $aData[], $aSubData[], $statusStr;
		float $aTrans[], $aRot[];
		string $aSel[] = `ls -sl -type transform`;
		
		if ($action == 0){
			// copy the selected items info
			
			if (size($aSel) == 0){
				print "Select at least one control curve.";
				return;
			}
			
			string $transStr, $rotStr;
			
			for ($ctrl in $aSel){
				
				$aTrans = `xform -q -ws -rp $ctrl`;
				$aRot = `xform -q -ws -ro $ctrl`;
				
				$data = $ctrl+"*"+string($aTrans[0])+","+string($aTrans[1])+","+string($aTrans[2])+"*"+string($aRot[0])+","+string($aRot[1])+","+string($aRot[2]);
				$aData[size($aData)] = $data;
				
			}
			
			$aAbRTSpaceSwitchData = $aData;
			
			$statusStr = (size($aSel) == 1) ? " object position copied." : " object positions copied.";
			print (size($aSel)+ $statusStr);
			
		}else if ($action == 1){
			// paste the save info
			
			if (size($aAbRTSpaceSwitchData) == 0){
				print "There is no data to paste.";
				return;
			}
			
			int $counter = 0;
			
			for ($data in $aAbRTSpaceSwitchData){
				$aData = stringToStringArray($data, "*");
				
				// get ctrl name
				$ctrl = $aData[0];
				
				// get trans info
				$aSubData = stringToStringArray($aData[1], ",");
				$aTrans[0] = float($aSubData[0]);
				$aTrans[1] = float($aSubData[1]);
				$aTrans[2] = float($aSubData[2]);
				
				// get rot info
				$aSubData = stringToStringArray($aData[2], ",");
				$aRot[0] = float($aSubData[0]);
				$aRot[1] = float($aSubData[1]);
				$aRot[2] = float($aSubData[2]);
				
				// apply it
				if (objExists($ctrl) && nodeType($ctrl) == "transform"){
					
					if (`getAttr -lock ($ctrl+".t")` == false) move -a -ws -rpr $aTrans[0] $aTrans[1] $aTrans[2] $ctrl;
					if (`getAttr -lock ($ctrl+".r")` == false) rotate -a -ws $aRot[0] $aRot[1] $aRot[2] $ctrl;
					
					$counter ++;
					
				}
			}
			
			$statusStr = (size($aSel) == 1) ? " object position modified." : " object positions modified.";
			print ($counter+ $statusStr);
			
		}
	}
	
	if (`window -exists abRTSSWin`) button -e -en (size($aAbRTSpaceSwitchData) > 0) abRTSSPasteBn;
	
}


global proc abRTMakeFkToIkSnapShelfBn(string $charName, string $limbName, string $aFkCtrls[], string $aFkJnts[], string $ikCtrl, string $ikAttCtrl, string $pvCtrl, string $aIkJnts[], string $aJnts[]){
	// creates a shelf button for character $charName or uses an existing and creates a button (limbName) in ui called by shelfBn that snaps fkCtrls to IkJnts
	// $ikAttCtrl is the control that the ikFkBlend att is on
	// $aData {"charName&limbName(lf_leg)&fkCtrl1>fkCtrl2>fkCtrl3&fkJnt1>fkJnt2>fkJnt3&ikCtrl&ikAttCtrl&pvCtrl&ikJnt1>ikJnt2>ikJnt3&limbJnt1>limbJnt2>limbJnt3"}
	
	string $cmd, $dataStr, $jnt, $obj;
	string $charBn = abRTGetCharNameFkIkSnapShelfBn($charName);
	string $placeHolder = "placeHolder";
	int $i;
	
	// strip initial "|" from paths so snap will work with regrouped and referenced objects
	for ($i=0;$i<size($aFkCtrls);$i++) $aFkCtrls[$i] = abRTStripRoot($aFkCtrls[$i]);
	for ($i=0;$i<size($aFkJnts);$i++) $aFkJnts[$i] = abRTStripRoot($aFkJnts[$i]);
	$ikCtrl = abRTStripRoot($ikCtrl);
	$ikAttCtrl = abRTStripRoot($ikAttCtrl);
	$pvCtrl = abRTStripRoot($pvCtrl);
	for ($i=0;$i<size($aIkJnts);$i++) $aIkJnts[$i] = abRTStripRoot($aIkJnts[$i]);
	for ($i=0;$i<size($aJnts);$i++) $aJnts[$i] = abRTStripRoot($aJnts[$i]);
	
	// $aData {"charName&limbName(lf_leg)&fkCtrl1>fkCtrl2>fkCtrl3&fkJnt1>fkJnt2>fkJnt3&ikCtrl&ikAttCtrl&pvCtrl&ikJnt1>ikJnt2>ikJnt3&limbJnt1>limbJnt2>limbJnt3"}
	string $newData = "\""+$charName+"&"+$limbName+"&"+(stringArrayToString($aFkCtrls, ">"))+"&"+(stringArrayToString($aFkJnts, ">"))+"&"+$ikCtrl+"&"+$ikAttCtrl+"&"+$pvCtrl+"&"+(stringArrayToString($aIkJnts, ">"))+"&"+(stringArrayToString($aJnts, ">"))+"\"";
	
	if ($charBn == ""){
		string $bnSuf = "_abRTFkIkSnapShelfBn";
		string $charAnn = $charName+$bnSuf;
		
		// make command string "charName&limbName(lf_leg)&fkCtrl1>fkCtrl2>fkCtrl3&fkJnt1>fkJnt2>fkJnt3&ikCtrl&ikAttCtrl&pvCtrl&ikJnt1>ikJnt2>ikJnt3&limbJnt1>limbJnt2>limbJnt3"
		$cmd = "global int $abRTInit; if ($abRTInit == \"\") source abAutoRig.mel;\n";
		$cmd = "abRTShowSnapFkToIkUI({"+$newData+",\""+$placeHolder+"\"});\n";
		
		string $parent = `shelfTabLayout -q -selectTab ShelfLayout`;
		string $charBn = `shelfButton -i "abAutoRigSkel.bmp" -iol $charName -ann $charAnn -parent $parent -c $cmd`;
		
	}else{
		$cmd = `shelfButton -q -c $charBn`;
		
		// check to see if this char limb combo is already in the button command
		string $testMatchStr = $charName+"&"+$limbName;
		
		if (`match $testMatchStr $cmd` == $testMatchStr){
			// this char limb has already been written to the shelf button cmd -- replace it
			
			string $aCmd[] = stringToStringArray($cmd, "{");
			string $aStr[] = stringToStringArray($aCmd[1], "}");
			$aCmd[1] = $aStr[0];
			$aCmd[2] = $aStr[1];
			// $aCmd now == {"procName(","\"data\",\"data\",\"data\"",");"} -- 2 is data
			
			string $aData[] = stringToStringArray($aCmd[1], ",");
			for ($i=0;$i<size($aData);$i++){
				
				if (`match $testMatchStr $aData[$i]` == $testMatchStr){
					$aData[$i] = $newData;
					break;
				}
			}
			
			// now put it all back together
			$cmd = $aCmd[0]+"{"+(stringArrayToString($aData, ","))+"}"+$aCmd[2];
			
		}else{
			
			// search and replace *placeHolder*
			$newData += ",\""+$placeHolder+"\"";
			$cmd = `substitute ("\""+$placeHolder+"\"") $cmd $newData`;
			
		}
		
		shelfButton -e -c $cmd $charBn;
		
	}
}


global proc string abRTGetCharNameFkIkSnapShelfBn(string $charName){
	// returns fkIkSnap shelf Button name for $charName or "" if one doesn't exist
	
	string $aCShelfBns[] = eval("shelfLayout -q -ca `shelfTabLayout -q -selectTab ShelfLayout`");
	string $bn, $ret, $ann;
	
	string $bnSuf = "_abRTFkIkSnapShelfBn";
	string $charAnn = $charName+$bnSuf;
	
	for ($bn in $aCShelfBns){
		$ann = `shelfButton -q -ann $bn`;
		if ($ann == $charAnn){
			$ret = $bn;
			break;
		}
	}
	return $ret;
}


global proc abRTSnapIkToFk(string $aFkJnts[], string $aFkCtrls[], string $ikCtrl, string $ikAttCtrl, string $jnt, string $pvCtrl){
	// snaps Ik ctrls to FkJnts in a most hacky way
	// $ikCtrl is wrist or ankle ikCtrl
	// $ikAttCtrl is curve with ikFkBlend attribute
	// $jnt is ankleJnt
	// if $jnt is "" then this is an arm that's being snapped (where the wrist joint has the same translation as the control curve)
	
	string $jntLoc, $ctrlLoc;
	float $aTrans[], $aRot[];
	
	// save current selection for later reselection
	string $aSel[] = `ls -sl`;
	
	// use namespaces if specified in UI
	if (`optionMenu -q -select abRTFkToIkUINameSpaceMenu` != 1){
		$nameSpace = `optionMenu -q -value abRTFkToIkUINameSpaceMenu`;
		
		for ($i=0;$i<size($aFkCtrls);$i++){
			if (startsWith($aFkCtrls[$i], "|")) $aFkCtrls[$i] = abRTStripRoot($aFkCtrls[$i]);
			$aFkCtrls[$i] = $nameSpace+":"+(substituteAllString($aFkCtrls[$i], "|", ("|"+$nameSpace+":")));
		}
		
		for ($i=0;$i<size($aFkJnts);$i++){
			if (startsWith($aFkJnts[$i], "|")) $aFkJnts[$i] = abRTStripRoot($aFkJnts[$i]);
			$aFkJnts[$i] = $nameSpace+":"+(substituteAllString($aFkJnts[$i], "|", ("|"+$nameSpace+":")));
		}
		
		if (startsWith($ikCtrl, "|")) $ikCtrl = abRTStripRoot($ikCtrl);
		$ikCtrl = $nameSpace+":"+(substituteAllString($ikCtrl, "|", ("|"+$nameSpace+":")));
		
		if (startsWith($jnt, "|")) $jnt = abRTStripRoot($jnt);
		$jnt = $nameSpace+":"+(substituteAllString($jnt, "|", ("|"+$nameSpace+":")));
		
		if (startsWith($pvCtrl, "|")) $pvCtrl = abRTStripRoot($pvCtrl);
		$pvCtrl = $nameSpace+":"+(substituteAllString($pvCtrl, "|", ("|"+$nameSpace+":")));
		
		if (startsWith($ikAttCtrl, "|")) $ikAttCtrl = abRTStripRoot($ikAttCtrl);
		$ikAttCtrl = $nameSpace+":"+(substituteAllString($ikAttCtrl, "|", ("|"+$nameSpace+":")));
	}
	
	
	if (!objExists($aFkCtrls[0])){
		warning ("Cannot find "+abRTStripPath($aFkCtrls[0])+" in the current scene.");
		return;
	}
	
	
	if ($jnt != ""){
		// dealing with a foot
		
		// get blend att and set it to 1 if not already (otherwise match won't work)
		float $ikFkBlend = `getAttr ($ikAttCtrl+".ikFkBlend")`;
		int $autoKey = `autoKeyframe -q -state`;
		int $changedIkFkBlend = false;
		
		if ($ikFkBlend < 1.0){
			if ($autoKey) autoKeyframe -state off;
			setAttr ($ikAttCtrl+".ikFkBlend") 1;
			$changedIkFkBlend = true;
		}
		
		// create loc for ankle joint and one for foot ctrl
		$jntLoc = abRTMakeLocator("snapIkToFkJntTempLoc");
		$ctrlLoc = abRTMakeLocator("snapIkToFkCtrlTempLoc");
		
		// parent ctrlLoc to ankleLoc
		$ctrlLoc = abRTParent($ctrlLoc, $jntLoc);
		
		// snap locs to ankle and footCtrl
		select -r $jnt $jntLoc;
		abRTPointOrient(1);
		select -clear;
		
		select -r $ikCtrl $ctrlLoc;
		abRTPointOrient(1);
		select -clear;
		
		// snap jntLoc to fkAnkleCtrl (same translation as the fkAnkle, and it's available) to find ctrl position
		select -r $aFkJnts[2] $jntLoc;
		abRTPointOrient(1);
		select -clear;
		
		// get trans and rot of ctrl loc
		$aTrans = `xform -q -ws -rp $ctrlLoc`;
		
		// reset ikFkBlend and autoKey if necessary
		if ($changedIkFkBlend){
			autoKeyframe -state $autoKey;
			setAttr ($ikAttCtrl+".ikFkBlend") $ikFkBlend;
		}
		
		// hack attack
		// make dup ikCtrl to snap to $ctrlLoc and copy rot values
		string $aStr[] = `duplicate $ikCtrl`;
		string $dupIkCtrl = $aStr[0];
		
		abRTShowAttr($dupIkCtrl, {"tx","ty","tz","rx","ry","rz"});
		
		select -r $ctrlLoc $dupIkCtrl;
		abRTPointOrient(1);
		select -clear;
		
		// position ikCtrl
		move -a -ws -rpr $aTrans[0] $aTrans[1] $aTrans[2] $ikCtrl;
		
		$aRot = `getAttr ($dupIkCtrl+".r")`;
		setAttr ($ikCtrl+".r") $aRot[0] $aRot[1] $aRot[2];
		
		delete $dupIkCtrl;
		delete $jntLoc;
		
	}else{
		
		// it's an arm
		// get trans and rot of ctrl loc
		
		$aTrans = `joint -q -p $aFkJnts[2]`;
		$aRot = `joint -q -o $aFkJnts[2]`;
		
		// position ikCtrl
		move -a -ws -rpr $aTrans[0] $aTrans[1] $aTrans[2] $ikCtrl;
		//rotate -a -ws $aRot[0] $aRot[1] $aRot[2] $ikCtrl;
		
	}
	
	// now to deal with the pvCtrl
	
	// make 1 degree curve snapped to joints to determine pv location
	// pv offset is distance of fkKneeCtrl to fkAnkleCtrl (don't want to have to sent ikJnts)
	
	float $aFKKneeTrans[] = `xform -q -ws -rp $aFkCtrls[0]`;
	float $aFKAnkleTrans[] = `xform -q -ws -rp $aFkCtrls[1]`;	
	float $pvOffset = sqrt(pow(($aFKKneeTrans[0] - $aFKAnkleTrans[0]), 2) + pow(($aFKKneeTrans[1] - $aFKAnkleTrans[1]), 2) + pow(($aFKKneeTrans[2] - $aFKAnkleTrans[2]), 2));
	
	int $i;
	string $curveCmd = "curve -d 1";
	
	for ($i=0;$i<3;$i++){
		$aTrans = `joint -q -p $aFkJnts[$i]`;
		$curveCmd += " -p "+$aTrans[0]+" "+$aTrans[1]+" "+$aTrans[2];
	}
	
	string $curve = eval($curveCmd);
	
	select -r ($curve+".cv[1]");
	moveVertexAlongDirection -n $pvOffset;
	select -clear;
	
	float $aPvTrans[] = `xform -q -ws -t ($curve+".cv[1]")`;
	
	delete $curve;
	
	move -a -ws -rpr $aPvTrans[0] $aPvTrans[1] $aPvTrans[2] $pvCtrl;
	
	if (size($aSel) > 0) select -r $aSel;
	
}


global proc abRTSnapFkToIk(string $aFkCtrls[], string $aFkJnts[], string $aIkJnts[]){
	// snaps fk ctrls to ikJnts
	// aOffsets are rotation offsets (to compensate for fkctrls being zeroed out) in the form of {offsetX|offsetY|offsetZ, offsetX|offsetY|offsetZ}
	
	string $nameSpace;
	int $i, $h;
	float $aFlt[];
	
	int $badSel = false;
	int $ok = true;
	
	// save current selection for later reselection
	string $aSel[] = `ls -sl`;
	
	// use namespaces if specified in UI
	if (`optionMenu -q -select abRTFkToIkUINameSpaceMenu` != 1){
		$nameSpace = `optionMenu -q -value abRTFkToIkUINameSpaceMenu`;
		
		for ($i=0;$i<size($aFkCtrls);$i++){
			if (startsWith($aFkCtrls[$i], "|")) $aFkCtrls[$i] = abRTStripRoot($aFkCtrls[$i]);
			$aFkCtrls[$i] = $nameSpace+":"+(substituteAllString($aFkCtrls[$i], "|", ("|"+$nameSpace+":")));
		}
		
		for ($i=0;$i<size($aFkJnts);$i++){
			if (startsWith($aFkJnts[$i], "|")) $aFkJnts[$i] = abRTStripRoot($aFkJnts[$i]);
			$aFkJnts[$i] = $nameSpace+":"+(substituteAllString($aFkJnts[$i], "|", ("|"+$nameSpace+":")));
		}
		
		for ($i=0;$i<size($aIkJnts);$i++){
			if (startsWith($aIkJnts[$i], "|")) $aIkJnts[$i] = abRTStripRoot($aIkJnts[$i]);
			$aIkJnts[$i] = $nameSpace+":"+(substituteAllString($aIkJnts[$i], "|", ("|"+$nameSpace+":")));
		}
	}
	
	if (!objExists($aFkCtrls[0])){
		warning ("Cannot find "+abRTStripPath($aFkCtrls[0])+" in the current scene.");
		return;
	}
	
	if (size($aFkCtrls) <= size($aIkJnts)){
		
		for ($i=0;$i<size($aFkCtrls);$i++){
			if (`objExists $aFkCtrls[$i]` && `objExists $aIkJnts[$i]`){
				
				// hack attack
				// make dup fkCtrl to snap to $ctrlLoc and copy rot values
				
				string $dupFkCtrl, $aStr[];
				float $aRot[];
				
				for ($h=0;$h<size($aFkCtrls);$h++){
					
					$aStr = `duplicate $aFkCtrls[$i]`;
					$dupFkCtrl = $aStr[0];
					
					abRTShowAttr($dupFkCtrl, {"tx","ty","tz","rx","ry","rz"});
					
					select -r $aIkJnts[$i] $dupFkCtrl;
					abRTPointOrient(1);
					select -clear;
					
					$aRot = `getAttr ($dupFkCtrl+".r")`;
					setAttr ($aFkCtrls[$i]+".r") $aRot[0] $aRot[1] $aRot[2];
					
					delete $dupFkCtrl;
				}
				
			}else{
				$badSel = true;
			}
		}
	}
	
	if ($badSel) warning "One or more specified objects no longer exist";
	
	if (size($aSel) > 0) select -r $aSel;
	
}


global proc abRTShowSnapFkToIkUI(string $aData[]){
	
	// makes UI to snap fk joints to ik joints
	// updated version in 1.9 doesn't work with older shelfbuttons (which is probably ok because it didn't really work that well anyway)
	// $aData {"charName&limbName(lf_leg)&fkCtrl1>fkCtrl2>fkCtrl3&fkJnt1>fkJnt2>fkJnt3&ikCtrl&ikAttCtrl&pvCtrl&ikJnt1>ikJnt2>ikJnt3&limbJnt1>limbJnt2>limbJnt3"}
	
	string $cmd, $data, $aSub[], $aFkCtrls[], $aFkJnts[], $aIkJnts[], $aJnts[], $charName, $limbName, $ikCtrl, $ikAttCtrl, $pvCtrl, $ikJnt, $ikFkBnName, $ikFkBnCmd, $fkIkBnName, $fkIkBnCmd, $menuName, $columnLayout, $rowColumnLayout, $str, $ankleJnt;
	string $placeHolder = "placeHolder";
	int $i, $k, $totRot, $isLeg;
	
	for ($i=0;$i<size($aData);$i++){
		$data = $aData[$i];
		if ($data == $placeHolder) continue;
		$aSub = stringToStringArray($data, "&");
		
		if (size($aSub) != 9){
			warning "Unable to display UI.";
			return;
		}
		
		$charName = $aSub[0];
		$limbName = $aSub[1];
		$aFkCtrls = stringToStringArray($aSub[2], ">");
		$aFkJnts = stringToStringArray($aSub[3], ">");
		$ikCtrl = $aSub[4];
		$ikAttCtrl = $aSub[5];
		$pvCtrl = $aSub[6];
		$aIkJnts = stringToStringArray($aSub[7], ">");
		$aJnts = stringToStringArray($aSub[8], ">");
		
		//abRTSnapIkToFk next to last argument will be $aJnts[2] for legs ($ankleJnt) and nothing for arms
		
		$isLeg = endsWith(tolower($limbName), "leg");
		if ($isLeg){
			$ankleJnt = $aJnts[2];
		}else{
			$ankleJnt = "";
		}
		
		if ($i == 0){
			$columnLayout = "abRT"+capitalizeString($charName)+"FkIkSnapColLayout";
			$rowColumnLayout = "abRT"+capitalizeString($charName)+"FkIkSnapRowColLayout";
			$cmd = ("columnLayout -columnAttach \"both\" 3 -rowSpacing 5 -adj true "+$columnLayout+";\n");
			$cmd += "rowColumnLayout -numberOfColumns 2 -columnWidth 2 50 -columnAttach 2 both 2 "+$rowColumnLayout+";\n";
		}
		
		$fkIkBnName = "abRTFkIK"+capitalizeString($charName)+capitalizeString($limbName)+"Bn";
		$fkIkBnCmd = "abRTSnapFkToIk({\\\""+(stringArrayToString($aFkCtrls,"\\\",\\\""))+"\\\"},{\\\""+(stringArrayToString($aFkJnts,"\\\",\\\""))+"\\\"},{\\\""+(stringArrayToString($aIkJnts,"\\\",\\\""))+"\\\"});";
		
		$ikFkBnName = "abRTIkFK"+capitalizeString($charName)+capitalizeString($limbName)+"Bn";
		$ikFkBnCmd = "abRTSnapIkToFk({\\\""+(stringArrayToString($aFkJnts,"\\\",\\\""))+"\\\"},{\\\""+(stringArrayToString($aFkCtrls,"\\\",\\\""))+"\\\"},\\\""+$ikCtrl+"\\\",\\\""+$ikAttCtrl+"\\\",\\\""+$ankleJnt+"\\\",\\\""+$pvCtrl+"\\\")";
		
		$cmd += "button -l \""+interToUI($limbName)+" Fk->Ik\" -c \""+$fkIkBnCmd+"\" "+$fkIkBnName+";\n";
		$cmd += "button -l \"Ik->Fk\" -c \""+$ikFkBnCmd+"\" "+$ikFkBnName+";\n";
	}
	
	if ($cmd != ""){
		// add namespace menu
		
		$menuName = "abRTFkToIkUINameSpaceMenu";
		
		string $aNameSpaces[] = `namespaceInfo -listOnlyNamespaces`;
		$aNameSpaces = stringArrayRemove({"shared", "UI"}, $aNameSpaces);
		$aNameSpaces = stringArrayCatenate({"Use Default Namespace"}, $aNameSpaces);
		
		$cmd += "optionMenu -p "+$columnLayout+" "+$menuName+";\n";
		for ($i=0;$i<size($aNameSpaces);$i++) $cmd += "menuItem -label \""+$aNameSpaces[$i]+"\";\n";
		
		$cmd = "if (`window -exists abRTFkToIkWin`){\ndeleteUI -window abRTFkToIkWin;\n}\nwindow -t \""+$charName+" Ik/Fk Snap\" -w 163 -h 156 -minimizeButton false -maximizeButton false abRTFkToIkWin;\n"+$cmd;
		$cmd += "showWindow abRTFkToIkWin;\n";
		
	}
	
	print $cmd;
	eval($cmd);
	
}


global proc int abRTGetPosInStrArray(string $str, string $aStr[]){
	// returns int (0 based) position of string in string array or -1 on fail.
	
	int $i;
	int $ret = -1;
	for ($i=0;$i<size($aStr);$i++){
		if ($aStr[$i] == $str){
			$ret = $i;
			break;
		}
	}
	
	return $ret;
	
}


global proc int abRTGetPosInIntArray(int $int, int $aInt[]){
	// returns int (0 based) position of int in int array or -1 on fail.
	
	int $i;
	int $ret = -1;
	for ($i=0;$i<size($aInt);$i++){
		if ($aInt[$i] == $int){
			$ret = $i;
			break;
		}
	}
	
	return $ret;
	
}


global proc abRTToggleMenuItem(string $menuItem, string $globalKey){
	// toggles a checkbox boolean menuItem and updates it's global value
	
	int $cVal;
	if (!catchQuiet($cVal = `menuItem -q -checkBox $menuItem`)){
		abRTSetGlobal($globalKey, (string($cVal)));
	}
	
}


global proc abRTGlobals(){
	// init global prefs string[]
	
	global string $abRTGlobalPrefs[];
	global string $abRTGlobalPrefNames[];
	
	clear($abRTGlobalPrefNames);
	clear($abRTGlobalPrefs);
	
	$abRTGlobalPrefNames[0] = "leftPrefix";$abRTGlobalPrefs[0] = "lf_"; 			// left prefix
	$abRTGlobalPrefNames[1] = "rightPrefix";$abRTGlobalPrefs[1] = "rt_"; 			// rt prefix
	
	$abRTGlobalPrefNames[2] = "name";$abRTGlobalPrefs[2] = "charName"; 			// character name
	$abRTGlobalPrefNames[3] = "globalScale";$abRTGlobalPrefs[3] = "1"; 			// global scale
	$abRTGlobalPrefNames[4] = "avgHeight";$abRTGlobalPrefs[4] = "183"; 			// units in avg height -- used to determine scale {183~6'0")
	$abRTGlobalPrefNames[5] = "deleteMeGrp";$abRTGlobalPrefs[5] = "abRTDeleteMeWhenDone"; 	// name of group to put temp rig building transforms in
	$abRTGlobalPrefNames[6] = "ctrlDir";$abRTGlobalPrefs[6] = "ctrl_grp"; 			// name of group to put control curves in
	$abRTGlobalPrefNames[7] = "versionNum";$abRTGlobalPrefs[7] = "2.8"; 			// script version Number
	
	// knee name conventions
	$abRTGlobalPrefNames[10] = "upLeg";$abRTGlobalPrefs[10] = "upLeg"; 			// upLeg name
	$abRTGlobalPrefNames[11] = "knee";$abRTGlobalPrefs[11] = "knee"; 			// knee name
	$abRTGlobalPrefNames[12] = "ankle";$abRTGlobalPrefs[12] = "ankle"; 			// ankle name
	$abRTGlobalPrefNames[13] = "ball";$abRTGlobalPrefs[13] = "ball"; 			// ball name
	$abRTGlobalPrefNames[14] = "toe";$abRTGlobalPrefs[14] = "toe"; 				// toe name
	$abRTGlobalPrefNames[15] = "heel";$abRTGlobalPrefs[15] = "heel"; 			// heel name
	
	// arm name conventions
	$abRTGlobalPrefNames[20] = "upArm";$abRTGlobalPrefs[20] = "upArm"; 			// upArm name
	$abRTGlobalPrefNames[21] = "elbow";$abRTGlobalPrefs[21] = "elbow"; 			// elbow name
	$abRTGlobalPrefNames[22] = "wrist";$abRTGlobalPrefs[22] = "wrist"; 			// wrist name
	$abRTGlobalPrefNames[23] = "hand";$abRTGlobalPrefs[23] = "hand"; 			// hand name
	
	// hand name conventions
	$abRTGlobalPrefNames[25] = "hand";$abRTGlobalPrefs[25] = "hand"; 			// hand name
	$abRTGlobalPrefNames[26] = "thumb";$abRTGlobalPrefs[26] = "thumb"; 			// thumb name
	$abRTGlobalPrefNames[27] = "index";$abRTGlobalPrefs[27] = "index"; 			// index name
	$abRTGlobalPrefNames[28] = "middle";$abRTGlobalPrefs[28] = "middle"; 			// middle name
	$abRTGlobalPrefNames[29] = "ring";$abRTGlobalPrefs[29] = "ring"; 			// ring name
	$abRTGlobalPrefNames[30] = "pinky";$abRTGlobalPrefs[30] = "pinky"; 			// pinky name
	
	// spine name conventions
	$abRTGlobalPrefNames[40] = "spine";$abRTGlobalPrefs[40] = "spine"; 			// spine name
	$abRTGlobalPrefNames[41] = "spine_a";$abRTGlobalPrefs[41] = "spine_a"; 			// spine_a name
	$abRTGlobalPrefNames[42] = "spine_b";$abRTGlobalPrefs[42] = "spine_b"; 			// spine_b name
	$abRTGlobalPrefNames[43] = "spine_c";$abRTGlobalPrefs[43] = "spine_c"; 			// spine_c name
	$abRTGlobalPrefNames[44] = "spine_d";$abRTGlobalPrefs[44] = "spine_d"; 			// spine_d name
	$abRTGlobalPrefNames[45] = "spine_e";$abRTGlobalPrefs[45] = "spine_e"; 			// spine_e name
	$abRTGlobalPrefNames[46] = "hip";$abRTGlobalPrefs[46] = "hip"; 				// hip name
	
	$abRTGlobalPrefNames[50] = "pvOffset";$abRTGlobalPrefs[50] = "20"; 			// pv ctrl offset from controlled jnt -- (no longer used)
	$abRTGlobalPrefNames[51] = "eyeCtrlOffset";$abRTGlobalPrefs[51] = "40"; 		// eye ctrl offset from eye jnts
	
	// colors
	$abRTGlobalPrefNames[60] = "ikJntColor";$abRTGlobalPrefs[60] = "28"; 			// ik joint color
	$abRTGlobalPrefNames[61] = "fkJntColor";$abRTGlobalPrefs[61] = "18"; 			// fk joint color
	$abRTGlobalPrefNames[62] = "lfCtrlColor";$abRTGlobalPrefs[62] = "6"; 			// left ctrl joint color
	$abRTGlobalPrefNames[63] = "rtCtrlColor";$abRTGlobalPrefs[63] = "13"; 			// right ctrl joint color
	$abRTGlobalPrefNames[64] = "ctrCtrlColor";$abRTGlobalPrefs[64] = "17"; 			// center ctrl color
	$abRTGlobalPrefNames[65] = "cogCtrlColor";$abRTGlobalPrefs[65] = "16"; 			// cog ctrl color
	
	// skeleton maker
	$abRTGlobalPrefNames[68] = "autoSaveSkeleton";$abRTGlobalPrefs[68] = "1"; 		// autoSave skeleton checkbox
	$abRTGlobalPrefNames[69] = "autoMirror";$abRTGlobalPrefs[69] = "1"; 			// autoMirror rigs on creation (legs, arms, hands)
	$abRTGlobalPrefNames[70] = "proxyLocScale";$abRTGlobalPrefs[70] = ".4"; 		// size of locs on proxy skeleton
	$abRTGlobalPrefNames[71] = "lockProxyCtlAxes";$abRTGlobalPrefs[71] = "1"; 		// lock proxy control axes
	$abRTGlobalPrefNames[72] = "legMirrorBehavior";$abRTGlobalPrefs[72] = "1"; 		// if true, the leg joints will be mirrored using behavior, otherwise will be mirrored using orientation
	
	// rotation
	$abRTGlobalPrefNames[75] = "thumbCurlSpreadRoll";$abRTGlobalPrefs[75] = "zyx"; 		// axes for thumb curl, spread and roll
	$abRTGlobalPrefNames[76] = "fingerCurlSpreadRoll";$abRTGlobalPrefs[76] = "yzx"; 	// axes for finger curl, spread and roll
	$abRTGlobalPrefNames[77] = "fingerCupAxis";$abRTGlobalPrefs[77] = "y"; 			// axis for finger cup joints
	$abRTGlobalPrefNames[78] = "reverseFingerCurl";$abRTGlobalPrefs[78] = "0"; 		// true if handJoints have been mirrored without -mirrorBehavior (pre 2.0 skeletons), otherwise false 
	
	
}


global proc string abRTGetGlobal(string $name){
	// return string value of value $name
	
	global string $abRTGlobalPrefs[];
	global string $abRTGlobalPrefNames[];
	
	string $ret;
	
	int $index = abRTGetPosInStrArray($name, $abRTGlobalPrefNames);
	if ($index != -1) $ret = $abRTGlobalPrefs[$index];
	
	return $ret;
	
}


global proc abRTSetGlobal(string $name, string $strVal){
	// set global pref $name to $strVal
	
	global string $abRTGlobalPrefs[];
	global string $abRTGlobalPrefNames[];
	
	int $index = abRTGetPosInStrArray($name, $abRTGlobalPrefNames);
	if ($index != -1) $abRTGlobalPrefs[$index] = $strVal;
	
}


global proc string abRTGetFromUI(string $uiItem){
	// returns current value of UI item (usually a field) or "" if empty
	
	string $ret;
	
	$uiItem = capitalizeString($uiItem);
	string $textFieldBnGrpName = "abRT"+$uiItem+"TxFldBnGrp";
	
	if (`textFieldButtonGrp -q -exists $textFieldBnGrpName`){
		$ret = `textFieldButtonGrp -q -text $textFieldBnGrpName`;
	}
	
	switch($uiItem){
		case "UpLegSplit": $ret = string(`intSliderGrp -q -v abRTUpLegSplitIntSldrGrp`); break;
		case "SpineJnts": $ret = string(`intSliderGrp -q -v abRTSpineJntsIntSldrGrp`); break;
		case "UpArmSplit": $ret = string(`intSliderGrp -q -v abRTUpArmSplitIntSldrGrp`); break;
		case "ForeArmSplit": $ret = string(`intSliderGrp -q -v abRTForeArmSplitIntSldrGrp`); break;
		case "AlignHandIK": $ret = string(`checkBox -q -v abRTAlignHandIKChkBx`); break;
		case "OrientSpineCtrls": $ret = string(`checkBox -q -v abRTOrientSpineCtrlsChkBx`); break;
	}
	
	return $ret;
	
}


global proc abRTSetUITxtFld(string $uiName, string $obj){
	// sets text field named "abRT"+capitalizeString($caller)+"TxFldBnGrp" to $obj (if it exists)
	
	if (`objExists $obj`){
		string $aStr[] = `ls -long $obj`;
		$obj = $aStr[0];
		string $textField = "abRT"+capitalizeString($uiName)+"TxFldBnGrp";
		if (`textFieldButtonGrp -q -e $textField`){
			textFieldButtonGrp -e -text $obj $textField;
		}
	}
	
}


global proc abRTClearUIItems(){
	// clears all (but name) UI fields.  Called on create skeleton (in main ui) click
	
	string $aItems[] = {"masterScaleJnt","rootCtrl","spineRoot","hip","cogCtrl","lowSpineCtrl","midSpineCtrl","hiSpineCtrl","spineSplitCtrl","neck","head","eye","neckCtrl","headCtrl","hipCtrl","upLeg","heelLoc","lfLegIkCtrl","rtLegIkCtrl","upArm","lfArmIkCtrl","rtArmIkCtrl","handCtrl","lfHandCtrl","rtHandCtrl","thumb","index","middle","ring","pinky","pinkyCup","ringCup"};
	
	string $item;
	
	for ($item in $aItems) textFieldButtonGrp -e -text "" ("abRT"+capitalizeString($item)+"TxFldBnGrp");
	
	abRTGuessUIItems();
}


global proc abRTCheckUIItems(string $selObj){
	// runs through UI fields and checks to see if selected items still exist.  Called on new selection and button click
	// removes selObj (if != "") from any fields it's in to prevent selecting the same object for multiple fields
	
	string $aItems[] = {"masterScaleJnt","rootCtrl","spineRoot","hip","cogCtrl","lowSpineCtrl","midSpineCtrl","hiSpineCtrl","spineSplitCtrl","neck","head","eye","neckCtrl","headCtrl","hipCtrl","upLeg","heelLoc","lfLegIkCtrl","rtLegIkCtrl","upArm","lfArmIkCtrl","rtArmIkCtrl","handCtrl","lfHandCtrl","rtHandCtrl","thumb","index","middle","ring","pinky","pinkyCup","ringCup"};
	
	string $item, $uiValue;
	
	for ($item in $aItems){
		
		$uiValue = abRTGetFromUI($item);
		if (!`objExists $uiValue` || $uiValue == $selObj){
			textFieldButtonGrp -e -text "" ("abRT"+capitalizeString($item)+"TxFldBnGrp");
		}
	}
}


global proc abRTGuessUIItems(){
	// attempts to fill in various important hidden UI items when called using name matching
	
	string $charName = abRTGetGlobal("name");
	string $ctrl;
	
	string $aNameSuffix[] = {
		"spineSplitCtrl","_spineSplitRot_ctrl",
		"rootCtrl","_root_ctrl",
		"hiSpineCtrl","_spineHigh_ctrl",
		"midSpineCtrl","_spineMid_ctrl",
		"lowSpineCtrl","_spineLow_ctrl",
		"cogCtrl","_cog_ctrl",
		"hipCtrl","_hip_ctrl",
		"headCtrl","_head_fk_ctrl",
		"neckCtrl","_neck_fk_ctrl",
		"spineRoot","_spine_low_jnt",
		"hip","_hip_jnt",
		"neck","_neck_jnt",
		"head","_head_a_jnt",
		"eye","_lf_eye_jnt",
		
		"upLeg","_lf_upLeg_jnt",
		"heelLoc","_lf_heel_loc",
		
		"upArm","_lf_upArm_jnt",
		
		"handCtrl","_lf_hand_ctrl",
		"thumb","_lf_thumb_a_jnt",
		"index","_lf_index_a_jnt",
		"middle","_lf_middle_a_jnt",
		"ring","_lf_ring_a_jnt",
		"pinky","_lf_pinky_a_jnt",
		"pinkyCup","_lf_pinkyCup_jnt",
		"ringCup","_lf_ringCup_jnt", 
		
		"lfHandCtrl","_lf_hand_ctrl",
		"rtHandCtrl","_rt_hand_ctrl",
		
		"lfLegIkCtrl","_lf_heel_ik_ctrl",
		"rtLegIkCtrl","_rt_heel_ik_ctrl",
		
		"lfArmIkCtrl","_lf_arm_ik_ctrl",
		"rtArmIkCtrl","_rt_arm_ik_ctrl"
	};
	
	int $i;
	for ($i=0;$i<size($aNameSuffix);$i+=2){
		
		if (abRTGetFromUI($aNameSuffix[$i]) == ""){
			$ctrl = $charName+$aNameSuffix[$i+1];
			if (`objExists $ctrl`) abRTSetUITxtFld($aNameSuffix[$i], $ctrl);
		}
		
	}
	
	// guess number of split joints
	int $int;
	
	string $upLeg = abRTGetFromUI("upLeg");
	if ($upLeg != ""){
		$int = size(`listRelatives -ad -type joint $upLeg`) - 4;
		intSliderGrp -e -v $int abRTUpLegSplitIntSldrGrp;
	}
	
	int $elbowFound = false;
	int $upArmSplitJntNum, $elbowSplitJntNum;
	string $aArmJnts[], $matchStr;
	string $upArm = abRTGetFromUI("upArm");
	if ($upArm != ""){
		$aArmJnts = abRTGetHierarchy($upArm, "", false);
		$matchStr = $charName+"_["+(abRTGetGlobal("leftPrefix"))+(abRTGetGlobal("rightPrefix"))+"]+elbow_jnt";
		
		for ($i=1;$i<(size($aArmJnts) - 2);$i++){
			if (!$elbowFound && `match $matchStr (abRTStripPath($aArmJnts[$i]))` == abRTStripPath($aArmJnts[$i])){
				// we've found the elbow!
				$elbowFound = true;
				
				$upArmSplitJntNum = $i-1;
				$elbowSplitJntNum = size($aArmJnts) - $i - 3;
				
				intSliderGrp -e -v $upArmSplitJntNum abRTUpArmSplitIntSldrGrp;
				intSliderGrp -e -v $elbowSplitJntNum abRTForeArmSplitIntSldrGrp;
				
				break;
			}
		}
	}
	
}

global proc string abRTGetDeleteMeGrpName(){
	// returns name of group to be used as a trash can for transforms to delete once the rig is built (like heelLocs).  The null will be created if it doesn't exist
	
	string $grp = abRTGetGlobal("deleteMeGrp");
	if (!(`objExists $grp`)) group -name $grp -em -w;
	
	return $grp;
	
}


global proc string abRTSwapSidePrefix(string $str){
	// swaps all occurences of left or right prefix with opposite
	
	string $lfPre = abRTGetGlobal("leftPrefix");
	string $rtPre = abRTGetGlobal("rightPrefix");
	string $ret, $regEx, $replace;
	int $match = false;
	
	if (`match $lfPre $str` == $lfPre){
		$match = true;
		$regEx = $lfPre;
		$replace = $rtPre;
	}else if (`match $rtPre $str` == $rtPre){
		$match = true;
		$regEx = $rtPre;
		$replace = $lfPre;
	}
	
	if ($match) $ret = abRTSubstituteAll($regEx, $str, $replace);
	
	return $ret;
	
}


global proc string abRTSubstituteAll(string $regEx, string $subject, string $replace){
	// like substitute all, but will replace all occurences of $regEx in $subject with $replace
	
	string $ret, $lastSubject;
	string $str = $subject;
	
	while ($str != $lastSubject){
		$lastSubject = $str;
		$str = `substitute $regEx $str $replace`;
	}
	
	$ret = $str;
	
	return $ret;
}


global proc string abRTGetObjSide(string $obj){
	/*
	returns "l", "r", or "" based on x trans of given joint (rigs must be symmetrical across YZ and facing forward in Z)
	will return nothing if $obj.tx is within tolerance of origin
	*/
	
	string $ret;
	float $tol = .0001;
	
	string $tLoc = abRTMakeLocator("abGetObjSide_loc");
	select -r $obj $tLoc;
	abRTPointOrient(1);
	select -clear;
	float $aTrans[] = `xform -q -ws -t $tLoc`;
	delete $tLoc;
	
	float $tx = $aTrans[0];
	
	if ($tx > $tol){
		$ret = "l";
	}else if ($tx < -$tol){
		$ret = "r";
	}
	
	return $ret;
}


global proc string abRTRigNamer(string $locKey, string $prefix, string $objType, int $useLocKeyAsName){
	/*
	returns a string with a name for an object based on:
	$locKey = global keyword for object name in hierarchy "hip", "upLeg", etc, unless $useLocKeyAsName is true, in which case $locKey will be used as the name
	$prefix = "l", "r", or ""
	$objType can be "ctrl" (curve controller), "jnt" (regular joint skin will be weighted to), "ikJnt" (joint for ik), "fkkJnt" (joint for fk),
	"utilJnt" (utility joint)
	*/
	
	string $rigName = abRTGetGlobal("name");
	
	if ($prefix == "l"){
		$prefix = abRTGetGlobal("leftPrefix");
	}else if ($prefix == "r"){
		$prefix = abRTGetGlobal("rightPrefix");
	}
	string $locName = ($useLocKeyAsName) ? $locKey : abRTGetGlobal($locKey);
	string $newName = $rigName+"_"+$prefix+$locName;
	string $suf;
	
	switch($objType){
		case "ctrl": $suf = "ctrl"; break;
		case "ikCtrl": $suf = "ik_ctrl"; break;
		case "fkCtrl": $suf = "fk_ctrl"; break;
		case "jnt": $suf = "jnt"; break;
		case "ikJnt": $suf = "ik_jnt"; break;
		case "fkJnt": $suf = "fk_jnt"; break;
		case "rvRigJnt": $suf = "rev_rig_jnt"; break;
		case "utilJnt": $suf = "ut_jnt"; break;
		case "loc": $suf = "loc"; break;
		case "grp": $suf = "grp"; break;
		case "rigGrp": $suf = "rig_grp"; break;
		case "refJnt": $suf = "ref_jnt"; break;
		case "ikHndl": $suf = "ikHandle"; break;
		case "pvCtrl": $suf = "pv_ctrl"; break;
		case "pvCons": $suf = "pv_cons"; break;
		case "orCons": $suf = "or_cons"; break;
		case "ptCons": $suf = "pt_cons"; break;
		case "aimCons": $suf = "aim_cons"; break;
		case "lineLoc": $suf = "line_loc"; break;
		case "fkPtCons": $suf = "fk_pt_cons"; break;
		case "fkParCons": $suf = "fk_par_cons"; break;
		case "fkPlsmns": $suf = "fk_plusMinus"; break;
		case "fkOrCons": $suf = "fk_or_cons"; break;
		case "ikOrCons": $suf = "ik_or_cons"; break;
		case "spcSwtchGrp": $suf = "space_switch_grp"; break;
		case "cond": $suf = "cond"; break;
		case "clmp": $suf = "clamp"; break;
		case "plsmns": $suf = "plusMinus"; break;
		case "rvrs": $suf = "reverse"; break;
		case "blnd": $suf = "blend"; break;  
		case "mltDiv": $suf = "multDiv"; break;
		default: $suf = $objType; break;
	}
	
	$newName += "_"+$suf;
	
	return $newName;
}


global proc string[] abRTRename(string $fullPath, string $newName){
	/*
	renames $obj (send fullPath) to $newName
	returns string[] where $aRet[0] = object's new name, $aRet[1] = objects new path with name, $aRet[2] = objects new path not including name
	*/
	
	string $aRet[];
	
	$fullPath = longNameOf($fullPath);
	
	string $newName = `rename $fullPath $newName`;
	string $aStr[] = stringToStringArray($newName, "|");
	$newName = $aStr[size($aStr)-1];
	
	$aStr = stringToStringArray($fullPath, "|");
	$aStr[size($aStr)-1] = $newName;
	string $newLongName = stringArrayToString($aStr, "|");
	
	int $i;
	string $newPath;
	for ($i=0;$i<(size($aStr)-1);$i++){
		if ($i>0) $newPath += "|";
		$newPath += $aStr[$i];
	}
	
	$aRet[size($aRet)] = $newName;
	$aRet[size($aRet)] = "|"+$newLongName;
	$aRet[size($aRet)] = "|"+$newPath;
	
	return $aRet;
}


global proc string abRTParent(string $child, string $parent){
	// parents $child to $parent and returns new full path of $child
	
	string $ret;
	
	string $aStr[] = `ls -long $parent`;
	$parent = $aStr[0];
	$aStr = `ls -long $child`;
	$child = $aStr[0];
	
	if (firstParentOf($child) != $parent){
		$aStr = `parent $child $parent`;
		$ret = $parent+"|"+abRTStripPath($aStr[0]);
	}else{
		$ret = $child;
	}
	
	return $ret;
}


global proc abRTServiceUI(string $caller){
	/*
	updates globals and fields when a joint is specified in the UI
	$caller gives the info as to what control called this proc
	*/
	
	int $badSel;
	string $selObj;
	string $aSel[] = `ls -sl -long`;
	
	if (size($aSel) == 1){
		$selObj = $aSel[0];
		abRTCheckUIItems($selObj);
	}else{
		$badSel = true;
	}
	
	if (!$badSel){
		
		int $i, $int;
		string $aJnts[], $jnt, $newName, $aNewName[], $fieldStr, $aRel[], $aStr[];
		
		$aRel = `listRelatives -ad -fullPath $selObj`;
		
		switch($caller){
			case "upLeg": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTUpLegTxFldBnGrp; break;
			case "upArm": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTUpArmTxFldBnGrp; break;
			case "heelLoc": if (`nodeType $selObj` == "transform" || `nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTHeelLocTxFldBnGrp; break;
			
			
			case "spineRoot":
			float $float;
			if (`nodeType $selObj` == "joint"){
				$float = `getAttr ($selObj+".tx")`;
				if ((abs($float)) <= .0000000000001){
					textFieldButtonGrp -e -text $selObj abRTSpineRootTxFldBnGrp;
				}else{
					warning "Root joint must have a x translate of 0.";
					$badSel = true;
				}
			}
			break;
			
			case "hip": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTHipTxFldBnGrp; else $badSel = true; break;
			case "neck": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTNeckTxFldBnGrp; else $badSel = true; break;
			case "head": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTHeadTxFldBnGrp; else $badSel = true; break;
			case "eye": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTEyeTxFldBnGrp; else $badSel = true; break;
			
			case "handCtrl": if (`nodeType $selObj` == "transform" && `nodeType $aRel[0]` == "nurbsCurve") textFieldButtonGrp -e -text $selObj abRTHandCtrlTxFldBnGrp; else $badSel = true; break;
			case "thumb": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTThumbTxFldBnGrp; else $badSel = true; break;
			case "index": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTIndexTxFldBnGrp; else $badSel = true; break;
			case "middle": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTMiddleTxFldBnGrp; else $badSel = true; break;
			case "ring": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTRingTxFldBnGrp; else $badSel = true; break;
			case "pinky": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTPinkyTxFldBnGrp; else $badSel = true; break;
			case "ringCup": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTRingCupTxFldBnGrp; else $badSel = true; break;
			case "pinkyCup": if (`nodeType $selObj` == "joint") textFieldButtonGrp -e -text $selObj abRTPinkyCupTxFldBnGrp; else $badSel = true; break;
			
		}
	}
	
	if ($badSel){
		
		string $textFieldBnGrpName = "abRT"+capitalizeString($caller)+"TxFldBnGrp";
		if (`textFieldButtonGrp -q -exists $textFieldBnGrpName`) textFieldButtonGrp -e -text "" $textFieldBnGrpName;
		
		if (size($aSel) > 1) warning "Select only one object";
	}
}


global proc abRTServiceUIButton(string $caller){
	
	abRTCheckUIItems("");
	int $result;
	int $autoMirror = int(abRTGetGlobal("autoMirror"));
	
	if (`currentUnit -q -linear` != "cm"){
		warning "The rig can't be built unless your linear working unit is set to centimeter.  Change it in Window > Settings/Preferences > Preferences > Settings and try again.  You can always change back to your preferred setting once the rig has been built.";
		return;
	}
	
	if (exists("softSelect")){
		if (`softSelect -q -softSelectEnabled`){
			print "Disabled softSelection.\n";
			softSelect -softSelectEnabled false;
		}
	}
	
	switch($caller){
		case "createLeg":
		
		string $upLeg = abRTGetFromUI("upLeg");
		string $heelLoc = abRTGetFromUI("heelLoc");
		if ($upLeg != "" && $heelLoc != ""){
			
			$result = abRTRigLeg($upLeg, $heelLoc);
			
			if ($result == true && $autoMirror){
				// rig mirror
				$upLeg = abRTGetMirrorObj($upLeg);
				$heelLoc = abRTGetMirrorObj($heelLoc);
				
				if ($upLeg != "" && $heelLoc != ""){
					abRTRigLeg($upLeg, $heelLoc);
				}
			}
			abRTRRPopulateScrollList();
		}else{
			warning "All fields must be filled.";
		}
		
		break;
		
		case "createSpine": 
		
		string $spineRoot = abRTGetFromUI("spineRoot");
		string $hip = abRTGetFromUI("hip");
		
		if ($spineRoot != "" && $hip != ""){
			abRTRigSpine($spineRoot, $hip);
			abRTRRPopulateScrollList();
		}else{
			warning "All fields must be filled.";
		}
		
		
		break;
		
		case "createHead": 
		
		string $neck = abRTGetFromUI("neck");
		string $head = abRTGetFromUI("head");
		
		if ($neck != "" && $head != ""){
			abRTRigHead($neck, $head);
			abRTRRPopulateScrollList();
		}else{
			warning "All fields must be filled.";
		}
		
		break;
		
		case "createArm": 
		
		string $upArm = abRTGetFromUI("upArm");
		
		if ($upArm != ""){
			$result = abRTRigArm($upArm);
			
			if ($result == true && $autoMirror){
				// rig mirror
				$upArm = abRTGetMirrorObj($upArm);
				
				if ($upArm != ""){
					abRTRigArm($upArm);
				}
			}
			abRTRRPopulateScrollList();
			abRTGuessUIItems(); // used to capture hand ctrl curve
		}else{
			warning "All fields must be filled.";
		}
		
		break;
		
		case "createHand": 
		
		string $handCtrl = abRTGetFromUI("handCtrl");
		string $thumb = abRTGetFromUI("thumb");
		string $index = abRTGetFromUI("index");
		string $middle = abRTGetFromUI("middle");
		string $ring = abRTGetFromUI("ring");
		string $pinky = abRTGetFromUI("pinky");
		string $pinkyCup = abRTGetFromUI("pinkyCup");
		string $ringCup = abRTGetFromUI("ringCup");
		
		if ($handCtrl != "" && $thumb != "" && $index != ""){
			$result = abRTRigHand($handCtrl, $thumb, $index, $middle, $ring, $pinky, $pinkyCup, $ringCup);
			
			if ($result == true && $autoMirror){
				// rig mirror
				$handCtrl = abRTGetMirrorObj($handCtrl);
				$thumb = abRTGetMirrorObj($thumb);
				$index = abRTGetMirrorObj($index);
				$middle = abRTGetMirrorObj($middle);
				$ring = abRTGetMirrorObj($ring);
				$pinky = abRTGetMirrorObj($pinky);
				$pinkyCup = abRTGetMirrorObj($pinkyCup);
				$ringCup = abRTGetMirrorObj($ringCup);
				
				if ($handCtrl != "" && $thumb != "" && $index != ""){
					abRTRigHand($handCtrl, $thumb, $index, $middle, $ring, $pinky, $pinkyCup, $ringCup);
				}
			}
			abRTRRPopulateScrollList();
		}else{
			warning "You need to specify a hand ctrl and thumb and index joints.";
		}
		
		break;
		
		case "handQuickSel": 
		
		string $aSel[] = `ls -sl`;
		
		if (size($aSel) > 0){
			string $aHandUiNames[] = {"thumb","index","middle","ring","pinky","pinkyCup","ringCup"};
			string $aRel[] = `listRelatives -type shape $aSel[0]`;
			if (size($aRel) > 0 && `nodeType $aRel[0]` == "nurbsCurve"){
				
				abRTSetUITxtFld("handCtrl", $aSel[0]);
				
				if (abRTGetObjSide($aSel[0]) == "l") abRTSetUITxtFld("lfHandCtrl", $aSel[0]);
				else abRTSetUITxtFld("rtHandCtrl", $aSel[0]);
				
				int $i;
				int $ok = true;
				int $entryNum = min((size($aSel)), (size($aHandUiNames)+1));
				
				for ($i=1;$i<$entryNum;$i++){
					if (`nodeType $aSel[$i]` != "joint"){
						$ok = false;
						break;
					}else{
						abRTSetUITxtFld(($aHandUiNames[($i-1)]), $aSel[$i]);
					}
				}
				
				if (!$ok) warning "All but the first selected item must be joints.";
				
			}else{
				warning "The first selection must be a nurbsCurve.";
			}
		}
		
		break;
		
	}
}


global proc abRTServiceNameFld(){
	// ensures that the name field is correctly filled
	
	string $name = `textFieldGrp -q -text abRTNameTxFldGrp`;
	if (isValidObjectName($name)){
		abRTSetGlobal("name",$name);
	}else{
		textFieldGrp -e -text (abRTGetGlobal("name")) abRTNameTxFldGrp;
	}
	
	// clear UI items
	abRTClearUIItems();
}


global proc abRTGetCurveInfo(){
	
	string $aSel[] = `ls -sl`;
	string $obj, $cmdStr, $tCmdStr;
	$cmdStr = "switch($wireType){\n";
	for ($obj in $aSel){
		setAttr ($obj+".tx") 0;
		setAttr ($obj+".ty") 0;
		setAttr ($obj+".tz") 0;
		$cmdStr += "case \""+$obj+"\": $directions = \""+re_getCurvePointInfo($obj)+"\"; break;";
		$cmdStr += "\n";
	}
	$cmdStr += "}";
	
	print $cmdStr;
	
}


global proc string re_getCurvePointInfo(string $curve){
	// I found this proc online at http://ryane.com
	
	int $degree = `getAttr ($curve+".degree")`;
	
	select ($curve+".cv[*]");
	string $allPoints[] = `filterExpand -ex true -sm 28`;
	
	string $curveStart = ("curve -d "+$degree);
	
	for ($i = 0; `size($allPoints)` > $i; ++$i)
	{
		float $loc[] = `xform -q -ws -t $allPoints[$i]`;
		$curveStart += (" -p "+ $loc[0]+ " "+ $loc[1]+ " "+ $loc[2]);
	}
	
	return $curveStart;
}


global proc gmDeleteConnection(string $destName){
	// If the specified name is the destination of a connection,
	// then delete that connection.
	
	if ( `connectionInfo -isDestination $destName` ){
		string $destination = `connectionInfo -getExactDestination $destName`;
		// When deleting a src connection from a character, you must remove
		// the item from the character set or the character will no longer
		// work consistently: bug 127212
		string $srcConn[] = `listConnections -s 1 -d 0 -type character $destination`;
		if (size($srcConn)) {
			string $warnMsg = ("Removed \'"+$destination+"\' from character \'"+$srcConn[0]+"\'.");
			warning($warnMsg);
			character -e -rm $srcConn[0] $destination;
		}
		
		// delete -icn doesn't work if destination attr is readOnly
		// so use disconnectAttr in this case
		string $sArr[1] = `ls -ro $destination`;
		if (size($sArr)) {
			string $src = `connectionInfo -sourceFromDestination $destination`;
			disconnectAttr $src $destination;
		} else {
			delete -icn $destination;
		}
	}
}


global proc string[] abRTJointHierarchyRenamer(string $selJnt, string $endJnt, string $aJntGlobalNames[], int $useGlobalNamesAsNames){
	/*
	$selJnt is a selected joint at the top of a non forking hierarchy
	$endJnt is joint to stop at -- can be left "" to drill down to bottom of hierarchy
	$aJntGlobalNames are the names of the variables that hold the user defined names for the joints (using abRTGetGlobal(globalName)) unles $useGlobalNamesAsNames is true, in which case the contents of $aJntGlobalNames will be used as the joint names
	this proc will rename the hierarchy to the appropriate names
	it's usually called when a joint select field in the UI is clicked.
	returns new joint names on success or an empty array on failure
	*/
	
	int $i, $useGlblNm;
	string $aRet[], $aNewName[], $newName, $jnt, $jntSide;
	
	if (`nodeType $selJnt` == "joint"){
		
		string $aJnts[] = abRTGetHierarchy($selJnt, $endJnt, true);
		if (size($aJnts) == size($aJntGlobalNames)){
			
			$jntSide = abRTGetObjSide($selJnt);
			for ($i=0;$i<size($aJntGlobalNames);$i++){
				
				$useGlblNm = 1 - ($useGlobalNamesAsNames && abRTGetGlobal($aJntGlobalNames[$i]) != ""); // if there's no matching global use the key as a name
				$newName = abRTRigNamer($aJntGlobalNames[$i], $jntSide, "jnt", $useGlblNm);
				$jnt = ($i==0) ? $aJnts[0] : $aJnts[$i-1]+"|"+abRTStripPath($aJnts[$i]);
				$aNewName = abRTRename($jnt, $newName);
				$aJnts[$i] = $aNewName[1];
				
			}
			
			$aRet = $aJnts;
		}else{
			warning ("There should only be "+size($aJntGlobalNames)+" joints (including the first) in the hierarchy");
		}
	}
	
	return $aRet;
}


global proc abAutoRig(){
	// make main rig tool ui
	
	global int $abRTInit;
	
	if ($abRTInit != true) abRTInit();
	
	if (`window -exists abRTWin`){
		deleteUI -window abRTWin;
	}
	
	string $vNum = abRTGetGlobal("versionNum");
	string $str;
	
	window -t ("abAutoRig "+$vNum) -w 324 -h 386 -menuBar true -minimizeButton false -maximizeButton false abRTWin;
	
	int $autoMirror = int(abRTGetGlobal("autoMirror"));
	
	menu -label "Options" -postMenuCommand "" abRTOptionsOpMn;
	
	menuItem -label "Auto Mirror" -checkBox $autoMirror -command "abRTToggleMenuItem(\"abRTAutoMirMnIt\", \"autoMirror\");" abRTAutoMirMnIt;
	
	menuItem -label "Hand Options" -sm true abRTHandOptionsMnIt;
	
	$str = abRTGetGlobal("thumbCurlSpreadRoll");
	
	menuItem -label "Thumb Curl Spread Roll Axes" -p abRTHandOptionsMnIt -sm true abRTThumbCurlSpreadRollMnIt;
	radioMenuItemCollection;
	menuItem -l "xyz" -rb ($str == "xyz") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"xyz\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "yzx" -rb ($str == "yzx") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"yzx\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "zxy" -rb ($str == "zxy") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"zxy\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "xzy" -rb ($str == "xzy") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"xzy\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "yxz" -rb ($str == "yxz") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"yxz\");") -p abRTThumbCurlSpreadRollMnIt;
	menuItem -l "zyx" -rb ($str == "zyx") -c ("abRTSetGlobal(\"thumbCurlSpreadRoll\",\"zyx\");") -p abRTThumbCurlSpreadRollMnIt;
	
	setParent ..;
	
	$str = abRTGetGlobal("fingerCurlSpreadRoll");
	
	menuItem -label "Finger Curl Spread Roll Axes" -p abRTHandOptionsMnIt -sm true abRTFingerCurlSpreadRollMnIt;
	radioMenuItemCollection;
	menuItem -l "xyz" -rb ($str == "xyz") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"xyz\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "yzx" -rb ($str == "yzx") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"yzx\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "zxy" -rb ($str == "zxy") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"zxy\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "xzy" -rb ($str == "xzy") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"xzy\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "yxz" -rb ($str == "yxz") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"yxz\");") -p abRTFingerCurlSpreadRollMnIt;
	menuItem -l "zyx" -rb ($str == "zyx") -c ("abRTSetGlobal(\"fingerCurlSpreadRoll\",\"zyx\");") -p abRTFingerCurlSpreadRollMnIt;
	
	setParent ..;
	
	$str = abRTGetGlobal("fingerCupAxis");
	
	menuItem -label "Finger Cup Axis" -p abRTHandOptionsMnIt -sm true abRTFingerCupAxisMnIt;
	radioMenuItemCollection;
	menuItem -l "x" -rb ($str == "x") -c ("abRTSetGlobal(\"fingerCupAxis\",\"x\");") -p abRTFingerCupAxisMnIt;
	menuItem -l "y" -rb ($str == "y") -c ("abRTSetGlobal(\"fingerCupAxis\",\"y\");") -p abRTFingerCupAxisMnIt;
	menuItem -l "z" -rb ($str == "z") -c ("abRTSetGlobal(\"fingerCupAxis\",\"z\");") -p abRTFingerCupAxisMnIt;
	
	setParent ..;
	
	menuItem -divider true -p abRTHandOptionsMnIt;
	menuItem -l "Reverse Right Curl" -cb (int(abRTGetGlobal("reverseFingerCurl"))) -c ("abRTSetGlobal(\"reverseFingerCurl\",(1-int(abRTGetGlobal(\"reverseFingerCurl\"))));") -p abRTHandOptionsMnIt abRTReverseFingerCurlMnIt;
	
	setParent ..;
	
	
	menu -label "Tools" -postMenuCommand "";
	menuItem -label "Skeleton Maker" -command "abRTSkeletonMaker();";
	menuItem -label "Wire Replacer" -command "abRTWireReplaceUI();";
	menuItem -label "Rig Remover" -command "abRTRigRemover();";
	menuItem -label "Space Switch Matcher" -command "abRTSpaceSwitchWindow();";
	menuItem -label "Joint Orient Rotation Tool" -command "abRTRotateOrientUI();";
	menuItem -label "Change Rotation Order Tool" -command "abRTChangeRotOrderWindow();";
	menuItem -label "Add Weight Joint Tool" -command "abRTAddWeightJointUI();";
	menuItem -divider true;
	menuItem -label "Stretchy Spline From Curve" -command "abRTMakeStretchySplineWin();";
	menuItem -divider true;
	menuItem -label "Quick Create Character Set" -ann "Creates a character set for all of your character's animatable attributes.  Select any one of your character control curves first." -command "abRTMakeCharSetFromSel();";
	menuItem -divider true;
	menuItem -label "Save Wires To Shelf" -ann "Save your modified wires to a shelf button for later recall.  Select any one of your character control curves first." -command "abRTCaptureControlCurves();";
	menuItem -divider true;
	menuItem -label "Reset Character to Default Pose" -ann "Reset a character to its default pose.  Select any one of your character control curves first." -command "abRTResetCharPose(1);";
	menuItem -label "Reset Selected Control Curves to Default" -ann "Reset selected control curves to their default pose.  Highlight entries in the ChannelBox to revert selected attributes." -command "abRTResetCharPose(0);";
	
	
	menu -label "Help" -postMenuCommand "";
	menuItem -label "Online Help" -command "showHelp -a \"http://www.supercrumbly.com/archives.php?sid=173\"";
	
	int $lmargin = 3;
	int $rmargin = 3;
	int $lCol = 70;
	int $cCol = 100;
	int $rCol = 60;
	
	formLayout -numberOfDivisions 100 abRTForm;
	
	tabLayout -innerMarginWidth 0 -innerMarginHeight 0 abRTTabLayout;
	
	// start form
	formLayout -numberOfDivisions $cCol abRTStartTabForm;
	textFieldGrp -label "Char Name:" -text (abRTGetGlobal("name")) -columnWidth2 $lCol $cCol -adjustableColumn2 2 -cc "abRTServiceNameFld();" abRTNameTxFldGrp;
	textFieldButtonGrp -ed false -manage false -label "Master Scale Jnt:" -text "" abRTMasterScaleJntTxFldBnGrp; // used to determine if masterscale has been set for a skeleton
	
	button -label "Create a Skeleton" -h 28 -c "abRTClearUIItems();abRTSkeletonMaker();" abRTCreateSkeletonBn;
	
	
	// spine form
	setParent ..;
	string $name = abRTGetGlobal("name");
	formLayout -numberOfDivisions $cCol abRTSpineTabForm;
	intSliderGrp -label "Spine Joints:" -min 4 -max 18 -v 8 -field true -columnWidth3 $lCol 40 100 -adjustableColumn3 3 -ann "Select the number of joints you want on the ik spine." abRTSpineJntsIntSldrGrp;
	textFieldButtonGrp -ed false -label "Spine Root:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"spineRoot\");" -ann "Select the root spine joint." abRTSpineRootTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Hip:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"hip\");" -ann "Select the hip joint." abRTHipTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Root Ctrl:" -text "" abRTRootCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Hip Ctrl:" -text "" abRTHipCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Cog Ctrl:" -text "" abRTCogCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Low Spine Ctrl:" -text "" abRTLowSpineCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Mid Spine Ctrl:" -text "" abRTMidSpineCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Hi Spine Ctrl:" -text "" abRTHiSpineCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -label "Spine/Split Rot Ctrl:" -text "" abRTSpineSplitCtrlTxFldBnGrp;
	checkBox -label "Align Control Curves to Spine" -value 0 -ann "If enabled, the mid and high spine control curves will be oriented to their respective spine joints; otherwise they'll lie on the XZ plane." abRTOrientSpineCtrlsChkBx;
	
	button -label "Create Spine Rig" -h 28 -c "abRTServiceUIButton(\"createSpine\");" abRTCreateSpineBn;
	
	
	// head form
	setParent ..;
	formLayout -numberOfDivisions $cCol abRTHeadTabForm;
	textFieldButtonGrp -ed false -label "Neck:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"neck\");" -ann "Select the neck joint." abRTNeckTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Head:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"head\");" -ann "Select the head joint." abRTHeadTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Eye:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"eye\");" -ann "Select an eye joint." abRTEyeTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -eb false -label "Neck Ctrl:" -text "" abRTNeckCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -eb false -label "Head Ctrl:" -text "" abRTHeadCtrlTxFldBnGrp;
	
	button -label "Create Head Rig" -h 28 -c "abRTServiceUIButton(\"createHead\");" abRTCreateHeadBn;
	
	
	// leg form
	setParent ..;
	formLayout -numberOfDivisions $cCol abRTLegTabForm;
	intSliderGrp -label "UpLeg Split:" -min 0 -max 2 -v 0 -field true -columnWidth3 $lCol 40 100 -adjustableColumn3 3 abRTUpLegSplitIntSldrGrp;
	textFieldButtonGrp -ed false -label "UpLeg:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"upLeg\");" abRTUpLegTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Heel Loc:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"heelLoc\");" abRTHeelLocTxFldBnGrp;
	button -label " Create Heel Locator " -c "abRTMakeHeelLoc();" abRTcreateHeelLocBn;
	checkBox -label "Create Mirror Loc" -value 1 abRTCreateBothHeelLocChkBx;
	
	textFieldButtonGrp -ed false -manage false -eb false -label "LfLegIkCtrl:" -text "" abRTLfLegIkCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -eb false -label "RtLegIkCtrl:" -text "" abRTRtLegIkCtrlTxFldBnGrp;
	
	button -label "Create Leg Rig" -h 28 -c "abRTServiceUIButton(\"createLeg\");" abRTCreateLegBn;
	
	
	// arm form
	setParent ..;
	formLayout -numberOfDivisions $cCol abRTArmTabForm;
	intSliderGrp -label "UpArm Split:" -min 0 -max 2 -v 0 -field true -columnWidth3 $lCol 40 100 -adjustableColumn3 3 abRTUpArmSplitIntSldrGrp;
	intSliderGrp -label "Fore Split:" -min 0 -max 2 -v 0 -field true -columnWidth3 $lCol 40 100 -adjustableColumn3 3 abRTForeArmSplitIntSldrGrp;
	textFieldButtonGrp -ed false -label "Up Arm:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"upArm\");" abRTUpArmTxFldBnGrp;
	checkBox -label "Align Hand IK to World Axes" -value 0 -ann "If enabled, the IK control will be aligned to the world axes, however its rotation channels will be locked."  abRTAlignHandIKChkBx;
	
	textFieldButtonGrp -ed false -manage false -eb false -label "LfArmIkCtrl:" -text "" abRTLfArmIkCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -eb false -label "RtArmIkCtrl:" -text "" abRTRtArmIkCtrlTxFldBnGrp;
	
	button -label "Create Arm Rig" -h 28 -c "abRTServiceUIButton(\"createArm\");" abRTcreateArmBn;
	
	
	// hand form
	setParent ..;
	formLayout -numberOfDivisions $cCol abRTHandTabForm;
	textFieldButtonGrp -ed false -label "Hand Ctrl:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"handCtrl\");" -ann "Select the hand control (must be a nurbs curve)." abRTHandCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Thumb:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"thumb\");" -ann "Select the first thumb joint (optional)." abRTThumbTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Index:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"index\");" -ann "Select the first index finger joint (optional)." abRTIndexTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Middle:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"middle\");" -ann "Select the middle finger joint (optional)." abRTMiddleTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Ring:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"ring\");" -ann "Select the first ring finger joint (optional)." abRTRingTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Pinky:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"pinky\");" -ann "Select the first pinky finger joint (optional)." abRTPinkyTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Ring Cup:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"ringCup\");" -ann "Select the ring cup joint (optional)." abRTRingCupTxFldBnGrp;
	textFieldButtonGrp -ed false -label "Pinky Cup:" -text "" -buttonLabel " Select " -columnWidth3 $lCol $cCol $rCol -adjustableColumn3 2 -bc "abRTServiceUI(\"pinkyCup\");" -ann "Select the first pinky cup joint (optional)." abRTPinkyCupTxFldBnGrp;
	button -label " Hand Quick Select " -c "abRTServiceUIButton(\"handQuickSel\");" -ann "Select controls in order that the fields on this tab are listed and press this button to fill them." abRTHandQuickSelBn;
	
	textFieldButtonGrp -ed false -manage false -eb false -label "LfHandCtrl:" -text "" abRTLfHandCtrlTxFldBnGrp;
	textFieldButtonGrp -ed false -manage false -eb false -label "RtHandCtrl:" -text "" abRTRtHandCtrlTxFldBnGrp;
	
	checkBox -label "Create Ik Finger Controls" -value 0 abRTCreateIkFingerChkBx;
	
	button -label "Create Hand Rig" -h 28 -c "abRTServiceUIButton(\"createHand\");" abRTcreateHandBn;
	
	
	formLayout -edit
	
	-af abRTTabLayout "top" 0
	-af abRTTabLayout "left" 0
	-af abRTTabLayout "right" 0
	-af abRTTabLayout "bottom" 0
	
	abRTForm
	;
	
	
	// start tab
	formLayout -edit
	
	-af abRTNameTxFldGrp "top" 14
	-af abRTNameTxFldGrp "left" $lmargin
	-af abRTNameTxFldGrp "right" ($rCol+$rmargin)
	
	-af abRTCreateSkeletonBn "bottom" 2
	-af abRTCreateSkeletonBn "left" 2
	-af abRTCreateSkeletonBn "right" 2
	
	abRTStartTabForm
	;
	
	
	// spine tab
	formLayout -edit
	
	-af abRTSpineJntsIntSldrGrp "top" 14
	-af abRTSpineJntsIntSldrGrp "left" $lmargin
	-af abRTSpineJntsIntSldrGrp "right" (60+$lmargin)
	
	-ac abRTSpineRootTxFldBnGrp "top" 4 abRTSpineJntsIntSldrGrp
	-af abRTSpineRootTxFldBnGrp "left" $lmargin
	-af abRTSpineRootTxFldBnGrp "right" $rmargin
	
	-ac abRTHipTxFldBnGrp "top" 4 abRTSpineRootTxFldBnGrp
	-af abRTHipTxFldBnGrp "left" $lmargin
	-af abRTHipTxFldBnGrp "right" $rmargin
	
	-ac abRTOrientSpineCtrlsChkBx "top" 9 abRTHipTxFldBnGrp
	-af abRTOrientSpineCtrlsChkBx "left" (70+$lmargin)
	
	-af abRTCreateSpineBn "bottom" 2
	-af abRTCreateSpineBn "left" 2
	-af abRTCreateSpineBn "right" 2
	
	abRTSpineTabForm
	;
	
	
	// head/neck tab
	formLayout -edit
	
	-af abRTNeckTxFldBnGrp "top" 14
	-af abRTNeckTxFldBnGrp "left" $lmargin
	-af abRTNeckTxFldBnGrp "right" $rmargin
	
	-ac abRTHeadTxFldBnGrp "top" 4 abRTNeckTxFldBnGrp
	-af abRTHeadTxFldBnGrp "left" $lmargin
	-af abRTHeadTxFldBnGrp "right" $rmargin
	
	-ac abRTEyeTxFldBnGrp "top" 4 abRTHeadTxFldBnGrp
	-af abRTEyeTxFldBnGrp "left" $lmargin
	-af abRTEyeTxFldBnGrp "right" $rmargin
	
	-af abRTCreateHeadBn "bottom" 2
	-af abRTCreateHeadBn "left" 2
	-af abRTCreateHeadBn "right" 2
	
	abRTHeadTabForm
	;
	
	
	// leg tab
	formLayout -edit
	
	-af abRTUpLegSplitIntSldrGrp "top" 14
	-af abRTUpLegSplitIntSldrGrp "left" $lmargin
	-af abRTUpLegSplitIntSldrGrp "right" (60+$lmargin)
	
	-ac abRTUpLegTxFldBnGrp "top" 4 abRTUpLegSplitIntSldrGrp
	-af abRTUpLegTxFldBnGrp "left" $lmargin
	-af abRTUpLegTxFldBnGrp "right" $rmargin
	
	-ac abRTHeelLocTxFldBnGrp "top" 4 abRTUpLegTxFldBnGrp
	-af abRTHeelLocTxFldBnGrp "left" $lmargin
	-af abRTHeelLocTxFldBnGrp "right" $rmargin
	
	-ac abRTcreateHeelLocBn "top" 6 abRTHeelLocTxFldBnGrp
	-af abRTcreateHeelLocBn "left" (70+$lmargin)
	
	-ac abRTCreateBothHeelLocChkBx "top" 9 abRTHeelLocTxFldBnGrp
	-ac abRTCreateBothHeelLocChkBx "left" 12 abRTcreateHeelLocBn
	
	-af abRTCreateLegBn "bottom" 2
	-af abRTCreateLegBn "left" 2
	-af abRTCreateLegBn "right" 2
	
	abRTLegTabForm
	;
	
	
	// arm tab
	formLayout -edit
	
	-af abRTUpArmSplitIntSldrGrp "top" 14
	-af abRTUpArmSplitIntSldrGrp "left" $lmargin
	-af abRTUpArmSplitIntSldrGrp "right" (60+$lmargin)
	
	-ac abRTForeArmSplitIntSldrGrp "top" 4 abRTUpArmSplitIntSldrGrp
	-af abRTForeArmSplitIntSldrGrp "left" $lmargin
	-af abRTForeArmSplitIntSldrGrp "right" (60+$lmargin)
	
	-ac abRTUpArmTxFldBnGrp "top" 4 abRTForeArmSplitIntSldrGrp
	-af abRTUpArmTxFldBnGrp "left" $lmargin
	-af abRTUpArmTxFldBnGrp "right" $rmargin
	
	-ac abRTAlignHandIKChkBx "top" 9 abRTUpArmTxFldBnGrp
	-af abRTAlignHandIKChkBx "left" (70+$lmargin)
	
	-af abRTcreateArmBn "bottom" 2
	-af abRTcreateArmBn "left" 2
	-af abRTcreateArmBn "right" 2
	
	abRTArmTabForm
	;
	
	
	// hand tab
	formLayout -edit
	
	-af abRTHandCtrlTxFldBnGrp "top" 14
	-af abRTHandCtrlTxFldBnGrp "left" $lmargin
	-af abRTHandCtrlTxFldBnGrp "right" $rmargin
	
	-ac abRTThumbTxFldBnGrp "top" 6 abRTHandCtrlTxFldBnGrp
	-af abRTThumbTxFldBnGrp "left" $lmargin
	-af abRTThumbTxFldBnGrp "right" $rmargin
	
	-ac abRTIndexTxFldBnGrp "top" 4 abRTThumbTxFldBnGrp
	-af abRTIndexTxFldBnGrp "left" $lmargin
	-af abRTIndexTxFldBnGrp "right" $rmargin
	
	-ac abRTMiddleTxFldBnGrp "top" 4 abRTIndexTxFldBnGrp
	-af abRTMiddleTxFldBnGrp "left" $lmargin
	-af abRTMiddleTxFldBnGrp "right" $rmargin
	
	-ac abRTRingTxFldBnGrp "top" 4 abRTMiddleTxFldBnGrp
	-af abRTRingTxFldBnGrp "left" $lmargin
	-af abRTRingTxFldBnGrp "right" $rmargin
	
	-ac abRTPinkyTxFldBnGrp "top" 4 abRTRingTxFldBnGrp
	-af abRTPinkyTxFldBnGrp "left" $lmargin
	-af abRTPinkyTxFldBnGrp "right" $rmargin
	
	-ac abRTPinkyCupTxFldBnGrp "top" 6 abRTPinkyTxFldBnGrp
	-af abRTPinkyCupTxFldBnGrp "left" $lmargin
	-af abRTPinkyCupTxFldBnGrp "right" $rmargin
	
	-ac abRTRingCupTxFldBnGrp "top" 4 abRTPinkyCupTxFldBnGrp
	-af abRTRingCupTxFldBnGrp "left" $lmargin
	-af abRTRingCupTxFldBnGrp "right" $rmargin
	
	-ac abRTHandQuickSelBn "top" 4 abRTRingCupTxFldBnGrp
	-af abRTHandQuickSelBn "left" ($lCol+$lmargin)
	
	-ac abRTCreateIkFingerChkBx "top" 6 abRTHandQuickSelBn
	-af abRTCreateIkFingerChkBx "left" ($lCol+$lmargin)
	
	-af abRTcreateHandBn "bottom" 2
	-af abRTcreateHandBn "left" 2
	-af abRTcreateHandBn "right" 2
	
	abRTHandTabForm
	;
	
	
	tabLayout -edit -tabLabel abRTStartTabForm "Start" -tabLabel abRTSpineTabForm "Spine" -tabLabel abRTHeadTabForm "Head/Neck" -tabLabel abRTLegTabForm "Legs/Feet" -tabLabel abRTArmTabForm "Arms" -tabLabel abRTHandTabForm "Hands" -preSelectCommand "abRTCheckUIItems(\"\");" abRTTabLayout;
	
	showWindow abRTWin;
	
	abRTGuessUIItems(); // update fields with existing ctrls
}


global proc string abRTMakeHeelLoc(){
	/*
	creates a loc to be positioned for heel joint when an upLeg joint has been selected in the UI
	actually creates two locs -- one on each side of the character
	*/
	
	abRTCheckUIItems("");
	
	string $ret, $aRel[];
	string $upLeg = abRTGetFromUI("upLeg");
	int $createMirror = `checkBox -q -value abRTCreateBothHeelLocChkBx`;
	
	if ($upLeg != ""){
		
		if (`objExists (abRTGetGlobal("deleteMeGrp"))`) delete (abRTGetGlobal("deleteMeGrp"));
		string $deleteMeGrp = abRTGetDeleteMeGrpName();
		
		string $aJnts[] = abRTGetHierarchy($upLeg, "", true);
		
		if (size($aJnts) < 5){
			warning "Your upLeg joint should be the first of a chain of no less than five joints.";
			return "";
		}
		
		$toe = $aJnts[size($aJnts)-1];
		$ball = $aJnts[size($aJnts)-2];
		$ankle = $aJnts[size($aJnts)-3];
		
		string $prefix = abRTGetObjSide($toe);
		string $newName = abRTRigNamer("heel", $prefix, "loc", 1);
		string $heelLoc = abRTMakeLocator($newName);
		
		select -r $ball $heelLoc;
		abRTPointOrient(1);
		select -d $toe;
		
		string $heelFrzGrp = abRTGroupFreeze($heelLoc, 1);
		$heelLoc = $heelFrzGrp+$heelLoc;
		
		float $aXform1[] = `xform -q -ws -t $ankle`;
		float $aXform2[] = `xform -q -ws -t $ball`;
		
		setAttr ($heelLoc+".tx") (($aXform1[2] - $aXform2[2])*1.1);
		makeIdentity -apply true -t 1 -r 1 -s 1 $heelLoc;
		setAttr -lock true ($heelLoc+".tz");
		
		setAttr ($heelLoc+".rx") 180;
		setAttr ($heelLoc+".ry") -90;
		
		if ($createMirror && $prefix != ""){
			
			string $aDupObj[] = `duplicate -rr -rc -name (abRTSwapSidePrefix($heelFrzGrp)) $heelFrzGrp`;
			string $mHeelFrzGrp = $aDupObj[0];
			
			$aRel = `listRelatives -c -fullPath $mHeelFrzGrp`;
			if (size($aRel) == 1){
				string $aMName[] = abRTRename($aRel[0], (abRTSwapSidePrefix($newName)));
				string $mHeelLoc = $aMName[1];
				
				float $aXform3[] = `xform -q -ws -t $mHeelFrzGrp`;
				setAttr ($mHeelFrzGrp+".tx") (-$aXform3[0]);
				float $aXform4[] = `xform -q -ws -ro $mHeelFrzGrp`;
				setAttr ($mHeelFrzGrp+".rx") (-($aXform4[0]+180));
				setAttr ($mHeelFrzGrp+".rz") (-($aXform4[2]+180));
				
				abRTPointConnect($heelLoc, $mHeelLoc, 3);
				
				parent $mHeelFrzGrp $deleteMeGrp;
			}
		}
		
		parent $heelFrzGrp $deleteMeGrp;
		
		$ret = $heelLoc = $deleteMeGrp+"|"+$heelLoc;
		select -r $heelLoc;
		
		abRTServiceUI("heelLoc");
		
		
	}else{
		warning "You must select an upLeg joint before you can create a heel locator.";
	}
	
	return $ret;
}


global proc abRTSetScale(string $jnt){
	// sets global scale var based on size of entire skeleton -- $jnt can be any joint in skeleton below the rootJnt
	
	string $rootJnt = abRTGetRootFromJoint($jnt);
	
	if ($rootJnt == "") return;
	
	// if a masterScaleJnt has been specified and it's the same as the rootJnt, then the global scale var is accurate
	if ($rootJnt == abRTGetFromUI("masterScaleJnt")) return;
	
	string $tJnt;
	string $aJnts[] = `listRelatives -type joint -fullPath -ad $rootJnt`;
	float $aTrans[], $minY, $maxY;
	
	string $tLoc = abRTMakeLocator("abRTFindScaleLoc");
	
	// find highest and lowest joints (in Y) to determine height of skeleton
	
	$minY = $maxY = 0;
	for ($tJnt in $aJnts){
		select -r $tJnt $tLoc;
		abRTPointOrient(1);
		select -clear;
		
		$aTrans = `xform -q -ws -t $tLoc`;
		if ($aTrans[1] > $maxY) $maxY = $aTrans[1];
		else if ($aTrans[1] < $minY) $minY = $aTrans[1];
	}
	
	delete $tLoc;
	
	float $height = $maxY - $minY;
	float $avgHeight = float(abRTGetGlobal("avgHeight"));
	float $scale = $height/$avgHeight;
	string $scaleStr = string($scale);
	abRTSetGlobal("globalScale", $scaleStr);
	
	// fill the masterScaleJnt field to flag that scale has been determined for this jnt
	
	abRTSetUITxtFld("masterScaleJnt", $rootJnt);
	
}


global proc abRTMakeRootCon(string $jnt){
	/*
	$jnt should be the root joint of the skeleton
	creates a root control and determines the appropriate scale
	assume avg height of 175 -- units are assumed to be centimeters
	*/
	
	if ($jnt != "" && `objExists $jnt` && `nodeType $jnt` == "joint"){
		
		string $rigRtGrp = abRTRigRootFolder();
		
		string $ctrl = abRTWireContoller("circle", 1, {}, 125, false);
		string $newName = abRTRigNamer("root", "", "ctrl", true);
		string $aName[] = abRTRename($ctrl, $newName);
		$ctrl = abRTParent($aName[1], $rigRtGrp);
		
		string $aPointCons[] = `pointConstraint -offset 0 0 0 -weight 1 $jnt $ctrl`;
		delete $aPointCons[0];
		setAttr ($ctrl+".ty") 0;
		makeIdentity -apply true -t 1 -r 1 -s 1 $ctrl;
		
		// add masterScale
		addAttr -ln "masterScale" -at "float" -dv 1 -keyable true -min .001 -max 10 $ctrl;
		
		// add skeleton vis att
		addAttr -ln "skeletonVis" -at bool -keyable true $ctrl;
		setAttr ($ctrl+".skeletonVis") true;
		connectAttr -f ($ctrl+".skeletonVis") ($jnt+".v");
		
		abRTSetUITxtFld("rootCtrl", $ctrl);
	}
}


global proc string abRTGetCharVarNode(){
	// returns or creates charVar node for a given character rootCon.  CharVar node contains info on the nodes created and associated with each part of the rigging process to allow easy removal of the rig.
	// charVar is a "geometryVarGroup" node with separate atts for spine, head/neck/eyes and lf and rt legs arms and hands;
	// Also holds version of script rig was created with
	// charVar is a child of the character_rig_grp
	// determines active character by nameField in UI.  If that's not consistent with name of rig group, then charVar won't be created correctly
	
	string $charName = abRTGetGlobal("name");
	
	if ($charName == ""){
		warning "Character Name is undefined.  Unable to save data to charVar node.";
		return "";
	}
	
	string $rigGrp = $charName+"_rig_grp";
	
	if (!`objExists $rigGrp` || `nodeType $rigGrp` != "transform"){
		warning ("The rig group \""+$rigGrp+"\" doesn't exist.  Unable to proceed.");
		return "";
	}
	
	string $aRel[] = `listRelatives -ad -type geometryVarGroup $rigGrp`;
	if (size($aRel) == 1){
		return $aRel[0];
	}else{
		// create the charVars node
		string $charVarNode = `createNode geometryVarGroup -n ($charName+"_charVars") -p $rigGrp`;
		addAttr -ln "versionNum" -at "float" $charVarNode;
		setAttr ($charVarNode+".versionNum") (float(abRTGetGlobal("versionNum")));
		return $charVarNode;
	}
	
}


global proc string abRTCreateNode(string $nodeType, string $baseName, string $prefix, string $limbName){
	// creates a node and records it to the character's charVars for easy rig removal
	// $nodeType is the type of node to create ("blendColors", "curveInfo", "plusMinusAverage", "multiplyDivide", "reverse", "condition", "clamp"
	// $baseName is baseName of node to be created, $prefix is "l","r", or "", and $cat is category att of charVars in which to record this node.
	// leave $limbName empty ("") to avoid it being recorded to charVars
	
	string $suffix, $cmd, $node;
	
	switch($nodeType){
		case "blendColors":$suffix="blnd";break;
		case "curveInfo":$suffix="crvInfo";break;
		case "plusMinusAverage":$suffix="plsMns";break;
		case "multiplyDivide":$suffix="mltDiv";break;
		case "reverse":$suffix="rvrs";break;
		case "condition":$suffix="cond";break;
		case "clamp":$suffix="clmp";break;
		case "blendWeighted":$suffix="bldWght";break;
	}
	
	$cmd = "createNode "+$nodeType+" -n (abRTRigNamer(\""+$baseName+"\", \""+$prefix+"\", \""+$suffix+"\", true));";
	
	$node = eval($cmd);
	
	if ($limbName != "") abRTSaveToCharVars({$node}, $limbName);
	
	return $node;
	
}


global proc abRTSaveRigGrpToCharVars(string $rigGrp, string $limbName){
	// saves the rigGrp to charVars in the attribute $limbName+"RigGrp".  Used for rig removal
	
	string $charVarNode = abRTGetCharVarNode();
	
	$rigGrp = shortNameOf($rigGrp);
	
	if ($charVarNode != ""){
		string $attName = $limbName+"RigGrp";
		if (!attributeExists($attName, $charVarNode)) addAttr -ln $attName -dt "string" $charVarNode;
		setAttr -type "string" ($charVarNode+"."+$attName) $rigGrp;	
	}
	
}


global proc abRTSaveToCharVars(string $aNodes[], string $limbName){
	// Used for rig removal.
	// saves the joints to charVars in the attribute $limbName+"Jnts".
	// saves atts (nodeName.att) to charVars in the attribute $limbName+"Atts". 
	// saves transforms to charVars in att $limbName+"Trans"
	// saves other nodes to charVars in att $limbName+"Nodes"
	
	string $charVarNode = abRTGetCharVarNode();
	if ($charVarNode == "") return;
	
	// sort jnts into one array and atts and transforms into another
	string $aJnts[], $aAtts[], $aTrans[], $aOthers[], $node, $aStr[], $cVarAtt, $cAttVal, $arrayStr;
	
	for ($node in $aNodes){
		
		if ($node == "") continue;
		
		// determine whether this is an attribute
		$aStr = stringToStringArray($node, ".");
		if (size($aStr) == 2){
			// it's an att
			$aStr[0] = abRTStripPath($aStr[0]);
			if (attributeExists($aStr[1], $aStr[0])){
				$aAtts[size($aAtts)] = abRTStripPath($node);
				continue;
			}
		}
		
		// transforms
		if (`nodeType $node` == "transform" && `objExists $node`){
			$aTrans[size($aTrans)] = abRTStripPath($node);
			continue;
		}
		
		// joints
		if (`nodeType $node` == "joint" && `objExists $node`){
			$aJnts[size($aJnts)] = abRTStripPath($node);
			continue;
		}
		
		// capture others in $aOthers
		if (`objExists $node`){
			$aOthers[size($aOthers)] = abRTStripPath($node);
			continue;
		}
		
	}
	
	if (size($aAtts) > 0){
		
		$cVarAtt = $limbName+"Atts";
		$arrayStr = stringArrayToString($aAtts, ",");
		
		if (!attributeExists($cVarAtt, $charVarNode)) addAttr -ln $cVarAtt -dt "string" $charVarNode;
		
		$cAttVal = `getAttr ($charVarNode+"."+$cVarAtt)`;
		if (size($cAttVal) > 0) $arrayStr = $cAttVal+","+$arrayStr;
		
		setAttr -type "string" ($charVarNode+"."+$cVarAtt) $arrayStr;
		
	}
	if (size($aTrans) > 0){
		
		$cVarAtt = $limbName+"Trans";
		$arrayStr = stringArrayToString($aTrans, ",");
		
		if (!attributeExists($cVarAtt, $charVarNode)) addAttr -ln $cVarAtt -dt "string" $charVarNode;
		
		$cAttVal = `getAttr ($charVarNode+"."+$cVarAtt)`;
		if (size($cAttVal) > 0) $arrayStr = $cAttVal+","+$arrayStr;
		
		setAttr -type "string" ($charVarNode+"."+$cVarAtt) $arrayStr;
		
	}
	if (size($aJnts) > 0){
		
		$cVarAtt = $limbName+"Jnts";
		$arrayStr = stringArrayToString($aJnts, ",");
		
		if (!attributeExists($cVarAtt, $charVarNode)) addAttr -ln $cVarAtt -dt "string" $charVarNode;
		
		$cAttVal = `getAttr ($charVarNode+"."+$cVarAtt)`;
		if (size($cAttVal) > 0) $arrayStr = $cAttVal+","+$arrayStr;
		
		setAttr -type "string" ($charVarNode+"."+$cVarAtt) $arrayStr;
		
	}
	if (size($aOthers) > 0){
		
		$cVarAtt = $limbName+"Nodes";
		$arrayStr = stringArrayToString($aOthers, ",");
		
		if (!attributeExists($cVarAtt, $charVarNode)) addAttr -ln $cVarAtt -dt "string" $charVarNode;
		
		$cAttVal = `getAttr ($charVarNode+"."+$cVarAtt)`;
		if (size($cAttVal) > 0) $arrayStr = $cAttVal+","+$arrayStr;
		
		setAttr -type "string" ($charVarNode+"."+$cVarAtt) $arrayStr;
		
	}
	
}


global proc abRTReplaceWireController(string $curve, string $wireType, int $facingAxis, int $useScaleSlider){
	// replaces existing control curve $curve, with a controller of the type $wireType (see abRTWireContoller proc) and facing axis +x,+y,+z,-x,-y,-z (1,2,3,4,5,6)
	// if $useScaleSlider then size will be based on the position of the scale slider in the replaceWire UI
	
	string $aRel[] = `listRelatives -c -type nurbsCurve $curve`;
	if (size($aRel) == 1){
		
		float $size, $globalScale, $scaleSlider;
		
		$globalScale = float(abRTGetGlobal("globalScale"));
		
		if ($useScaleSlider && `window -q -exists abRTWrRplcWin`){
			$scaleSlider = `floatField -q -v abRTWRScaleFltFld`;
			$size = $globalScale*$scaleSlider;
		}else{
			$size = abRTGetMaxDim($curve);
			$size = $size/$globalScale;
		}
		
		float $aOffset[] = `xform -q -ws -t $curve`;
		if (abs($aOffset[0]) < .00001 && abs($aOffset[1]) < .00001 && abs($aOffset[2]) < .00001) $aOffset = `objectCenter($curve)`;
		
		string $directions = abRTWireContoller($wireType, $facingAxis, $aOffset, $size, true);
		string $replaceCmd = `substitute "curve -d" $directions "curve -r -ws -d"`;
		$replaceCmd += " "+$curve;
		eval ($replaceCmd);
		
	}else{
		warning "Select a curve.";
	}
}


global proc abRTScaleWireController(string $curve, float $maxDim, int $scaleUnits){
	// scales a curve to fill $maxDim in its largest dimension -- maxDim is assumed to be in scaled units if $scaleUnits is true
	
	string $aStr[];
	string $aRel[] = `listRelatives -c -type nurbsCurve $curve`;
	
	if (size($aRel) == 1){
		
		if ($scaleUnits){
			string $scaleStr = abRTGetGlobal("globalScale");
			float $scale = ($scaleStr == "") ? 1 : float($scaleStr);
			$maxDim = $maxDim*$scale;
		}
		
		// dup curve, scale it up, and get its point info
		$aStr = `duplicate -n "abRTScaleWireControllerDupObj_crv" $curve`;
		string $tDup = $aStr[0];
		
		xform -centerPivots $tDup;
		float $cMaxDim = abRTGetMaxDim($tDup);
		
		float $mDimScalar = ($maxDim - $cMaxDim)/$cMaxDim;
		
		setAttr -lock false -keyable true ($tDup+".sx");
		setAttr -lock false -keyable true ($tDup+".sy");
		setAttr -lock false -keyable true ($tDup+".sz");
		
		float $aScale[] = `getAttr ($tDup+".s")`;
		float $aTargetScale[] = {$aScale[0]*$mDimScalar, $aScale[1]*$mDimScalar, $aScale[2]*$mDimScalar};
		
		setAttr ($tDup+".s") $aTargetScale[0] $aTargetScale[1] $aTargetScale[2];
		
		string $directions = re_getCurvePointInfo($tDup);
		string $replaceCmd = `substitute "curve -d" $directions "curve -r -ws -d"`;
		$replaceCmd += " "+$curve;
		eval ($replaceCmd);
		
		delete $tDup;
		
	}
	
}


global proc abRTMoveWireRelativeToPivot(string $curve, float $x, float $y, float $z, int $useWorldSpace){
	/*
	moves curve relative to its pivot
	$x, $y, and $z can be -1,0,1 based on whether you want to move the curve points min, center, max relative to the pivot in each dimension
	can be greater or less than 1 and -1 respectively.  $x == -2 will move the wire two bBox widths -x beyond its pivot.
	uses worldspace if $useWorldSpace == true, otherwise uses local space
	*/
	
	string $aRel[] = `listRelatives -c -type nurbsCurve $curve`;
	if (size($aRel) == 1){
		
		string $cNode = $aRel[0];
		float $aBbox[] = `xform -q -ws -boundingBox $curve`;
		
		float $aBboxDim[] = {$aBbox[3]-$aBbox[0], $aBbox[4]-$aBbox[1], $aBbox[5]-$aBbox[2]};
		float $aCenter[] = {($aBbox[0]+($aBboxDim[0])/2),($aBbox[1]+($aBboxDim[1])/2),($aBbox[2]+($aBboxDim[2])/2)};
		float $aPivot[] = `xform -q -ws -rp $curve`;
		float $xOffset, $yOffset, $zOffset;
		
		$xOffset = $aPivot[0] - $aCenter[0] + $aBboxDim[0]*$x;
		$yOffset = $aPivot[1] - $aCenter[1] + $aBboxDim[1]*$y;
		$zOffset = $aPivot[2] - $aCenter[2] + $aBboxDim[2]*$z;
		
		string $aCvs[] = `filterExpand -ex true -sm 28 ($curve+".cv[*]")`;
		string $cv;
		float $xForm[], $xForm2[];
		
		for ($cv in $aCvs){
			$xForm = ($useWorldSpace) ? `xform -q -ws -t $cv` : `xform -q -os -t $cv` ;
			$xForm2[0] = $xForm[0] + $xOffset;
			$xForm2[1] = $xForm[1] + $yOffset;
			$xForm2[2] = $xForm[2] + $zOffset;
			if ($useWorldSpace){
				xform -ws -t $xForm2[0] $xForm2[1] $xForm2[2] $cv;
			}else{
				xform -os -t $xForm2[0] $xForm2[1] $xForm2[2] $cv;
			}
		}
	}
}


/* global proc abRTMoveWireRelativeToPivot(string $curve, float $x, float $y, float $z){
	
	moves curve relative to its pivot
	$x, $y, and $z can be -1,0,1 based on whether you want to move the curve points min, center, max relative to the pivot in each dimension
	can be greater or less than 1 and -1 respectively.  $x == -2 will move the wire two bBox widths -x beyond its pivot.
	
	
	string $aRel[] = `listRelatives -c -type nurbsCurve $curve`;
	if (size($aRel) == 1){
		
		string $cNode = $aRel[0];
		float $aBbox[] = `xform -q -ws -boundingBox $curve`;
		
		float $aBboxDim[] = {$aBbox[3]-$aBbox[0], $aBbox[4]-$aBbox[1], $aBbox[5]-$aBbox[2]};
		float $aCenter[] = {($aBbox[0]+($aBboxDim[0])/2),($aBbox[1]+($aBboxDim[1])/2),($aBbox[2]+($aBboxDim[2])/2)};
		float $aPivot[] = `xform -q -ws -rp $curve`;
		float $xOffset, $yOffset, $zOffset;
		
		$xOffset = $aPivot[0] - $aCenter[0] + $aBboxDim[0]*$x;
		$yOffset = $aPivot[1] - $aCenter[1] + $aBboxDim[1]*$y;
		$zOffset = $aPivot[2] - $aCenter[2] + $aBboxDim[2]*$z;
		
		string $aCvs[] = `filterExpand -ex true -sm 28 ($curve+".cv[*]")`;
		string $cv;
		float $xForm[], $xForm2[];
		
		for ($cv in $aCvs){
			$xForm = `xform -q -ws -t $cv`;
			$xForm2[0] = $xForm[0] + $xOffset;
			$xForm2[1] = $xForm[1] + $yOffset;
			$xForm2[2] = $xForm[2] + $zOffset;
			xform -ws -t $xForm2[0] $xForm2[1] $xForm2[2] $cv;
		}
	}
} */


global proc string abRTWireContoller(string $wireType, int $facingAxis, float $aOffset[], float $size, int $getIns){
	/*
	$wireType is the type of controller to build
	$facingAxis is the direction that the controller will face 0(x+), 1(y+), 2(z+), 3, 4, and 5 are the coresponding negative directions
	$aOffset is used to offset wire from origin
	$size is how big to make the max dimension on the bounding box (in Maya units which is modified by the global "globalScale")
	if $getIns (get instructions) is true, directions on how to build the control will be returned -- controller won't be built
	if $getIns is false, newly built controller name will be returned
	*/
	
	string $directions, $ret;
	
	switch($wireType){
		case "fatArrow": $directions = "curve -d 1 -p -1.13696793 -4.532183231e-016 -1.736420648 -p -1.13696793 -3.029387864e-016 -0.2273470747 -p -2 -4.945704011e-016 -0.2273470747 -p 1.550375579e-005 1.450820363e-016 1.736420648 -p 2 3.936080183e-016 -0.2273470747 -p 1.136881109 2.019571254e-016 -0.2273470747 -p 1.136881109 5.167758861e-017 -1.736420648 -p -1.13696793 -4.532183231e-016 -1.736420648"; break;
		case "medArrow": $directions = "curve -d 1 -p -1.008294648 -4.71258548e-016 -2 -p -1.008294648 -2.895354667e-016 -0.1751773671 -p -1.773670842 -4.594831208e-016 -0.1751773671 -p 8.820779928e-015 1.509637169e-016 2 -p 1.773670842 3.281849614e-016 -0.1751773671 -p 1.008215818 1.582198035e-016 -0.1751773671 -p 1.008215818 -2.350327819e-017 -2 -p -1.008294648 -4.71258548e-016 -2"; break;
		case "fatFourWayArrowMed": $directions = "curve -d 1 -p -9.860761315e-032 -1.99167939e-016 -2 -p -0.6639344264 -2.655067899e-016 -1.185770492 -p -0.3774000001 -2.018833665e-016 -1.185770492 -p -0.3774000001 -1.213826241e-016 -0.3774000001 -p -1.185770492 -3.008769306e-016 -0.3774000001 -p -1.185770492 -3.294111661e-016 -0.6639344264 -p -2 -4.440892099e-016 9.860761318e-032 -p -1.185770492 -1.971767147e-016 0.6639344264 -p -1.185770492 -2.257076853e-016 0.3774327869 -p -0.3774327869 -4.622065895e-017 0.3774327869 -p -0.3774327869 3.427681844e-017 1.185770492 -p -0.6639344264 -2.933932489e-017 1.185770492 -p 9.860761315e-032 1.99167939e-016 2 -p 0.6639344264 2.655067899e-016 1.185770492 -p 0.3774000001 2.018833665e-016 1.185770492 -p 0.3774000001 1.213826241e-016 0.3774000001 -p 1.185770492 3.008769306e-016 0.3774000001 -p 1.185770492 3.294111661e-016 0.6639344264 -p 2 4.440892099e-016 -9.860761318e-032 -p 1.185770492 1.971767147e-016 -0.6639344264 -p 1.185770492 2.257076853e-016 -0.3774327869 -p 0.3774327869 4.622065895e-017 -0.3774327869 -p 0.3774327869 -3.427681844e-017 -1.185770492 -p 0.6639344264 2.933932489e-017 -1.185770492 -p -9.860761315e-032 -1.99167939e-016 -2"; break;
		case "fatFourWayArrow": $directions = "curve -d 1 -p 1.30541401e-006 -1.991662106e-016 -2 -p -0.5286913681 -2.519920061e-016 -1.35162697 -p -0.3005519943 -2.01334889e-016 -1.35162697 -p -0.3005519943 -9.666337077e-017 -0.3005389401 -p -1.351613916 -3.300459999e-016 -0.3005389401 -p -1.351613916 -3.527652843e-016 -0.5286809248 -p -1.999986946 -4.440837024e-016 1.174872608e-005 -p -1.351613916 -2.474666541e-016 0.5287044222 -p -1.351613916 -2.701882786e-016 0.3005389401 -p -0.3005519943 -3.680564937e-017 0.3005389401 -p -0.3005519943 6.786586888e-017 1.35162697 -p -0.5286913681 1.720875176e-017 1.35162697 -p 1.30541401e-006 1.991696677e-016 2 -p 0.5286939789 2.519954634e-016 1.35162697 -p 0.300525886 2.013319694e-016 1.35162697 -p 0.300525886 9.666045107e-017 0.3005389401 -p 1.351613916 3.300488774e-016 0.3005389401 -p 1.351613916 3.527705018e-016 0.5287044222 -p 1.999986946 4.440889199e-016 1.174872608e-005 -p 1.351613916 2.474718716e-016 -0.5286809248 -p 1.351613916 2.701911561e-016 -0.3005389401 -p 0.300525886 3.680272967e-017 -0.3005389401 -p 0.300525886 -6.786878854e-017 -1.35162697 -p 0.5286939789 -1.720529447e-017 -1.35162697 -p 1.30541401e-006 -1.991662106e-016 -2"; break;
		case "fatFoutWayArrowSmall_1": $directions = "curve -d 1 -p 1.180149114e-015 -1.991627351e-016 -1.999976564 -p -0.9492113346 -3.25514564e-016 -1.152295686 -p -0.5396067219 -2.345640697e-016 -1.152295686 -p -0.5396067219 -1.735477366e-016 -0.5395832847 -p -1.152319123 -3.095972196e-016 -0.5395832847 -p -1.152319123 -3.503872729e-016 -0.9491878972 -p -2 -4.440840058e-016 2.34373169e-005 -p -1.152319123 -1.613348076e-016 0.9492347719 -p -1.152319123 -2.021295288e-016 0.5395832847 -p -0.5396067219 -6.608004592e-017 0.5395832847 -p -0.5396067219 -5.059044821e-018 1.15234256 -p -0.9492113346 -9.600953922e-017 1.15234256 -p 1.180149114e-015 1.991684754e-016 1.999976564 -p 0.9492113346 3.255249723e-016 1.15234256 -p 0.5395598474 2.345640698e-016 1.15234256 -p 0.5395598474 1.735430687e-016 0.5395832847 -p 1.152319123 3.096029599e-016 0.5395832847 -p 1.152319123 3.503976812e-016 0.9492347719 -p 2 4.440944141e-016 2.34373169e-005 -p 1.152319123 1.613452159e-016 -0.9491878972 -p 1.152319123 2.021352691e-016 -0.5395832847 -p 0.5395598474 6.607537795e-017 -0.5395832847 -p 0.5395598474 5.059044751e-018 -1.152295686 -p 0.9492113346 9.601994752e-017 -1.152295686 -p 1.180149114e-015 -1.991627351e-016 -1.999976564"; break;
		case "twoWayArrow": $directions = "curve -d 1 -p -1.185770492 -3.008769306e-016 -0.3774000001 -p -1.185770492 -3.294111661e-016 -0.6639344264 -p -2 -4.440892099e-016 -3.301863753e-015 -p -1.185770492 -1.971767147e-016 0.6639344264 -p -1.185770492 -2.257076853e-016 0.3774327869 -p 1.185770492 3.008769306e-016 0.3774000001 -p 1.185770492 3.294111661e-016 0.6639344264 -p 2 4.440892099e-016 -3.301863753e-015 -p 1.185770492 1.971767147e-016 -0.6639344264 -p 1.185770492 2.257076853e-016 -0.3774327869 -p -1.185770492 -3.008769306e-016 -0.3774000001"; break;
		case "medTwoWayArrow": $directions = "curve -d 1 -p -0.8347730204 -2.391417678e-016 -0.5400961875 -p -0.8347730204 -2.799762183e-016 -0.9501466274 -p -2 -4.440892098e-016 2.362623916e-015 -p -0.8347730204 -9.073747268e-017 0.9501466274 -p -0.8347730204 -1.315677179e-016 0.5401384163 -p 0.8347683283 2.391402587e-016 0.5400914956 -p 0.8347683283 2.799751764e-016 0.9501466274 -p 2 4.440892098e-016 2.362623916e-015 -p 0.8347683283 9.073643084e-017 -0.9501466274 -p 0.8347683283 1.315666761e-016 -0.5401384163 -p -0.8347730204 -2.391417678e-016 -0.5400961875"; break;
		case "fatCross": $directions = "curve -d 1 -p -1.295999999 -4.869377471e-016 -2 -p -1.295999999 -4.168306324e-016 -1.295999999 -p -2 -5.731500341e-016 -1.295999999 -p -2 -3.150283852e-016 1.295999999 -p -1.295999999 -1.587089834e-016 1.295999999 -p -1.295999999 -8.860186874e-017 2 -p 1.295999999 4.869377471e-016 2 -p 1.295999999 4.168306324e-016 1.295999999 -p 2 5.731500341e-016 1.295999999 -p 2 3.150283852e-016 -1.295999999 -p 1.295999999 1.587089834e-016 -1.295999999 -p 1.295999999 8.860186874e-017 -2 -p -1.295999999 -4.869377471e-016 -2"; break;
		case "medCross": $directions = "curve -d 1 -p -0.8839111111 -3.954356325e-016 -2 -p -0.8839111111 -2.842969718e-016 -0.8839703704 -p -2 -5.321184883e-016 -0.8839703704 -p -2 -3.560599313e-016 0.8839703704 -p -0.8839111111 -1.082384149e-016 0.8839703704 -p -0.8839111111 2.900245553e-018 2 -p 0.8840296296 3.95461949e-016 2 -p 0.8840296296 2.843232883e-016 0.8839703704 -p 2 5.321184883e-016 0.8839703704 -p 2 3.560599313e-016 -0.8839703704 -p 0.8840296296 1.082647314e-016 -0.8839703704 -p 0.8840296296 -2.873929247e-018 -2 -p -0.8839111111 -3.954356325e-016 -2"; break;
		case "fatDoubleArrow180": $directions = "curve -d 3 -p -1.5024735 2.375179035e-016 -0.313090278 -p -1.5024735 5.329184319e-017 0.5165901387 -p -0.8298885555 -1.784101448e-016 1.189143333 -p -0.000239888857 -2.800094477e-016 1.189143333 -p 0.8294405278 -3.816126387e-016 1.189143333 -p 1.502029 -3.14641442e-016 0.5165901387 -p 1.502029 -1.304153816e-016 -0.313090278 -p 1.535698559 -1.345385771e-016 -0.313090278 -p 1.771388498 -1.634013168e-016 -0.313090278 -p 1.805058056 -1.675245123e-016 -0.313090278 -p 1.72568385 -1.361908622e-016 -0.410428533 -p 1.170057262 8.314750859e-017 -1.091805079 -p 1.090683056 1.144811587e-016 -1.189143333 -p 1.01130885 1.0258794e-016 -1.091805079 -p 0.4556822618 1.933433913e-017 -0.410428533 -p 0.3763080556 7.441120482e-018 -0.313090278 -p 0.4106439653 3.236323161e-018 -0.313090278 -p 0.6509984236 -2.619763652e-017 -0.313090278 -p 0.6853343334 -3.040243384e-017 -0.313090278 -p 0.6853343334 -1.144719013e-016 0.0655249442 -p 0.3783753334 -1.45040097e-016 0.3724839442 -p -0.000239888857 -9.867463631e-017 0.3724839442 -p -0.3788551111 -5.230917563e-017 0.3724839442 -p -0.6858141111 5.343980843e-017 0.0655249442 -p -0.6858141111 1.375092759e-016 -0.313090278 -p -0.6514248932 1.332979504e-016 -0.313090278 -p -0.4106972734 1.038182931e-016 -0.313090278 -p -0.3763080555 9.960696765e-017 -0.313090278 -p -0.4556822618 1.309406178e-016 -0.410428533 -p -1.01130885 3.502789886e-016 -1.091805079 -p -1.090683056 3.816126387e-016 -1.189143333 -p -1.170057262 3.6971942e-016 -1.091805079 -p -1.72568385 2.864658191e-016 -0.410428533 -p -1.805058056 2.745726004e-016 -0.313090278 -p -1.771437886 2.704554531e-016 -0.313090278 -p -1.53609367 2.416350509e-016 -0.313090278 -p -1.5024735 2.375179035e-016 -0.313090278"; break;
		case "fatDoubleArrow90": $directions = "curve -d 3 -p -1.340659625 5.167415496e-017 0.6274029306 -p -1.24332529 2.212991615e-017 0.7067771366 -p -0.5619761826 -1.846824145e-016 1.262403725 -p -0.4646418473 -2.142266534e-016 1.341777931 -p -0.4646418473 -2.066952423e-016 1.307859471 -p -0.4646418473 -1.539746868e-016 1.070427197 -p -0.4646418473 -1.464432757e-016 1.036508736 -p 0.3650420971 -2.480468987e-016 1.036508736 -p 1.037627041 -1.810760533e-016 0.3639590694 -p 1.037627041 3.15079036e-018 -0.4657248751 -p 1.071296992 -9.724531511e-019 -0.4657248751 -p 1.306989674 -2.983552883e-017 -0.4657248751 -p 1.340659625 -3.395877234e-017 -0.4657248751 -p 1.261285419 -2.62512223e-018 -0.5630631301 -p 0.7056588311 2.167132486e-016 -1.244439676 -p 0.6262846251 2.480468987e-016 -1.341777931 -p 0.5469104191 2.3615368e-016 -1.244439676 -p -0.0087161688 1.529000791e-016 -0.5630631301 -p -0.0880903751 1.410068605e-016 -0.4657248751 -p -0.0537548573 1.368021111e-016 -0.4657248751 -p 0.1865968571 1.073684875e-016 -0.4657248751 -p 0.2209323749 1.031637382e-016 -0.4657248751 -p 0.2209323749 1.909427072e-017 -0.0871096528 -p -0.0860266251 -1.147392499e-017 0.2198493472 -p -0.4646418473 3.489153569e-017 0.2198493472 -p -0.4646418473 4.246124224e-017 0.1857584196 -p -0.4646418473 9.544986938e-017 -0.0528811419 -p -0.4646418473 1.030195759e-016 -0.0869720695 -p -0.5619761826 9.731458621e-017 -0.0075978632 -p -1.24332529 5.737914469e-017 0.5480287246 -p -1.340659625 5.167415496e-017 0.6274029306"; break;
		case "fatSingleArrow90": $directions = "curve -d 3 -p -0.9029594168 3.492542029e-017 0.372501583 -p -0.9029594168 1.477730939e-017 0.4632406078 -p -0.9029594168 -1.262612802e-016 1.098421947 -p -0.9029594168 -1.464093911e-016 1.189160972 -p -0.07327547232 -2.480130141e-016 1.189160972 -p 0.5993094718 -1.810413854e-016 0.5166077775 -p 0.5993094718 3.184674957e-018 -0.3130726391 -p 0.6330480178 -9.469687407e-019 -0.3130726391 -p 0.8692208708 -2.986884648e-017 -0.3130726391 -p 0.9029594168 -3.400049017e-017 -0.3130726391 -p 0.8235852108 -2.665969716e-018 -0.4104148138 -p 0.2679586228 2.166784936e-016 -1.091818798 -p 0.1885844168 2.480130141e-016 -1.189160972 -p 0.1092102108 2.361189251e-016 -1.091818798 -p -0.4464163772 1.528592316e-016 -0.4104148138 -p -0.5257905834 1.409651426e-016 -0.3130726391 -p -0.4915236607 1.367687935e-016 -0.3130726391 -p -0.2516521173 1.073939719e-016 -0.3130726391 -p -0.2173851945 1.031976228e-016 -0.3130726391 -p -0.2173851945 1.912815531e-017 0.06554258305 -p -0.5243406668 -1.144047241e-017 0.372501583 -p -0.9029594168 3.492542029e-017 0.372501583"; break;
		case "fatSingleArrow180": $directions = "curve -d 3 -p -0.1518426113 -2.079620801e-016 1.189160972 -p 0.6778378054 -3.095652711e-016 1.189160972 -p 1.350422749 -2.425936424e-016 0.5166077779 -p 1.350422749 -5.836758205e-017 -0.3130726389 -p 1.384161688 -6.249927375e-017 -0.3130726389 -p 1.620337285 -9.14214875e-017 -0.3130726389 -p 1.654076223 -9.55531792e-017 -0.3130726389 -p 1.574702016 -6.421865874e-017 -0.4104148136 -p 1.019075428 1.551258046e-016 -1.091818797 -p 0.9397012225 1.864603251e-016 -1.189160972 -p 0.8603270155 1.745662361e-016 -1.091818797 -p 0.3047004283 9.13065426e-017 -0.4104148136 -p 0.225326222 7.941245361e-017 -0.3130726389 -p 0.2595931448 7.521610447e-017 -0.3130726389 -p 0.4994646882 4.584128286e-017 -0.3130726389 -p 0.5337316109 4.164493373e-017 -0.3130726389 -p 0.5337316109 -4.242453371e-017 0.06554258335 -p 0.2267726109 -7.299272942e-017 0.3725015833 -p -0.1518426113 -2.662726874e-017 0.3725015833 -p -0.5304613613 1.973862395e-017 0.3725015833 -p -0.8374168335 1.25487176e-016 0.06554258335 -p -0.8374168335 2.095566434e-016 -0.3130726389 -p -0.9281558582 2.206686021e-016 -0.3130726389 -p -1.563337198 2.984533125e-016 -0.3130726389 -p -1.654076223 3.095652711e-016 -0.3130726389 -p -1.654076223 1.253392108e-016 0.5166077779 -p -0.981491278 -1.063627772e-016 1.189160972 -p -0.1518426113 -2.079620801e-016 1.189160972"; break;
		case "fatSingleArrow270": $directions = "curve -d 3 -p -0.1518426111 -3.335609246e-016 1.502233611 -p 0.6778378056 -4.351641156e-016 1.502233611 -p 1.35042275 -3.681924869e-016 0.8296804165 -p 1.35042275 -1.839664266e-016 -1.509999933e-010 -p 1.384161687 -1.880981183e-016 -1.509999933e-010 -p 1.620337285 -2.17020332e-016 -1.509999933e-010 -p 1.654076222 -2.211520237e-016 -1.509999933e-010 -p 1.574702016 -1.898175033e-016 -0.0973421749 -p 1.019075428 2.952696008e-017 -0.7787461588 -p 0.939701222 6.086148054e-017 -0.8760883335 -p 0.860327016 4.896739154e-017 -0.7787461588 -p 0.3047004285 -3.429230192e-017 -0.0973421749 -p 0.2253262222 -4.618639091e-017 -1.509999933e-010 -p 0.259593145 -5.038274005e-017 -1.509999933e-010 -p 0.4994646884 -7.975756166e-017 -1.509999933e-010 -p 0.5337316111 -8.395391079e-017 -1.509999933e-010 -p 0.5337316111 -1.680233782e-016 0.3786152221 -p 0.2267726111 -1.985915739e-016 0.6855742221 -p -0.1518426111 -1.522261133e-016 0.6855742221 -p -0.5304613611 -1.058602206e-016 0.6855742221 -p -0.8374168333 -1.116685193e-019 0.3786152221 -p -0.8374168333 8.395779892e-017 -1.509999933e-010 -p -0.8374168333 1.680280497e-016 -0.3786187502 -p -0.5304613611 1.985958941e-016 -0.6855742224 -p -0.1518426111 1.522300014e-016 -0.6855742224 -p -0.1518390834 1.522295694e-016 -0.6855742224 -p -0.1518143889 1.522265453e-016 -0.6855742224 -p -0.1518108611 1.522261133e-016 -0.6855742224 -p -0.1518108611 1.723742241e-016 -0.7763132471 -p -0.1518108611 3.134128137e-016 -1.411494587 -p -0.1518108611 3.335609246e-016 -1.502233611 -p -0.1518143889 3.335613566e-016 -1.502233611 -p -0.1518390834 3.335643807e-016 -1.502233611 -p -0.1518426111 3.335648127e-016 -1.502233611 -p -0.9814912778 4.351641156e-016 -1.502233611 -p -1.654076222 3.681932702e-016 -0.8296839446 -p -1.654076222 1.839664266e-016 -1.509999933e-010 -p -1.654076222 -2.59633761e-019 0.8296804165 -p -0.9814912778 -2.319616218e-016 1.502233611 -p -0.1518426111 -3.335609246e-016 1.502233611"; break;
		case "thinDoubleArrow90": $directions = "curve -d 3 -p -1.220898625 1.630422784e-017 0.7471868613 -p -1.147197029 -4.324927329e-018 0.7994448782 -p -0.6312792213 -1.487308702e-016 1.165255704 -p -0.557577625 -1.693600253e-016 1.217513722 -p -0.557577625 -1.627116727e-016 1.187572203 -p -0.557577625 -1.161726058e-016 0.9779788793 -p -0.557577625 -1.095242532e-016 0.9480373613 -p 0.2720851528 -2.111252841e-016 0.9480373613 -p 0.944655986 -1.441519274e-016 0.2754841666 -p 0.944655986 4.007413297e-017 -0.55419625 -p 0.975349306 3.631540955e-017 -0.55419625 -p 1.190205305 1.000400732e-017 -0.55419625 -p 1.220898625 6.245283896e-018 -0.55419625 -p 1.168642959 2.900950072e-017 -0.6278974543 -p 0.802848596 1.883610673e-016 -1.143812518 -p 0.750592931 2.111252841e-016 -1.217513722 -p 0.698336873 2.011596393e-016 -1.143812518 -p 0.332539766 1.31399229e-016 -0.6278974543 -p 0.2802837084 1.214335842e-016 -0.55419625 -p 0.3103937745 1.177462864e-016 -0.55419625 -p 0.521166948 9.193486969e-017 -0.55419625 -p 0.551277014 8.824757186e-017 -0.55419625 -p 0.551277014 -4.773277858e-017 0.05820480555 -p 0.0548375417 -9.718507502e-017 0.5547113053 -p -0.557577625 -2.218832459e-017 0.5547113053 -p -0.557577625 -1.533430793e-017 0.5238435582 -p -0.557577625 3.264442556e-017 0.3077665524 -p -0.557577625 3.949844222e-017 0.2768988056 -p -0.6312792213 3.692133306e-017 0.3291525115 -p -1.147197029 1.8881337e-017 0.6949331552 -p -1.220898625 1.630422784e-017 0.7471868613"; break;
		case "thinDoubleArrow180": $directions = "curve -d 3 -p -1.50345775 2.479536094e-016 -0.4194580692 -p -1.50345775 6.372676574e-017 0.4102258752 -p -0.8308869167 -1.679727109e-016 1.082775541 -p -0.0012065 -2.695759019e-016 1.082775541 -p 0.8284598056 -3.711773648e-016 1.082775541 -p 1.501027111 -3.042043593e-016 0.4102258752 -p 1.501027111 -1.199775157e-016 -0.4194580692 -p 1.531720823 -1.237362871e-016 -0.4194580692 -p 1.746579566 -1.500480254e-016 -0.4194580692 -p 1.777273278 -1.538067968e-016 -0.4194580692 -p 1.725017612 -1.3104258e-016 -0.4931592736 -p 1.359223249 2.830898662e-017 -1.009074337 -p 1.306967583 5.107320344e-017 -1.082775541 -p 1.254711526 4.110755867e-017 -1.009074337 -p 0.8889144188 -2.865285166e-017 -0.4931592736 -p 0.8366583611 -3.861849644e-017 -0.4194580692 -p 0.8667680353 -4.230574627e-017 -0.4194580692 -p 1.077538465 -6.811682697e-017 -0.4194580692 -p 1.107648139 -7.180407681e-017 -0.4194580692 -p 1.107648139 -2.077844272e-016 0.1929429863 -p 0.6112121944 -2.572371557e-016 0.6894494864 -p -0.001224138889 -1.822378132e-016 0.6894494864 -p -0.6136075556 -1.072449509e-016 0.6894494864 -p -1.110096417 6.380198015e-017 0.1929429863 -p -1.110096417 1.997823306e-016 -0.4194580692 -p -1.079714714 1.96061768e-016 -0.4194580692 -p -0.8670400635 1.700174951e-016 -0.4194580692 -p -0.8366583611 1.662969326e-016 -0.4194580692 -p -0.8889144188 1.890611974e-016 -0.4931592736 -p -1.254711526 3.484131e-016 -1.009074337 -p -1.306967583 3.711773648e-016 -1.082775541 -p -1.359223249 3.61211672e-016 -1.009074337 -p -1.725017612 2.914509257e-016 -0.4931592736 -p -1.777273278 2.814852329e-016 -0.4194580692 -p -1.746849634 2.777595342e-016 -0.4194580692 -p -1.533881393 2.516793081e-016 -0.4194580692 -p -1.50345775 2.479536094e-016 -0.4194580692"; break;
		case "thinSingleArrow90": $directions = "curve -d 3 -p 0.612993722 4.007239067e-017 -0.4194492499 -p 0.643687434 3.631361925e-017 -0.4194492499 -p 0.858546177 1.0001881e-017 -0.4194492499 -p 0.889239889 6.243109579e-018 -0.4194492499 -p 0.836983831 2.90073744e-017 -0.4931504543 -p 0.471186724 1.88359277e-016 -1.009065518 -p 0.418930666 2.111235418e-016 -1.082766722 -p 0.366675001 2.01157849e-016 -1.009065518 -p 0.0008806377418 1.313971027e-016 -0.4931504543 -p -0.05137502796 1.214314099e-016 -0.4194492499 -p -0.02126535376 1.177441601e-016 -0.4194492499 -p 0.189505076 9.193307939e-017 -0.4194492499 -p 0.21961475 8.824582956e-017 -0.4194492499 -p 0.21961475 -4.773060426e-017 0.1929341668 -p -0.2768211946 -9.718333271e-017 0.6894406671 -p -0.889239889 -2.218615027e-017 0.6894406671 -p -0.889239889 -3.18900453e-017 0.7331431252 -p -0.889239889 -9.981818386e-017 1.039064264 -p -0.889239889 -1.095220789e-016 1.082766722 -p -0.05957358346 -2.111235418e-016 1.082766722 -p 0.612993722 -1.441505364e-016 0.4102170557 -p 0.612993722 4.007239067e-017 -0.4194492499"; break;
		case "thinSingleArrow180": $directions = "curve -d 3 -p -0.1381142639 -2.079642402e-016 1.082777306 -p 0.6915485139 -3.095652711e-016 1.082777306 -p 1.364119348 -2.425919143e-016 0.4102241109 -p 1.364119348 -5.8365854e-017 -0.4194563058 -p 1.394813059 -6.212462542e-017 -0.4194563058 -p 1.609671803 -8.843636367e-017 -0.4194563058 -p 1.640365513 -9.219513509e-017 -0.4194563058 -p 1.588109457 -6.943078323e-017 -0.4931579021 -p 1.22231235 8.992172861e-017 -1.00907571 -p 1.170056292 1.126860805e-016 -1.082777306 -p 1.117800625 1.027203007e-016 -1.00907571 -p 0.7520062629 3.295894507e-017 -0.4931579021 -p 0.6997505972 2.299316526e-017 -0.4194563058 -p 0.7298602714 1.930591542e-017 -0.4194563058 -p 0.9406307005 -6.505165278e-018 -0.4194563058 -p 0.9707403745 -1.019241511e-017 -0.4194563058 -p 0.9707403745 -1.461719822e-016 0.192941222 -p 0.4743009027 -1.95625062e-016 0.6894512498 -p -0.1381319028 -1.206261515e-016 0.6894512498 -p -0.7505153195 -4.563328919e-017 0.6894512498 -p -1.247004181 1.254144252e-016 0.192941222 -p -1.247004181 2.613939923e-016 -0.4194563058 -p -1.290710559 2.667463031e-016 -0.4194563058 -p -1.596659137 3.042129603e-016 -0.4194563058 -p -1.640365513 3.095652711e-016 -0.4194563058 -p -1.640365513 1.253392108e-016 0.4102241109 -p -0.9677982084 -1.063606172e-016 1.082777306 -p -0.1381142639 -2.079642402e-016 1.082777306"; break;
		case "thinSingleArrow270": $directions = "curve -d 3 -p -0.1381283752 -3.335609246e-016 1.502233611 -p 0.6915520415 -4.351641156e-016 1.502233611 -p 1.364136986 -3.681932702e-016 0.8296839444 -p 1.364136986 -1.839664266e-016 -7.299995742e-011 -p 1.394828738 -1.87724958e-016 -7.299995742e-011 -p 1.609673762 -2.140350162e-016 -7.299995742e-011 -p 1.640365514 -2.177935476e-016 -7.299995742e-011 -p 1.588107888 -1.950290908e-016 -0.07370120441 -p 1.222299806 -3.567584413e-017 -0.589616268 -p 1.17004218 -1.29113873e-017 -0.6633174723 -p 1.117788083 -2.287727208e-017 -0.589616268 -p 0.7520046949 -9.263936247e-017 -0.07370120441 -p 0.699750597 -1.026052472e-016 -7.299995742e-011 -p 0.7298606632 -1.062925451e-016 -7.299995742e-011 -p 0.940633836 -1.321039618e-016 -7.299995742e-011 -p 0.970743903 -1.357912596e-016 -7.299995742e-011 -p 0.970743903 -2.717716101e-016 0.6124010555 -p 0.4743044304 -3.212239065e-016 1.108907556 -p -0.1381283752 -2.46224996e-016 1.108907556 -p -0.7505294307 -1.712299736e-016 1.108907556 -p -1.247004181 -1.847706656e-019 0.6124010555 -p -1.247004181 1.357955798e-016 -7.299995742e-011 -p -1.247004181 2.717759302e-016 -0.6124010556 -p -0.7505294307 3.212239065e-016 -1.108907556 -p -0.1381283752 2.462288841e-016 -1.108907556 -p -0.1381283752 2.559327792e-016 -1.152610013 -p -0.1381283752 3.238609177e-016 -1.458531154 -p -0.1381283752 3.335648127e-016 -1.502233611 -p -0.9677770418 4.351641156e-016 -1.502233611 -p -1.640365514 3.681929189e-016 -0.8296804167 -p -1.640365514 1.839668586e-016 -7.299995742e-011 -p -1.640365514 -2.599850711e-019 0.8296839444 -p -0.9677770418 -2.319616218e-016 1.502233611 -p -0.1381283752 -3.335609246e-016 1.502233611"; break;
		case "thinDoubleArrow270": $directions = "curve -d 3 -p -0.1380966251 -3.335669728e-016 1.639296597 -p 0.6915520416 -4.351662757e-016 1.639296597 -p 1.364101708 -3.681911102e-016 0.9667469305 -p 1.364101708 -1.839642665e-016 0.137062986 -p 1.39479738 -1.877232779e-016 0.137062986 -p 1.609669842 -2.140366962e-016 0.137062986 -p 1.640365514 -2.177957077e-016 0.137062986 -p 1.588111416 -1.950316828e-016 0.06336178168 -p 1.222328028 -3.568146032e-017 -0.4525532819 -p 1.170073931 -1.291743549e-017 -0.5262544862 -p 1.117816305 -2.288288826e-017 -0.4525532819 -p 0.7520082227 -9.264195455e-017 0.06336178168 -p 0.6997505972 -1.026074073e-016 0.137062986 -p 0.7298606633 -1.062947052e-016 0.137062986 -p 0.940633837 -1.321061219e-016 0.137062986 -p 0.970743903 -1.357934197e-016 0.137062986 -p 0.970743903 -2.717737701e-016 0.7494640416 -p 0.4743044305 -3.212260666e-016 1.245970542 -p -0.1381319028 -2.462267241e-016 1.245970542 -p -0.7504976806 -1.712360218e-016 1.245970542 -p -1.247004181 -1.869307351e-019 0.7494640416 -p -1.247004181 1.357934197e-016 0.137062986 -p -1.247004181 2.717737701e-016 -0.4753380695 -p -0.7504976806 3.212178583e-016 -0.97184457 -p -0.1381319028 2.462271561e-016 -0.97184457 -p -0.1381279831 2.462266761e-016 -0.97184457 -p -0.1381005448 2.46223316e-016 -0.97184457 -p -0.1380966251 2.462228359e-016 -0.97184457 -p -0.1380966251 2.394835316e-016 -0.941493441 -p -0.1380966251 1.923077946e-016 -0.7290328092 -p -0.1380966251 1.855684902e-016 -0.6986816806 -p -0.06439542072 1.881465177e-016 -0.7509393062 -p 0.4515196428 2.061929423e-016 -1.116747388 -p 0.5252208472 2.087709698e-016 -1.169005014 -p 0.4515196428 2.293992066e-016 -1.221259112 -p -0.06439542072 3.737987209e-016 -1.587042499 -p -0.1380966251 3.944269578e-016 -1.639296597 -p -0.1380966251 3.876638928e-016 -1.608838461 -p -0.1380966251 3.403218295e-016 -1.395628762 -p -0.1380966251 3.335587646e-016 -1.365170625 -p -0.9678123195 4.351662757e-016 -1.365170625 -p -1.640365514 3.681907588e-016 -0.6926174306 -p -1.640365514 1.839646985e-016 0.137062986 -p -1.640365514 -2.621451406e-019 0.9667469305 -p -0.9678123195 -2.319594617e-016 1.639296597 -p -0.1380966251 -3.335669728e-016 1.639296597"; break;
		case "fatDoubleArrow270": $directions = "curve -d 3 -p -0.1518073334 -3.335669728e-016 1.656332236 -p 0.6778413333 -4.351662757e-016 1.656332236 -p 1.350391 -3.681911102e-016 0.9837825694 -p 1.350391 -1.839642665e-016 0.1540986249 -p 1.384133465 -1.880963902e-016 0.1540986249 -p 1.620333757 -2.170216281e-016 0.1540986249 -p 1.654076222 -2.211537518e-016 0.1540986249 -p 1.574702016 -1.898192313e-016 0.05675645019 -p 1.019075428 2.952523203e-017 -0.6246475337 -p 0.939701222 6.085975248e-017 -0.7219897084 -p 0.860330936 4.896518348e-017 -0.6246475337 -p 0.3047317865 -3.42978701e-017 0.05675645019 -p 0.2253615 -4.619243911e-017 0.1540986249 -p 0.2596205833 -5.038782822e-017 0.1540986249 -p 0.49943725 -7.97559296e-017 0.1540986249 -p 0.5336963333 -8.395131871e-017 0.1540986249 -p 0.5336963333 -1.680207861e-016 0.5327138471 -p 0.2268078889 -1.985976221e-016 0.8396728471 -p -0.1518073334 -1.522321615e-016 0.8396728471 -p -0.5304225556 -1.058667008e-016 0.8396728471 -p -0.8373815556 -1.17716714e-019 0.5327138471 -p -0.8373815556 8.395175072e-017 0.1540986249 -p -0.8373815556 1.680212182e-016 -0.2245165973 -p -0.5304225556 1.985894139e-016 -0.5314755973 -p -0.1518073334 1.522239532e-016 -0.5314755973 -p -0.1518073334 1.447264858e-016 -0.497710006 -p -0.1518073334 9.224353927e-017 -0.2613478276 -p -0.1518073334 8.474607188e-017 -0.2275822362 -p -0.05446907836 9.045058159e-017 -0.3069564425 -p 0.6269074672 1.30382663e-016 -0.86258303 -p 0.7242457222 1.360871727e-016 -0.941957236 -p 0.6269074672 1.656318915e-016 -1.021331442 -p -0.05446907836 3.724475823e-016 -1.57695803 -p -0.1518073334 4.019923012e-016 -1.656332236 -p -0.1518073334 3.943886509e-016 -1.62208844 -p -0.1518073334 3.411624148e-016 -1.382378783 -p -0.1518073334 3.335587646e-016 -1.348134986 -p -0.9815230278 4.351662757e-016 -1.348134986 -p -1.654076222 3.681907588e-016 -0.6755817918 -p -1.654076222 1.839646985e-016 0.1540986249 -p -1.654076222 -2.621451406e-019 0.9837825694 -p -0.9815230278 -2.319594617e-016 1.656332236 -p -0.1518073334 -3.335669728e-016 1.656332236"; break;
		case "simpleCurve": $directions = "curve -d 3 -p 1.491982807 -8.32461314e-017 -0.5296378589 -p 1.094322782 3.11320802e-017 0.294937037 -p -0.0091184666 8.32461314e-017 0.529637859 -p -1.089040132 3.11320802e-017 0.294937037 -p -1.491982807 -8.13802097e-017 -0.521234495"; break;
		case "hexagon": $directions = "curve -d 1 -p 1.732069186 4.841823955e-016 1.000018152 -p 1.728708577e-005 1.991717776e-016 2 -p -1.732069186 -2.850108411e-016 1.000018152 -p -1.732069186 -4.841823955e-016 -1.000018152 -p 1.728708577e-005 -1.991641006e-016 -2 -p 1.732069186 2.850108411e-016 -1.000018152 -p 1.732069186 4.841823955e-016 1.000018152"; break;
		case "pentagon": $directions = "curve -d 1 -p 1.902094336 4.838950455e-016 1.236047533 -p -0.4489878479 3.792734978e-017 2 -p -1.902094336 -4.838950455e-016 -1.711825145e-015 -p -0.4489878479 -3.604085283e-016 -2 -p 1.902094336 2.377140058e-016 -1.236047533 -p 1.902094336 4.838950455e-016 1.236047533"; break;
		case "triangle": $directions = "curve -d 1 -p 1.732089031 8.881784197e-016 2 -p -1.732089031 -4.242328955e-016 -1.677410481e-005 -p 1.732089031 -8.881784197e-016 -2 -p 1.732089031 8.881784197e-016 2"; break;
		case "square": $directions = "curve -d 1 -p 2 2.449212707e-016 -2 -p 2 6.432571491e-016 2 -p -2 -2.449212707e-016 2 -p -2 -6.432571491e-016 -2 -p 2 2.449212707e-016 -2"; break;
		case "rightFoot": $directions = "curve -d 3 -p 0.06318265997 6.203348349e-016 -2.864061996 -p 0.35405183 5.763113415e-016 -2.867827055 -p 0.6910319521 5.03223827e-016 -2.762578432 -p 0.7665175589 4.211446138e-016 -2.412890286 -p 0.8420031658 3.390654006e-016 -2.063202141 -p 0.7025064917 1.781773447e-016 -1.158105227 -p 0.6544433436 1.254089529e-016 -0.8594840177 -p 0.5613395771 2.319404977e-017 -0.2810380245 -p 0.7874460407 -1.099241968e-016 0.2068702536 -p 0.8404922811 -1.538596233e-016 0.3843929599 -p 0.8935385215 -1.977950498e-016 0.5619156663 -p 1.322228305 -3.416252982e-016 0.9481911558 -p 1.306502307 -4.250885463e-016 1.374444873 -p 1.290776308 -5.085517943e-016 1.800698592 -p 1.241162247 -6.839057219e-016 2.708910254 -p 0.8524506908 -6.357743351e-016 2.767050547 -p 0.1786839945 -5.523465979e-016 2.867827055 -p -0.8717223576 -2.247705011e-016 2.044665902 -p -1.096975331 -1.007922303e-016 1.601468152 -p -1.322228305 2.318604052e-017 1.158270402 -p -0.9126966985 1.518189813e-017 0.8850652409 -p -0.8308564474 1.064731548e-016 0.3694411534 -p -0.7490161963 1.977644115e-016 -0.1461829341 -p -0.8609902906 3.716282977e-016 -0.9235268929 -p -0.8534468031 4.615886149e-016 -1.375773867 -p -0.8401568705 6.200876795e-016 -2.172577076 -p -0.3568401958 6.839057219e-016 -2.858624086 -p 0.06318265997 6.203348349e-016 -2.864061996"; break;
		case "pyramid": $directions = "curve -d 1 -p -1.19152376 -0.8425346782 -1.191524073 -p 1.191524021 -0.8425346782 -1.191523917 -p 5.200000844e-008 0.8425346782 5.199999977e-008 -p -1.19152376 -0.8425346782 -1.191524073 -p -1.191524021 -0.8425346782 1.191523916 -p 5.200000844e-008 0.8425346782 5.199999977e-008 -p 1.191523968 -0.8425346782 1.191524073 -p -1.191524021 -0.8425346782 1.191523916 -p 1.191523968 -0.8425346782 1.191524073 -p 1.191524021 -0.8425346782 -1.191523917"; break;
		case "diamond": $directions = "curve -d 1 -p 0 1.239355655 0 -p -1.514017025 0.0004742610035 -1.323595759e-007 -p -6.617978794e-008 0.0004742610035 1.514017025 -p 0 1.239355655 0 -p -6.617978794e-008 0.0004742610035 1.514017025 -p 0 -1.239355655 0 -p 1.985393517e-007 0.0004742610035 -1.514017025 -p 0 1.239355655 0 -p -1.514017025 0.0004742610035 -1.323595759e-007 -p 0 -1.239355655 0 -p 1.514017025 0.0004742610035 0 -p 0 1.239355655 0 -p -6.617978794e-008 0.0004742610035 1.514017025 -p -1.514017025 0.0004742610035 -1.323595759e-007 -p 1.985393517e-007 0.0004742610035 -1.514017025 -p 1.514017025 0.0004742610035 0 -p -6.617978794e-008 0.0004742610035 1.514017025"; break;
		case "wedge": $directions = "curve -d 1 -p 1.30736962 -0.5857146082 1.192092896e-007 -p -1.307369381 -0.5857146082 -1.509620428 -p -1.30736962 -0.5857146082 1.509620428 -p 1.30736962 -0.5857146082 1.192092896e-007 -p -1.30736962 0.5857146082 1.509620428 -p -1.30736962 -0.5857146082 1.509620428 -p -1.30736962 0.5857146082 1.509620428 -p -1.307369381 0.5857146082 -1.509620428 -p -1.307369381 -0.5857146082 -1.509620428 -p 1.30736962 -0.5857146082 1.192092896e-007 -p -1.307369381 0.5857146082 -1.509620428"; break;
		case "cone": $directions = "curve -d 1 -p 0.52405353 -1.12549606 -0.9076867709 -p -0.5240531214 -1.12549606 -0.9076870161 -p 0 1.12549606 4.085917841e-008 -p 0.52405353 -1.12549606 -0.9076867709 -p 1.04810657 -1.12549606 4.085917841e-008 -p 0 1.12549606 4.085917841e-008 -p 0.524053244 -1.12549606 0.9076870161 -p -0.5240534074 -1.12549606 0.9076869344 -p 0 1.12549606 4.085917841e-008 -p -1.04810657 -1.12549606 -1.15320871e-007 -p -0.5240531214 -1.12549606 -0.9076870161 -p 0 1.12549606 4.085917841e-008 -p 0.52405353 -1.12549606 -0.9076867709 -p 1.04810657 -1.12549606 4.085917841e-008 -p 0.524053244 -1.12549606 0.9076870161 -p -0.5240534074 -1.12549606 0.9076869344 -p -1.04810657 -1.12549606 -1.15320871e-007 -p -0.5240531214 -1.12549606 -0.9076870161"; break;
		case "cube": $directions = "curve -d 1 -p -0.9570669451 0.9570669451 0.9570669451 -p -0.9570669451 -0.9570669451 0.9570669451 -p -0.9570669451 -0.9570669451 -0.9570669451 -p -0.9570669451 0.9570669451 -0.9570669451 -p -0.9570669451 0.9570669451 0.9570669451 -p 0.9570669451 0.9570669451 0.9570669451 -p 0.9570669451 -0.9570669451 0.9570669451 -p -0.9570669451 -0.9570669451 0.9570669451 -p -0.9570669451 -0.9570669451 -0.9570669451 -p 0.9570669451 -0.9570669451 -0.9570669451 -p 0.9570669451 0.9570669451 -0.9570669451 -p -0.9570669451 0.9570669451 -0.9570669451 -p 0.9570669451 0.9570669451 -0.9570669451 -p 0.9570669451 0.9570669451 0.9570669451 -p 0.9570669451 -0.9570669451 0.9570669451 -p 0.9570669451 -0.9570669451 -0.9570669451"; break;
		case "circle": $directions = "curve -d 3 -p 1.546937353 -3.552300952e-015 0.001858757955 -p 1.551310359 -3.601799394e-015 -0.2185947654 -p 1.411065616 -3.74063061e-015 -0.8438349798 -p 0.7409117157 -3.871883216e-015 -1.431242701 -p -0.003372160999 -3.907345872e-015 -1.609459626 -p -0.7977262653 -3.867324423e-015 -1.426751398 -p -1.432580307 -3.725690505e-015 -0.7790183706 -p -1.61284924 -3.552300952e-015 0.001858757955 -p -1.433393638 -3.3769048e-015 0.78930516 -p -0.7944704785 -3.236137647e-015 1.4257317 -p 0.0003293026186 -3.198081485e-015 1.609459626 -p 0.7569824352 -3.230900316e-015 1.432481619 -p 1.415849742 -3.361567623e-015 0.8250858975 -p 1.548001191 -3.511490203e-015 0.2362406989 -p 1.546937353 -3.552300952e-015 0.001858757955"; break;
		case "sphere": $directions = "curve -d 1 -p -7.058219961e-008 1.489694643 -4.207026559e-015 -p -7.058219961e-008 1.376298421 -0.5700813997 -p -7.058219961e-008 1.05337317 -1.053373099 -p -7.058219961e-008 0.5700814703 -1.37629828 -p -7.058219961e-008 0 -1.489694502 -p -7.058219961e-008 -0.5700814703 -1.37629828 -p -7.058219961e-008 -1.05337317 -1.053373099 -p -7.058219961e-008 -1.376298421 -0.5700813997 -p -7.058219961e-008 -1.489694643 -4.207026559e-015 -p -7.058219961e-008 -1.376298421 0.570081435 -p -7.058219961e-008 -1.05337317 1.05337317 -p -7.058219961e-008 -0.5700814703 1.37629828 -p -7.058219961e-008 0 1.489694502 -p -7.058219961e-008 0.5700814703 1.37629828 -p -7.058219961e-008 1.05337317 1.05337317 -p -7.058219961e-008 1.376298421 0.570081435 -p -7.058219961e-008 1.489694643 -4.207026559e-015 -p -0.5700814703 1.376298421 -4.207026559e-015 -p -1.05337317 1.05337317 -4.207026559e-015 -p -1.37629835 0.5700814703 -4.207026559e-015 -p -1.489694573 0 -4.207026559e-015 -p -1.37629835 -0.5700814703 -4.207026559e-015 -p -1.05337317 -1.05337317 -4.207026559e-015 -p -0.5700814703 -1.376298421 -4.207026559e-015 -p -7.058219961e-008 -1.489694643 -4.207026559e-015 -p 0.5700813997 -1.376298421 -4.207026559e-015 -p 1.05337317 -1.05337317 -4.207026559e-015 -p 1.37629835 -0.5700814703 -4.207026559e-015 -p 1.489694573 0 -4.207026559e-015 -p 1.37629835 0.5700814703 -4.207026559e-015 -p 1.05337317 1.05337317 -4.207026559e-015 -p 0.5700813997 1.376298421 -4.207026559e-015 -p -7.058219961e-008 1.489694643 -4.207026559e-015 -p -0.5700814703 1.376298421 -4.207026559e-015 -p -1.05337317 1.05337317 -4.207026559e-015 -p -1.37629835 0.5700814703 -4.207026559e-015 -p -1.489694573 0 -4.207026559e-015 -p -1.05337317 0 1.053373099 -p -7.058219961e-008 0 1.489694502 -p 1.053373099 0 1.05337317 -p 1.489694573 0 -4.207026559e-015 -p 1.053373029 0 -1.053373099 -p -7.058219961e-008 0 -1.489694502 -p -1.05337317 0 -1.053373099 -p -1.489694573 0 -4.207026559e-015"; break;
		case "fourWayArrowCurved": $directions = "curve -d 3 -p 2.70241849 -0.2829757136 6.106226635e-016 -p 2.702419211 -0.2829760364 -5.879629637e-007 -p 2.702419932 -0.2829763592 -1.175925928e-006 -p 2.702420653 -0.2829766819 -1.763888892e-006 -p 2.416297902 -0.1549005005 -0.2333103608 -p 2.125557768 -0.06151542042 -0.4703840392 -p 1.826332319 -0.001323453938 -0.7143767639 -p 1.826332319 0.008067472117 -0.6116090694 -p 1.826332319 0.01745839817 -0.508841375 -p 1.826332319 0.02684932423 -0.4060736806 -p 1.359722433 0.1643729746 -0.4060736806 -p 0.8918987168 0.2507550485 -0.4060736806 -p 0.4060913194 0.2829766819 -0.4060736806 -p 0.4060993822 0.2507560034 -0.8918809259 -p 0.4060913194 0.1643757237 -1.359704545 -p 0.4060913194 0.02685334396 -1.826314681 -p 0.508857838 0.01746227122 -1.826314681 -p 0.6116243565 0.008071198482 -1.826314681 -p 0.714390875 -0.001319874258 -1.826314681 -p 0.4703982402 -0.06151042729 -2.125540018 -p 0.233324556 -0.1548940867 -2.41628016 -p 1.5875e-005 -0.2829687863 -2.702403014 -p -0.2332946263 -0.1548931198 -2.416280898 -p -0.4703660114 -0.06150806036 -2.125540606 -p -0.714359125 -0.001316196471 -1.826314681 -p -0.6116031898 0.00807365034 -1.826314681 -p -0.5088472546 0.01746349715 -1.826314681 -p -0.4060913194 0.02685334396 -1.826314681 -p -0.4060913194 0.1643757237 -1.359704545 -p -0.4060993824 0.2507560034 -0.8918809259 -p -0.4060913194 0.2829766819 -0.4060736806 -p -0.8918987168 0.2507550485 -0.4060736806 -p -1.359722433 0.1643729746 -0.4060736806 -p -1.826332319 0.02684932423 -0.4060736806 -p -1.826332319 0.01745839817 -0.508841375 -p -1.826332319 0.008067472117 -0.6116090694 -p -1.826332319 -0.001323453938 -0.7143767639 -p -2.125557768 -0.06151542042 -0.4703840392 -p -2.416297902 -0.1549005005 -0.2333103608 -p -2.702420653 -0.2829766819 -1.763888891e-006 -p -2.416297914 -0.1549003616 0.2333068229 -p -2.125557775 -0.06151514588 0.470380505 -p -1.826332319 -0.001323045295 0.7143732361 -p -1.826332319 0.008066958569 0.6116184769 -p -1.826332319 0.01745696243 0.5088637176 -p -1.826332319 0.0268469663 0.4061089583 -p -1.359722343 0.1643706756 0.4061089583 -p -0.891898694 0.2507522819 0.4061170212 -p -0.4060913194 0.2829743421 0.4061089583 -p -0.4060913194 0.2507521621 0.8919038947 -p -0.4060913194 0.1643722632 1.359716286 -p -0.4060913194 0.02685334396 1.826314681 -p -0.5088472546 0.01746349715 1.826314681 -p -0.6116031898 0.00807365034 1.826314681 -p -0.714359125 -0.001316196471 1.826314681 -p -0.4703660114 -0.06150806037 2.125540606 -p -0.2332946264 -0.1548931198 2.416280898 -p 1.5875e-005 -0.2829687863 2.702403014 -p 0.233324556 -0.1548940867 2.41628016 -p 0.4703982402 -0.06151042729 2.125540018 -p 0.714390875 -0.001319874258 1.826314681 -p 0.6116243565 0.008071198482 1.826314681 -p 0.508857838 0.01746227122 1.826314681 -p 0.4060913194 0.02685334396 1.826314681 -p 0.4060913194 0.1643722632 1.359716286 -p 0.4060913194 0.2507521621 0.8919038947 -p 0.4060913194 0.2829743421 0.4061089583 -p 0.891898694 0.2507522819 0.4061170212 -p 1.359722343 0.1643706756 0.4061089583 -p 1.826332319 0.0268469663 0.4061089583 -p 1.826332319 0.01745696243 0.5088637176 -p 1.826332319 0.008066958569 0.6116184769 -p 1.826332319 -0.001323045295 0.7143732361 -p 2.125557015 -0.06151499283 0.4703811254 -p 2.416296434 -0.1548998876 0.2333080307 -p 2.70241849 -0.2829757136 6.106226635e-016"; break;
		case "leftFoot": $directions = "curve -d 3 -p -0.06318265997 6.203348349e-016 -2.864061996 -p -0.35405183 5.763113415e-016 -2.867827055 -p -0.6910319521 5.03223827e-016 -2.762578432 -p -0.7665175589 4.211446138e-016 -2.412890286 -p -0.8420031658 3.390654006e-016 -2.063202141 -p -0.7025064917 1.781773447e-016 -1.158105227 -p -0.6544433436 1.254089529e-016 -0.8594840177 -p -0.5613395771 2.319404977e-017 -0.2810380245 -p -0.7874460407 -1.099241968e-016 0.2068702536 -p -0.8404922811 -1.538596233e-016 0.3843929599 -p -0.8935385215 -1.977950498e-016 0.5619156663 -p -1.322228305 -3.416252982e-016 0.9481911558 -p -1.306502307 -4.250885463e-016 1.374444873 -p -1.290776308 -5.085517943e-016 1.800698592 -p -1.241162247 -6.839057219e-016 2.708910254 -p -0.8524506908 -6.357743351e-016 2.767050547 -p -0.1786839945 -5.523465979e-016 2.867827055 -p 0.8717223576 -2.247705011e-016 2.044665902 -p 1.096975331 -1.007922303e-016 1.601468152 -p 1.322228305 2.318604052e-017 1.158270402 -p 0.9126966985 1.518189813e-017 0.8850652409 -p 0.8308564474 1.064731548e-016 0.3694411534 -p 0.7490161963 1.977644115e-016 -0.1461829341 -p 0.8609902906 3.716282977e-016 -0.9235268929 -p 0.8534468031 4.615886149e-016 -1.375773867 -p 0.8401568705 6.200876795e-016 -2.172577076 -p 0.3568401958 6.839057219e-016 -2.858624086 -p -0.06318265997 6.203348349e-016 -2.864061996"; break;
		case "eyeHolder_2": $directions = "curve -d 3 -p -3.316111111 4.060934653e-016 0 -p -3.316111111 5.618402142e-016 -0.701421 -p -1.831449361 5.062774923e-016 -1.27 -p 8.881784197e-016 2.819970399e-016 -1.27 -p 1.831445833 5.77170195e-017 -1.27 -p 3.316111111 -2.503459332e-016 -0.701421 -p 3.316111111 -4.06092682e-016 0 -p 3.316111111 -5.618402142e-016 0.7014245278 -p 1.831445833 -5.06276277e-016 1.27 -p 8.881784197e-016 -2.819962566e-016 1.27 -p -1.831449361 -5.771580416e-017 1.27 -p -3.316111111 2.503459332e-016 0.7014245278 -p -3.316111111 4.060934653e-016 0"; break;
		case "leftEye_2": $directions = "curve -d 3 -p -0.4016727781 -5.702313928e-017 0.550370375 -p -0.457446944 -3.099294428e-017 0.4639010139 -p -0.490195305 -4.163547078e-018 0.3611333195 -p -0.490195305 2.038426122e-017 0.2505798195 -p -0.490195305 8.835876992e-017 -0.05555015277 -p -0.242044361 1.130784592e-016 -0.303736375 -p 0.06408913895 7.558915632e-017 -0.303736375 -p 0.370219111 3.810028542e-017 -0.303736375 -p 0.618370056 -4.739684858e-017 -0.05555015277 -p 0.618370056 -1.153713573e-016 0.2505798195 -p 0.618370056 -1.39712368e-016 0.3602019861 -p 0.586105 -1.58403933e-016 0.4621759306 -p 0.531156333 -1.707762407e-016 0.5482007917 -p 0.794603722 -1.870732484e-016 0.4763011528 -p 1.040892 -1.895120302e-016 0.3514530972 -p 1.12836325 -1.502101429e-016 0.1262115417 -p 1.087074139 -6.865756128e-017 -0.218297125 -p 0.615717167 4.976489162e-017 -0.491664625 -p 0.280285472 9.61898231e-017 -0.5157487639 -p -0.201425528 1.628680002e-016 -0.550370375 -p -0.8541349721 1.895120302e-016 -0.3103862361 -p -1.12836325 1.66050194e-016 -0.05348287499 -p -0.9588817499 7.766553562e-017 0.251094875 -p -0.6787268055 -6.284106775e-019 0.4491901806 -p -0.4016727781 -5.702313928e-017 0.550370375"; break;
		case "rightEye_2": $directions = "curve -d 3 -p 0.4016727778 -1.722533865e-016 0.550370375 -p 0.4574469444 -1.598834713e-016 0.4639010139 -p 0.4901953056 -1.410748443e-016 0.3611333195 -p 0.4901953056 -1.16527036e-016 0.2505798195 -p 0.4901953056 -4.855252723e-017 -0.05555015277 -p 0.242044361 3.694460667e-017 -0.303736375 -p -0.064089139 7.443390967e-017 -0.303736375 -p -0.370219111 1.119227806e-016 -0.303736375 -p -0.618370056 8.720309117e-017 -0.05555015277 -p -0.618370056 1.922858247e-017 0.2505798195 -p -0.618370056 -5.112428233e-018 0.3602019861 -p -0.586105 -3.170639163e-017 0.4621759306 -p -0.531156333 -5.753679653e-017 0.5482007917 -p -0.794603722 -9.309935033e-018 0.4763011528 -p -1.040892 4.857252117e-017 0.3514530972 -p -1.12836325 1.092979782e-016 0.1262115417 -p -1.087074139 1.807379782e-016 -0.218297125 -p -0.615717167 1.837150825e-016 -0.491664625 -p -0.280285472 1.479856571e-016 -0.5157487639 -p 0.201425528 9.668256397e-017 -0.550370375 -p 0.8541349722 -3.653583263e-017 -0.3103862361 -p 1.12836325 -1.271620071e-016 -0.05348287499 -p 0.95888175 -1.740370411e-016 0.251094875 -p 0.6787268056 -1.837150825e-016 0.4491901806 -p 0.4016727778 -1.722533865e-016 0.550370375"; break;
		case "eyeHolder_1": $directions = "curve -d 3 -p -2.961370125 3.626512671e-016 -3.552713679e-015 -p -2.961370125 5.017374973e-016 -0.6263886944 -p -1.635525403 4.521175368e-016 -1.13414175 -p 1.763888889e-006 2.518298408e-016 -1.13414175 -p 1.635525403 5.15425768e-017 -1.13414175 -p 2.961370125 -2.235650369e-016 -0.6263886944 -p 2.961370125 -3.626512671e-016 -3.552713679e-015 -p 2.961370125 -5.017374973e-016 0.6263886944 -p 1.635525403 -4.521175368e-016 1.13414175 -p 1.763888889e-006 -2.518302728e-016 1.13414175 -p -1.635525403 -5.15425768e-017 1.13414175 -p -2.961370125 2.235650369e-016 0.6263886944 -p -2.961370125 3.626512671e-016 -3.552713679e-015"; break;
		case "leftEye_1": $directions = "curve -d 3 -p -0.7168620833 7.847402785e-018 0.3223401111 -p -0.7204110277 1.341513109e-017 0.2992225833 -p -0.7228063889 1.892540649e-017 0.2757275833 -p -0.7228063889 2.427237629e-017 0.2516469722 -p -0.7228063889 8.114013373e-017 -0.004462638889 -p -0.5152037222 1.01813248e-016 -0.2120617778 -p -0.2591117503 7.04520624e-017 -0.2120617778 -p -0.0030233053 3.909130879e-017 -0.2120617778 -p 0.2045793607 -3.242811451e-017 -0.004462638889 -p 0.2045793607 -8.929587191e-017 0.2516469722 -p 0.2045793607 -1.107378003e-016 0.3482128333 -p 0.1750024727 -1.270239758e-016 0.4378713056 -p 0.1244635277 -1.373199986e-016 0.5121133889 -p 0.5097109727 -1.671407517e-016 0.4339448889 -p 1.048340396 -1.384284983e-016 0.007574903241 -p 1.050141833 -1.383324707e-016 0.006148916667 -p 0.8592149723 -6.044384391e-017 -0.2393315 -p 0.4500774167 5.022914789e-017 -0.5121133889 -p 0.1500258057 8.697365884e-017 -0.5121133889 -p -0.5046098055 1.671407517e-016 -0.5121133889 -p -0.8591973333 1.62103425e-016 -0.2938674167 -p -1.050141833 1.067601955e-016 0.06068483333 -p -0.9762101944 7.659746426e-017 0.1557513889 -p -0.8570101111 4.183895259e-017 0.2465493333 -p -0.7168620833 7.847402785e-018 0.3223401111"; break;
		case "rightEye_1": $directions = "curve -d 3 -p 0.7168656113 -1.639283996e-016 0.3223401111 -p 0.7204145557 -1.592298832e-016 0.2992225833 -p 0.7228063891 -1.543058507e-016 0.2757275833 -p 0.7228063891 -1.489588809e-016 0.2516469722 -p 0.7228063891 -9.209112348e-017 -0.004462638889 -p 0.5152072502 -2.057213222e-017 -0.2120617778 -p 0.2591152774 1.078905338e-017 -0.2120617778 -p 0.00302330545 4.215023898e-017 -0.2120617778 -p -0.2045793605 2.147712468e-017 -0.004462638889 -p -0.2045793605 -3.539063272e-017 0.2516469722 -p -0.2045793605 -5.683256122e-017 0.3482128333 -p -0.1750024726 -8.036274582e-017 0.4378713056 -p -0.1244635276 -1.030368311e-016 0.5121133889 -p -0.5097109725 -3.850229062e-017 0.4339448889 -p -1.048340396 1.22131766e-016 0.007574903241 -p -1.050141833 1.226690037e-016 0.006148916667 -p -0.8592149725 1.537955811e-016 -0.2393315 -p -0.4500738886 1.642616508e-016 -0.5121133889 -p -0.1500258056 1.275175719e-016 -0.5121133889 -p 0.5046133335 4.735004698e-017 -0.5121133889 -p 0.8591973335 -4.453287562e-017 -0.2938674167 -p 1.050141833 -1.466424747e-016 0.06068483333 -p 0.9762101945 -1.58697775e-016 0.1557513889 -p 0.8570101112 -1.642616508e-016 0.2465493333 -p 0.7168656113 -1.639283996e-016 0.3223401111"; break;
		case "star": $directions = "curve -d 1 -p 4.136342832e-006 3.507139171e-016 1.574294764 -p 0.4483431619 3.507139171e-016 0.4508811256 -p 1.655311323 3.20815096e-017 0.3716434898 -p 0.7254313938 -7.740425674e-017 -0.4019106506 -p 1.023042663 -3.507139171e-016 -1.574294764 -p 1.061470089e-006 -2.042082642e-016 -0.9289619621 -p -1.023034041 -3.507137159e-016 -1.57429398 -p -0.7254222595 -7.740298536e-017 -0.4019042755 -p -1.655311323 3.208211014e-017 0.3716441484 -p -0.5690329816 3.188507364e-016 0.4429598677 -p 4.136342832e-006 3.507139171e-016 1.574294764"; break;
		case "star1": $directions = "curve -d 1 -p 4.061744194e-006 3.006913913e-016 1.354193638 -p 0.4576062361 3.006913913e-016 1.707772517 -p 0.6771051956 2.764271376e-016 1.172768908 -p 1.25017858 2.743245875e-016 1.250170404 -p 1.172777397 1.510129357e-016 0.6770975918 -p 1.707785327 1.014703209e-016 0.4575947092 -p 1.354201648 2.706829724e-020 -3.179268949e-006 -p 1.707785965 -1.016137352e-016 -0.4576020564 -p 1.172777942 -1.50346153e-016 -0.6771040867 -p 1.25017926 -2.775954695e-016 -1.25017779 -p 0.6771073481 -2.604092926e-016 -1.172779411 -p 0.4575996775 -3.792026117e-016 -1.707776695 -p -8.724864601e-006 -3.006930827e-016 -1.354201273 -p -0.4576042094 -3.792018713e-016 -1.70777336 -p -0.6771189109 -2.60405873e-016 -1.17276401 -p -1.250185239 -2.775942557e-016 -1.250172323 -p -1.172773534 -1.503401313e-016 -0.6770769683 -p -1.707796469 -1.016121026e-016 -0.4575947024 -p -1.354185503 2.99797652e-020 9.930845686e-006 -p -1.707787678 1.014713003e-016 0.4575991166 -p -1.172765547 1.510125537e-016 0.677095857 -p -1.250169545 2.74324514e-016 1.250170012 -p -0.6770964489 2.764269275e-016 1.172768282 -p -0.4795462095 2.982649449e-016 1.654272164 -p 4.061744194e-006 3.006913913e-016 1.354193638"; break;
		case "star2": $directions = "curve -d 1 -p 0 3.184379554e-016 1.434117057 -p 0.2585374548 3.184379554e-016 1.632383541 -p 0.4431666299 3.118348089e-016 1.363918659 -p 0.7503239032 3.251489358e-016 1.472597395 -p 0.8429510582 2.579924383e-016 1.160209917 -p 1.168652347 2.594151329e-016 1.168645684 -p 1.160218835 1.871856583e-016 0.8429391055 -p 1.472585945 1.666011086e-016 0.750319008 -p 1.363907423 9.839997349e-017 0.443151162 -p 1.632387084 5.740854378e-017 0.2585456926 -p 1.434090436 1.502476341e-021 6.644875207e-006 -p 1.632383891 -5.740616099e-017 -0.2585343404 -p 1.363905697 -9.839791945e-017 -0.4431448385 -p 1.472579458 -1.666016841e-016 -0.7503072814 -p 1.160215127 -1.871717806e-016 -0.8429467614 -p 1.168646713 -2.594920104e-016 -1.168648121 -p 0.842945567 -2.576200165e-016 -1.16021741 -p 0.7503051693 -3.26978815e-016 -1.47258167 -p 0.4431415674 -3.028482973e-016 -1.363907479 -p 0.2585320214 -3.624617615e-016 -1.632382654 -p -1.676819145e-006 -3.184330345e-016 -1.434094896 -p -0.2585343448 -3.624616203e-016 -1.632382018 -p -0.4431462369 -3.028482981e-016 -1.363907482 -p -0.7503072085 -3.269782548e-016 -1.472579147 -p -0.8429491944 -2.576196435e-016 -1.16021573 -p -1.168649352 -2.594916529e-016 -1.168646511 -p -1.16021638 -1.871709056e-016 -0.8429428209 -p -1.472583305 -1.666014853e-016 -0.7503063863 -p -1.363905598 -9.839750762e-017 -0.4431429837 -p -1.632384466 -5.740592112e-017 -0.2585332601 -p -1.434090715 1.879755997e-021 8.343995287e-006 -p -1.632386475 5.740879466e-017 0.2585468225 -p -1.363907142 9.840032914e-017 0.4431527638 -p -1.472587818 1.666012888e-016 0.7503198196 -p -1.160218819 1.871854847e-016 0.8429383229 -p -1.168652893 2.594150897e-016 1.168645491 -p -0.8429515076 2.579923294e-016 1.160209423 -p -0.750324342 3.251488572e-016 1.472597025 -p -0.4431679377 3.11834848e-016 1.363919229 -p -0.2770005521 3.177776447e-016 1.605537148 -p 0 3.184379554e-016 1.434117057"; break;
		case "star3": $directions = "curve -d 1 -p 1.073841842e-015 4.038637772e-016 1.818840756 -p 0.1963090838 4.038637772e-016 0.9869130102 -p 0.6960591757 3.352535317e-016 1.680385963 -p 0.559054647 1.935382562e-016 0.8366578999 -p 1.286139925 2.839868753e-016 1.286130238 -p 0.8366495027 1.244525777e-016 0.5590153548 -p 1.680420473 1.544894361e-016 0.6960597407 -p 0.9869084139 4.360184999e-017 0.1963035392 -p 1.818865945 -2.80994677e-021 4.888041789e-011 -p 0.9869084145 -4.358756585e-017 -0.1963035394 -p 1.68042047 -1.545564279e-016 -0.6960597396 -p 0.8366495158 -1.241263207e-016 -0.5590153604 -p 1.286139861 -2.855782795e-016 -1.286130211 -p 0.559054958 -1.857754018e-016 -0.8366580349 -p 0.6960576588 -3.731204913e-016 -1.680385305 -p 0.1963164834 -2.191394229e-016 -0.9869162236 -p 1.751439113e-015 -4.038621878e-016 -1.818833599 -p -0.1963164834 -2.191394229e-016 -0.9869162236 -p -0.6960576588 -3.731204913e-016 -1.680385305 -p -0.559054958 -1.857754018e-016 -0.8366580349 -p -1.286139861 -2.855782795e-016 -1.286130211 -p -0.8366495158 -1.241263207e-016 -0.5590153604 -p -1.68042047 -1.545564279e-016 -0.6960597396 -p -0.9869084145 -4.358756585e-017 -0.1963035394 -p -1.818865945 -2.809946771e-021 4.888012291e-011 -p -0.9869084139 4.360184999e-017 0.1963035392 -p -1.680420473 1.544894361e-016 0.6960597407 -p -0.8366495027 1.244525777e-016 0.5590153548 -p -1.286139925 2.839868753e-016 1.286130238 -p -0.559054647 1.935382562e-016 0.8366578999 -p -0.6960591757 3.352535317e-016 1.680385963 -p -0.1378439787 4.118903995e-016 0.9057845227 -p 1.073841842e-015 4.038637772e-016 1.818840756"; break;
		case "bloatedTriangle": $directions = "curve -d 1 -p -3.393338327e-005 9.62758465e-017 -1.487912969 -p 1.099122645 5.528840826e-016 -1.246247656 -p 1.879556526 8.346907722e-016 -0.7495368539 -p 1.195622399 2.956979196e-016 1.054518285 -p -3.393338327e-005 -3.606915951e-016 2.016195826 -p -1.195588466 -7.662130238e-016 1.054518285 -p -1.879556526 -8.346907722e-016 -0.7495368539 -p -1.099122645 -4.233329306e-016 -1.246247656 -p -3.393338327e-005 9.62758465e-017 -1.487912969"; break;
		case "octagonFilled": $directions = "curve -d 1 -p -1.542706563 0 0 -p -1.09085832 0 -1.090858348 -p 2.74106296e-008 0 -1.54270659 -p 1.090858375 0 -1.090858348 -p 1.542706801 0 0 -p 1.090858467 0 1.090858439 -p 2.74106296e-008 0 1.54270659 -p -1.09085832 0 1.090858348 -p -1.542706563 0 0 -p 1.542706801 0 0 -p 2.74106296e-008 0 0 -p 2.74106296e-008 0 1.54270659 -p 2.74106296e-008 0 -1.54270659 -p 2.74106296e-008 0 0 -p -1.09085832 0 -1.090858348 -p 1.090858467 0 1.090858439 -p 2.74106296e-008 0 0 -p -1.09085832 0 1.090858348 -p 1.090858375 0 -1.090858348"; break;
		case "flattenedCircle": $directions = "curve -d 3 -p -1.893523879 3.626512671e-016 -3.552713679e-015 -p -1.893523879 5.017374973e-016 -0.6263886944 -p -1.008773226 4.521175368e-016 -1.181523364 -p 0 2.518300568e-016 -1.314058341 -p 1.008773226 5.15425768e-017 -1.181523364 -p 1.759554072 -2.235650369e-016 -0.6263886944 -p 1.893523879 -3.626512671e-016 -3.552713679e-015 -p 1.759554072 -5.017374973e-016 0.6263886944 -p 1.008773226 -4.521175368e-016 1.181523364 -p 0 -2.518300568e-016 1.314058341 -p -1.008773226 -5.15425768e-017 1.181523364 -p -1.893523879 2.235650369e-016 0.6263886944 -p -1.893523879 3.626512671e-016 -3.552713679e-015"; break;
	}
	
	if ($directions != ""){
		string $tWire = eval($directions);
		
		if ($facingAxis == 0){
			rotate -r -ws -90 -90 0 $tWire; 
		}else if ($facingAxis == 2){
			rotate -r -ws 90 -180 0 $tWire; 
		}else if ($facingAxis == 3){
			rotate -r -ws -90 90 0 $tWire; 
		}else if ($facingAxis == 4){
			rotate -r -ws -180 0 0 $tWire; 
		}else if ($facingAxis == 5){
			rotate -r -ws -90 180 0 $tWire; 
		}
		
		if ($size != 0){
			
			string $scaleStr = abRTGetGlobal("globalScale");
			if ($scaleStr == "") $scaleStr = "1";
			float $gScale = float($scaleStr);
			float $maxDim = abRTGetMaxDim($tWire);
			float $scale = ($size/$maxDim)*$gScale;
			scale -relative $scale $scale $scale $tWire;
			
		}
		
		if (size($aOffset) == 3) xform -ws -t $aOffset[0] $aOffset[1] $aOffset[2] $tWire;
		
		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $tWire;
		
		if ($getIns){
			$directions = re_getCurvePointInfo($tWire);
			delete $tWire;
			$ret = $directions;
		}else{
			$ret = $tWire;
		}
	}
	
	return $ret;
}


global proc abRTWireReplaceUI(){
	// replace existing wires on a rig
	
	
	if (`window -exists abRTWrRplcWin`){
		deleteUI -window abRTWrRplcWin;
	}
	window -t "abWireReplace" -w 168 -h 420 -minimizeButton false -maximizeButton false abRTWrRplcWin;
	
	int $lmargin = 3;
	int $rmargin = 3;
	
	formLayout -numberOfDivisions 100 abTRWrRplcForm;
	
	string $aWireTypes[] = {"flattenedCircle","simpleCurve","fatArrow","medArrow","fatFourWayArrowMed","fatFourWayArrow","fatFoutWayArrowSmall_1","twoWayArrow","medTwoWayArrow","fatCross","medCross","fatDoubleArrow180","fatDoubleArrow90","fatSingleArrow90","fatSingleArrow180","fatSingleArrow270","thinDoubleArrow90","thinDoubleArrow180","thinSingleArrow90","thinSingleArrow180","thinSingleArrow270","thinDoubleArrow270","fatDoubleArrow270","hexagon","pentagon","triangle","square","rightFoot","pyramid","diamond","wedge","cone","cube","circle","sphere","fourWayArrowCurved","leftFoot","eyeHolder_2","leftEye_2","rightEye_2","eyeHolder_1","leftEye_1","rightEye_1","bloatedTriangle","star","star1","star2","star3"};
	$aWireTypes = sort($aWireTypes);
	string $wireName;
	
	textScrollList -allowMultiSelection false -dcc "abRTServiceWireReplaceUI(\"Replace\");" abRTWRWireTypeTxtScrllLst;
	for ($wireName in $aWireTypes) textScrollList -e -append $wireName abRTWRWireTypeTxtScrllLst;
	
	radioCollection abRTWRFacingRdBnCol;
	radioButton -label "+X" abRTWRFacingXPosRdBn;
	radioButton -label "+Y" abRTWRFacingYPosRdBn;
	radioButton -label "+Z" abRTWRFacingZPosRdBn;
	radioButton -label "-X" abRTWRFacingXNegRdBn;
	radioButton -label "-Y" abRTWRFacingYNegRdBn;
	radioButton -label "-Z" abRTWRFacingZNegRdBn;
	setParent ..;
	
	radioCollection -e -sl abRTWRFacingYPosRdBn abRTWRFacingRdBnCol;
	
	button -l "Replace Selected" -c "abRTServiceWireReplaceUI(\"Replace\");" abRTWRReplaceBn;
	separator abRTWRSep1;
	button -l "Copy From To" -c "abRTServiceWireReplaceUI(\"Copy\");" abRTWRCopyBn;
	button -l "Mirror Selected" -c "abRTServiceWireReplaceUI(\"Mirror\");" abRTWRMirrorBn;
	
	separator abRTWRSep2;
	
	text -label "Wire Scale" abRTWRScaleTxt;
	string $cmd = "string $aSel[] = `textScrollList -q -si abRTWRWireTypeTxtScrllLst`; if (size($aSel) != 0) abRTServiceWireReplaceUI(\"Replace\");";
	floatField -min 0 -v 100 -step .5 -changeCommand $cmd -dragCommand ("undoInfo -swf off;"+$cmd+"undoInfo -swf on;") abRTWRScaleFltFld;
	
	
	formLayout -e
	
	-af abRTWRScaleTxt "bottom" 7
	-af abRTWRScaleTxt "left" ($lmargin*2)
	
	-af abRTWRScaleFltFld "bottom" 4
	-ac abRTWRScaleFltFld "left" 5 abRTWRScaleTxt
	-af abRTWRScaleFltFld "right" $rmargin
	
	-ac abRTWRSep2 "bottom" 5 abRTWRScaleFltFld
	-af abRTWRSep2 "left" $lmargin
	-af abRTWRSep2 "right" $rmargin
	
	-ac abRTWRMirrorBn "bottom" 4 abRTWRSep2
	-af abRTWRMirrorBn "left" $lmargin
	-af abRTWRMirrorBn "right" $rmargin
	
	-ac abRTWRCopyBn "bottom" 5 abRTWRMirrorBn
	-af abRTWRCopyBn "left" $lmargin
	-af abRTWRCopyBn "right" $rmargin
	
	-ac abRTWRSep1 "bottom" 5 abRTWRCopyBn
	-af abRTWRSep1 "left" $lmargin
	-af abRTWRSep1 "right" $rmargin
	
	-ac abRTWRReplaceBn "bottom" 6 abRTWRSep1
	-af abRTWRReplaceBn "left" $lmargin
	-af abRTWRReplaceBn "right" $rmargin
	
	-ac abRTWRFacingXNegRdBn "bottom" 5 abRTWRReplaceBn
	-af abRTWRFacingXNegRdBn "left"($lmargin*4)
	
	-ac abRTWRFacingYNegRdBn "bottom" 5 abRTWRReplaceBn
	-ap abRTWRFacingYNegRdBn "left" $lmargin 35
	
	-ac abRTWRFacingZNegRdBn "bottom" 5 abRTWRReplaceBn
	-af abRTWRFacingZNegRdBn "right" ($rmargin*3)
	
	-ac abRTWRFacingXPosRdBn "bottom" 6 abRTWRFacingXNegRdBn
	-af abRTWRFacingXPosRdBn "left" ($lmargin*4)
	
	-ac abRTWRFacingYPosRdBn "bottom" 6 abRTWRFacingXNegRdBn
	-ap abRTWRFacingYPosRdBn "left" $lmargin 35
	
	-ac abRTWRFacingZPosRdBn "bottom" 6 abRTWRFacingXNegRdBn
	-af abRTWRFacingZPosRdBn "right" ($rmargin*3)
	
	-af abRTWRWireTypeTxtScrllLst "top" 10
	-af abRTWRWireTypeTxtScrllLst "left" $lmargin
	-af abRTWRWireTypeTxtScrllLst "right" $rmargin
	-ac abRTWRWireTypeTxtScrllLst "bottom" 6 abRTWRFacingXPosRdBn
	
	abTRWrRplcForm;
	
	showWindow abRTWrRplcWin;
	
}


global proc abRTMakeCurSelWire(){
	// helper proc for me to modify wires -- makes a wire based on current selection in UI
	
	if (!`window -exists abRTWrRplcWin`) return;
	
	string $aWire[0] = `textScrollList -q -si abRTWRWireTypeTxtScrllLst`;
	string $newWire = abRTWireContoller($aWire[0], 1, {}, 0, false);
	abRTRename($newWire, $aWire[0]);
	
}


global proc abRTServiceWireReplaceUI(string $caller){
	
	// $caller can be "Copy", "Replace", "Mirror"
	
	string $aCurves[] = `ls -sl`;
	int $i;
	int $badSel = false;
	string $aStr[], $aCurveShapes[];
	for ($i=0;$i<size($aCurves);$i++){
		$aStr = `listRelatives -c -fullPath -type nurbsCurve $aCurves[0]`;
		if (size($aStr) == 1) $aCurveShapes[size($aCurveShapes)] = $aStr[0];
		else $badSel = true;
	}
	
	if ((size($aCurveShapes) != 1 && ($caller == "Replace" || $caller == "Mirror")) || (size($aCurveShapes) != 2 && $caller == "Copy")) $badSel = true;
	
	
	if (!$badSel){
		
		$aStr = `textScrollList -q -si abRTWRWireTypeTxtScrllLst`;
		string $wireType = $aStr[0];
		radioCollection -q -cia abRTWRFacingRdBnCol;
		
		string $aAxesCtrls[] = {"abRTWRFacingXPosRdBn","abRTWRFacingYPosRdBn","abRTWRFacingZPosRdBn","abRTWRFacingXNegRdBn","abRTWRFacingYNegRdBn","abRTWRFacingZNegRdBn"};
		string $slAxisCtrl = `radioCollection -q -sl abRTWRFacingRdBnCol`;
		int $slAxis = abRTGetPosInStrArray($slAxisCtrl, $aAxesCtrls);
		
		switch($caller){
			case "Copy":
			
			string $directions = re_getCurvePointInfo($aCurves[0]);
			string $replaceCmd = `substitute "curve -d" $directions "curve -r -ws -d"`;
			$replaceCmd += " "+$aCurves[1];
			eval ($replaceCmd);
			delete $aCurves[0];
			
			break;
			
			case "Replace":
			
			abRTReplaceWireController($aCurves[0], $wireType, $slAxis, true);
			select -r $aCurves[0];
			
			break;
			
			case "Mirror":
			
			string $mCtrl = abRTGetMirrorObj($aCurves[0]);
			if ($mCtrl != ""){
				
				string $directions = re_getCurvePointInfo($aCurves[0]);
				string $tCrv = eval($directions);
				setAttr ($tCrv+".sx") -1;
				
				string $directions = re_getCurvePointInfo($tCrv);
				string $replaceCmd = `substitute "curve -d" $directions "curve -r -ws -d"`;
				$replaceCmd += " "+$mCtrl;
				
				delete $tCrv;
				
				eval($replaceCmd);
				
				select -r $aCurves[0];
				
			}
			
			break;
		}
	}
}


global proc string[] abRTGetCtrlCrvs(string $rigGrp){
	// returns all control curves of a character given the rigGrp
	
	string $aRet[];
	
	if (objExists($rigGrp)){
		
		string $aOrigSel[] = `ls -sl`;
		
		string $aRigGrpContents[] = `listRelatives -ad -path -type transform $rigGrp`;
		string $curvesNameFilter = `itemFilter -byName "*_ctrl"`;
		
		select -r $aRigGrpContents;
		string $aCurves[] = `lsThroughFilter -selection $curvesNameFilter`;
		select -r $aOrigSel;
		
		delete $curvesNameFilter;
		
		$aRet = $aCurves;
	}
	
	print "\n\n"; // ignore "Some items can't be moved in 3d view" warning
	
	return $aRet;
}


global proc abRTCaptureControlCurves(){
	// select the rootCon and run this proc and a shelfButton will be created that can be used to rebuild all of your rig's control curves
	
	int $ok = false;
	
	string $rigGrp = abRTGetRigGrpFromSelCtrl();
	string $aCurves[] = abRTGetRigGrpCtrlCurves($rigGrp);
	string $charName = `substitute "_rig_grp" $rigGrp ""`;
	
	string $curve, $cmd;
	int $i;
	
	$cmd = "\""+$charName+"\",\n";
	for ($i=0;$i<size($aCurves);$i++){
		$curve = shortNameOf($aCurves[$i]);
		$cmd += "\"";
		$cmd += $curve;
		$cmd += ":";
		$cmd += re_getCurvePointInfo($curve);
		$cmd += "\"";
		if ($i<(size($aCurves)-1)) $cmd += ",\n";
	}
	
	$cmd = "abRTRecallControlCurves({\n"+$cmd+"\n});";
	
	string $parent = `shelfTabLayout -q -selectTab ShelfLayout`;
	string $charBn = `shelfButton -i "abAutoRigCurve.bmp" -iol $charName -ann "Restore control curves" -parent $parent -c $cmd`;
	
	if (size($aCurves) > 0) print ("Saved "+size($aCurves)+" curves to shelfButton \"crv\"");
	
}


global proc abRTRecallControlCurves(string $aData[]){
	// aData in the form of ["charName","curveName:curveDirections","curveName:curveDirections"]
	
	if (size($aData) == 0) return;
	
	int $ok = false;
	
	// get rigGrp, charName and control curves
	string $rigGrp = abRTGetRigGrpFromSelCtrl();
	string $aCurves[] = abRTGetRigGrpCtrlCurves($rigGrp);
	string $cCharName = `substitute "_rig_grp" $rigGrp ""`;
	
	// break data into two arrays for quick sorting; substitute new char name
	
	string $dataCharName = $aData[0];
	
	string $aCurveName[], $aDirections[], $aStr[];
	int $i;
	
	for ($i=1;$i<size($aData);$i++){
		$aStr = stringToStringArray($aData[$i], ":");
		$aCurveName[size($aCurveName)] = `substitute $dataCharName $aStr[0] $cCharName`;
		$aDirections[size($aDirections)] = $aStr[1];
	}
	
	int $count = 0;
	int $k;
	string $curve, $shortName, $cmd;
	
	for ($k=0;$k<size($aCurves);$k++){
		
		$curve = $aCurves[$k];
		$shortName = shortNameOf($curve);
		
		// search for $shortName and, if found, apply curve directions to $curve
		for ($i=0;$i<size($aCurveName);$i++){
			if ($shortName == $aCurveName[$i]){
				$cmd = `substitute "curve -d" $aDirections[$i] "curve -r -ws -d"`;
				$cmd += " "+$curve;
				eval ($cmd);
				$count ++;
				break;
			}
		}
	}
	
	if ($count > 0) print ("Replaced "+$count+" curves");
	
}


global proc float abRTGetMaxDim(string $obj){
	// returns the max dimension of $obj boundingBox
	
	float $aBBox[] = `xform -q -ws -boundingBox $obj`;
	float $aDim[] = {abs($aBBox[3]-$aBBox[0]),abs($aBBox[4]-$aBBox[1]),abs($aBBox[5]-$aBBox[2])};
	float $flt;
	float $max = 0;
	
	for ($flt in $aDim) if ($flt > $max) $max = $flt;
	
	return $max;
}


global proc string abRTGetMirrorObj(string $obj){
	// returns name of same type of object on other side of yz axis or an empty string if none (or multiple in same position)
	
	if (!objExists($obj)) return "";
	
	string $nodeType, $tObj, $ret, $transform, $aRetObj[], $aStr[];
	float $xForm[];
	float $tol = .001;
	int $posXObj; // true if $obj is on the x+ side of the YZ plane
	
	string $tLoc = abRTMakeLocator("abRTGetMirror_loc");
	
	select -r $obj $tLoc;
	abRTPointOrient(1);
	
	float $objXform[] = `xform -q -ws -t $tLoc`;
	
	if ($objXform[0] > $tol){
		$posXObj = true;
	}else if ($objXform[0] < -$tol){
		$posXObj = false;
	}else{
		// $obj is on the x origin -- it will have no mirror
		$posXObj = -1;
	}
	
	if ($posXObj != -1){
		
		string $aStr[] = `listRelatives -shapes $obj`;
		int $useShape = (size($aStr) > 0);
		$nodeType = ($useShape) ? `nodeType $aStr[0]` : `nodeType $obj`;
		
		string $aObj[] = `ls -type $nodeType`;
		
		for ($tObj in $aObj){
			
			// if the node is a locator don't include our tLoc in the matching
			
			if ($useShape){
				// get transform
				$aStr = `listRelatives -p -type transform $tObj`;
				if (size($aStr) == 1) $transform = $aStr[0];
				else continue;
			}else{
				$transform = $tObj;
			}
			
			if (shortNameOf($transform) == shortNameOf($tLoc)) continue;
			
			select -r $transform $tLoc;
			abRTPointOrient(1);
			
			$xForm = `xform -q -ws -t $tLoc`;
			
			if (abs($objXform[0] + $xForm[0]) < $tol){
				if (abs($objXform[1] - $xForm[1]) < $tol){
					if (abs($objXform[2] - $xForm[2]) < $tol){
						$aRetObj[size($aRetObj)] = $transform;
					}
				}
			}
		}
		
		
		if (size($aRetObj) == 1){
			$ret = $aRetObj[0];
		}else if (size($aRetObj) > 1){
			
			// try to guess mirror object based on name match
			
			string $mObjGuess;
			string $prefix = abRTGetObjSide($obj);
			string $lfPrefix = abRTGetGlobal("leftPrefix");
			string $rtPrefix = abRTGetGlobal("rightPrefix");
			
			if ($prefix == "l"){
				$mObjGuess = abRTSubstituteAll($lfPrefix, $obj, $rtPrefix);
			}else{
				$mObjGuess = abRTSubstituteAll($rtPrefix, $obj, $lfPrefix);
			}
			
			for ($tObj in $aRetObj){
				if (longNameOf($tObj) == longNameOf($mObjGuess)){
					$ret = $mObjGuess;
					break;
				}
			}
			
			// if that doesn't work, ask the user
			if ($ret == ""){
				string $bnStr, $aStrippedBns[];
				for ($tObj in $aRetObj){
					$aStrippedBns[size($aStrippedBns)] = abRTStripPath($tObj);
					$bnStr += " -button \""+($aStrippedBns[size($aStrippedBns)-1])+"\"";
				}
				
				string $shortNameObj = abRTStripPath($obj);
				string $cmd = "confirmDialog -title \"Multiple Mirror Objects\" -message \"Select the mirror object of "+$shortNameObj+".\" "+$bnStr+" -button \"Cancel\" -defaultButton \"Cancel\" -cancelButton \"Cancel\" -dismissString \"Cancel\"";
				
				string $chosenObj = eval($cmd);
				if ($chosenObj != "Cancel"){
					int $arrayPos = abRTGetPosInStrArray($chosenObj, $aStrippedBns);
					if ($arrayPos >= 0) $ret = $aRetObj[$arrayPos];
				}else{
					error "Operation cancelled.";
				}
			}
		}
	}
	
	select -clear;
	delete $tLoc;
	
	return $ret;
	
}


global proc abRTRigRemover(){
	// shows a UI to remove parts of the rig.
	
	string $node;
	string $aNodes[] = `ls -type geometryVarGroup "*_charVars"`;
	
	if (size($aNodes) == 0){
		warning "There are no valid CharVar nodes in the scene.";
		return;
	}
	
	if (`window -exists abRTRigRemoverWin`){
		deleteUI -window abRTRigRemoverWin;
	}
	window -t "abRigRemover" -w 156 -h 254 -menuBar true -minimizeButton false -maximizeButton false abRTRigRemoverWin;
		
	formLayout -numberOfDivisions 100 abRTRRForm;
	
	// populate option menu
	optionMenu -changeCommand "abRTRRPopulateScrollList();" abRTRRCharOpMn;
	for ($node in $aNodes) menuItem -label $node -p abRTRRCharOpMn;
	
	textScrollList -allowMultiSelection true abRTRRTxtScrollList;
	
	button -label "Refresh" -command "abRTRRPopulateScrollList();" abRTRRRefBn;
	button -label "Remove Selected" -command "abRTRRDeleteRig();" abRTRRDelBn;
	
	int $lmargin = 3;
	int $rmargin = 3;
	
	formLayout -e
	
	-af abRTRRDelBn "bottom" 4
	-af abRTRRDelBn "left" $lmargin
	-af abRTRRDelBn "right" $rmargin
	
	-af abRTRRRefBn "left" $lmargin
	-af abRTRRRefBn "right" $rmargin
	-ac abRTRRRefBn "bottom" 5 abRTRRDelBn
	
	-ac abRTRRTxtScrollList "top" 4 abRTRRCharOpMn
	-af abRTRRTxtScrollList "left" $lmargin
	-af abRTRRTxtScrollList "right" $rmargin
	-ac abRTRRTxtScrollList "bottom" 5 abRTRRRefBn
	
	-af abRTRRCharOpMn "top" 5
	-af abRTRRCharOpMn "left" $lmargin
	-af abRTRRCharOpMn "right" $rmargin
	
	abRTRRForm
	;
	
	// populate textScrollList
	abRTRRPopulateScrollList();
	
	// showWindow
	showWindow abRTRigRemoverWin;
}


global proc abRTRRPopulateScrollList(){
	// refreshes the RigRemover scrollList
	
	if (!`window -ex abRTRigRemoverWin`) return;
	if (!`window -ex abRTWin`){
		deleteUI -window abRTRigRemoverWin;
		return;
	}
	
	// populate textScrollList
	string $att, $part;
	string $aRigParts[] = {"spine","head","leftLeg","rightLeg","leftArm","rightArm","leftHand","rightHand"};
	string $aSceneCharVars[] = `ls -type geometryVarGroup "*_charVars"`;
	/* string $selCharVars = `optionMenu -q -v abRTRRCharOpMn`; */
	
	
	if (size($aSceneCharVars) == 0){
		// There are no charvars in the scene
		deleteUI -window abRTRigRemoverWin;
		return;
	}
	
	
	// update option menu
	string $menuItem, $option;
	string $aOptionMenuItems[] = `optionMenu -q -itemListLong abRTRRCharOpMn`;
	
	// getSelected Item
	int $selMenuItem = `optionMenu -q -select abRTRRCharOpMn`;
	
	// empty and rebuild the option menu
	for ($menuItem in $aOptionMenuItems) deleteUI -menuItem $menuItem;
	for ($option in $aSceneCharVars) menuItem -label $option -p abRTRRCharOpMn;
	
	// reselect $selMenuItem
	if (size($aSceneCharVars) >= $selMenuItem) optionMenu -e -select $selMenuItem abRTRRCharOpMn;
	
	
	string $selCharVars = `optionMenu -q -v abRTRRCharOpMn`;
	
	// clear textScrollList
	textScrollList -e -ra abRTRRTxtScrollList;
	
	if ($selCharVars != ""){
		
		string $aCharVarAtts[] = `listAttr -userDefined $selCharVars`;
		
		for ($att in $aCharVarAtts){
			for ($part in $aRigParts){
				
				if (startsWith($att, $part)){
					textScrollList -e -append $part abRTRRTxtScrollList;
					$aRigParts = stringArrayRemove({$part}, $aRigParts);
					break;
				}
			}
		}
	}
	
}


global proc abRTRRDeleteRig(){
	// deletes part of rig specified in abRTRRTxtScrollList
	
	if (!`window -ex abRTWin`){
		deleteUI -window abRTRigRemoverWin;
		return;
	}
	
	string $charVarsNode = `optionMenu -q -v abRTRRCharOpMn`;
	string $aDelRigItems[] = `textScrollList -q -si abRTRRTxtScrollList`;
	
	
	// put the character back into the default pose
	/* string $masterRigGrp = firstParentOf($charVarsNode);
	string $aCtrlCrvs[] = abRTGetCtrlCrvs($masterRigGrp);
	
	if (size($aCtrlCrvs) > 0){
		string $aSel[] = `ls -sl`;
		select -r $aCtrlCrvs[0];
		abRTResetCharPose(true);
		select -r $aSel;
	} */
	// done
	
	
	string $item, $rigGrpAtt, $rigGrp, $nodesStr, $aNodes[], $node, $jntGrpAtt, $jntGrp, $jntStr, $aJnts[], $jnt, $nodeGrpAtt, $transGrpAtt, $attGrpAtt, $attStr, $aAtts[], $att, $aStr[], $transStr, $aTrans[];
	for ($item in $aDelRigItems){
		$rigGrpAtt = $item+"RigGrp";
		$jntGrpAtt = $item+"Jnts";
		$nodeGrpAtt = $item+"Nodes";
		$transGrpAtt = $item+"Trans";
		$attGrpAtt = $item+"Atts";
		if (attributeExists($rigGrpAtt, $charVarsNode)){
			
			// break joint connections
			// first retrieve joints
			if (attributeExists($jntGrpAtt, $charVarsNode)){
				$jntStr = `getAttr ($charVarsNode+"."+$jntGrpAtt)`;
				$aJnts = stringToStringArray($jntStr, ",");
				
				// now break'em
				for ($jnt in $aJnts){
					gmDeleteConnection($jnt+".tx");
					gmDeleteConnection($jnt+".ty");
					gmDeleteConnection($jnt+".tz");
					gmDeleteConnection($jnt+".rx");
					gmDeleteConnection($jnt+".ry");
					gmDeleteConnection($jnt+".rz");
				}
				// remove attributes
				deleteAttr -at $jntGrpAtt $charVarsNode;
			}
			
			
			// get array of nodes out of charVars for this item
			if (attributeExists($nodeGrpAtt, $charVarsNode)){
				$nodesStr = `getAttr ($charVarsNode+"."+$nodeGrpAtt)`;
				$aNodes = stringToStringArray($nodesStr, ",");
				for ($node in $aNodes) if (`objExists $node`) delete $node;
				// remove attributes
				deleteAttr -at $nodeGrpAtt $charVarsNode;
			}
			
			// get rid of stray attributes
			if (attributeExists($attGrpAtt, $charVarsNode)){
				$attStr = `getAttr ($charVarsNode+"."+$attGrpAtt)`;
				$aAtts = stringToStringArray($attStr, ",");
				for ($att in $aAtts){
					$aStr = stringToStringArray($att, ".");
					if (`objExists $aStr[0]` && attributeExists($aStr[1], $aStr[0])){
						setAttr -lock 0 $att;
						deleteAttr $att;
					}
				}
				// remove attributes
				deleteAttr -at $attGrpAtt $charVarsNode;
			}
			
			// remove any random transforms
			if (attributeExists($transGrpAtt, $charVarsNode)){
				$transStr = `getAttr ($charVarsNode+"."+$transGrpAtt)`;
				$aTrans = stringToStringArray($transStr, ",");
				for ($node in $aTrans) if (`objExists $node`) delete $node;
				// remove attributes
				deleteAttr -at $transGrpAtt $charVarsNode;
			}
			
			// delete rig group
			if (attributeExists($rigGrpAtt, $charVarsNode)){
				$rigGrp = `getAttr ($charVarsNode+"."+$rigGrpAtt)`;
				if (`objExists $rigGrp`) delete $rigGrp;
				// remove attributes
				deleteAttr -at $rigGrpAtt $charVarsNode;
			}
			
		}else{
			warning ("Unable to remove "+$item);
		}
		
		// remove the item from the scrollList
		textScrollList -e -ri $item abRTRRTxtScrollList;
		
	}
	
	// if there are no items left, delete the rigGrp
	if (`textScrollList -q -numberOfItems abRTRRTxtScrollList` == 0){
		string $mainRigGrp = firstParentOf($charVarsNode);
		if (objExists($mainRigGrp) && endsWith($mainRigGrp, "_rig_grp")) delete $mainRigGrp;
	}
	
	// update RigRemover UI
	abRTRRPopulateScrollList();
	
	// update UI textfields
	abRTCheckUIItems("");
	
}


global proc abRTChangeRotOrderWindow(){
	// creates window for changing rotation order on selected objects
	
	if (`window -exists abRTROWin`) deleteUI -window abRTROWin;
	
	window -t "abChangeRotationOrder" -w 276 -h 62 -menuBar false -minimizeButton false -maximizeButton false abRTROWin;
		
	formLayout -numberOfDivisions 100 abRTROForm;
	
	//optionMenu -q -select abRTROOptionMn
	
	optionMenu abRTROOptionMn;
	menuItem -label "xyz" -p abRTROOptionMn;
	menuItem -label "yzx" -p abRTROOptionMn;
	menuItem -label "zxy" -p abRTROOptionMn;
	menuItem -label "xzy" -p abRTROOptionMn;
	menuItem -label "yxz" -p abRTROOptionMn;
	menuItem -label "zyx" -p abRTROOptionMn;
	
	button -label "  Change Rotation Order On Selected To:  " -h 25 -command "abRTChangeRotationOrder((`ls -sl`), ((`optionMenu -q -select abRTROOptionMn`)-1));" abRTROChangeROBn;
	
	int $lmargin = 2;
	int $rmargin = 2;
	
	formLayout -e
	
	-af abRTROOptionMn "top" 5
	-af abRTROOptionMn "right" $rmargin
	
	-af abRTROChangeROBn "top" 4
	-af abRTROChangeROBn "left" $lmargin
	-ac abRTROChangeROBn "right" 4 abRTROOptionMn
	
	
	abRTROForm
	;
	
	showWindow abRTROWin;
	
}


global proc abRTChangeRotationOrder(string $aSel[], int $newRO){
	// changes the rotation order on the selected transforms in $aObj to $newRo:
	// 0:xyz, 1:yzx, 2:zxy, 3:xzy, 4:yxz, 5:zyx
	
	string $obj, $aLocs[], $aObj[], $aRel[], $tDup, $aStr[];
	float $aKeyTimes[], $aFlt[], $aRot[];
	int $i, $k;
	
	int $objCounter = 0;
	int $keyCounter = 0;
	int $lockedCounter = 0;
	
	string $locRootName = "abChangeRotOrderLoc_";
	
	float $initTime = `currentTime -q`;
	string $aInitSel[] = `ls -sl`;
	
	// get transforms for aSel
	for ($obj in $aSel){
		
		if (nodeType($obj) == "transform"){
			$aObj[size($aObj)] = $obj;
		}else{
			$aRel = `listRelatives -p -f -type transform $obj`;
			if (size($aRel) == 1) $aObj[size($aObj)] = $aRel[0];
		}
		
	}
	
	if (size($aObj) == 0) return;
	
	for ($obj in $aObj){
		
		// skip this object if it already has the desired RO
		if ($newRO == `getAttr ($obj+".ro")`) continue;
		
		if (!`getAttr -settable ($obj+".r")` || !`getAttr -settable ($obj+".rx")` || !`getAttr -settable ($obj+".ry")` || !`getAttr -settable ($obj+".rz")`){
			$lockedCounter++;
			continue;
		}
		
		// get keyframes for $obj (need to remove duplicates)
		$aFlt = sort(`keyframe -q $obj`);
		for ($i=0;$i<size($aFlt);$i++){
			
			if ($i == 0){
				$aKeyTimes[size($aKeyTimes)] = $aFlt[$i];
				continue;
			}
			
			if ($aFlt[$i] != $aFlt[$i-1]) $aKeyTimes[size($aKeyTimes)] = $aFlt[$i];
			
		}
		
		// create a loc for each keytime and snap it to the obj (will snap back to this after RO is changed)
		for ($k=0;$k<size($aKeyTimes);$k++){
			
			currentTime $aKeyTimes[$k];
			
			// make loc
			$aLocs[size($aLocs)] = abRTMakeLocator($locRootName+$k);
			
			//snap loc
			select -r $obj $aLocs[$k];
			abRTPointOrient(1);
			select -clear;
			
		}
		
		// change RO
		setAttr ($obj+".ro") $newRO;
		
		// can't snap obj to loc (anim curve connections) so have to snap a duplicated obj to loc and copy those values to the existing obj over keytimes
		for ($k=0;$k<size($aKeyTimes);$k++){
			
			currentTime $aKeyTimes[$k];
			
			// dup obj
			$aStr = `duplicate $obj`;
			$tDup = $aStr[0];
			
			abRTShowAttr($tDup, {"tx","ty","tz","rx","ry","rz"});
			
			//snap obj
			select -r $aLocs[$k] $tDup;
			abRTPointOrient(1);
			select -clear;
			
			$aRot = `getAttr ($tDup+".r")`;
			setAttr ($obj+".r") $aRot[0] $aRot[1] $aRot[2];
			
			delete $tDup;
			
			$keyCounter++;
			
		}
		
		// cleanup
		
		// delete locs
		if (size($aLocs) > 0) for ($obj in $aLocs) delete $obj;
		
		// clear arrays
		clear($aLocs);
		clear($aKeyTimes);
		
		$objCounter++;
		
	}
	
	// reset time and sel
	currentTime $initTime;
	select -r $aInitSel;
	
	string $lockedStr = ($lockedCounter > 0) ? "  Unable to operate on "+$lockedCounter+" locked or connected object(s)." : "";
	print ("Reset the rotation order on "+$objCounter+" transform(s) and a total of "+$keyCounter+" key(s)."+$lockedStr);
	
}


global proc abRTRotateOrientUI(){
	// opens joint orient UI
	
	if (`window -exists abRTROWin`){
		deleteUI -window abRTROWin;
	}
	window -t "abRotateOrient" -w 176 -h 142 -menuBar false -minimizeButton false -maximizeButton false abRTROWin;
		
	formLayout -numberOfDivisions 100 abRTROForm;
	
	// populate option menu
	button -label "+90 X" -c "abRTRORotateJointLA(0);" abRTEOXPos90Bn;
	button -label "+90 Y" -c "abRTRORotateJointLA(1);" abRTEOYPos90Bn;
	button -label "+90 Z" -c "abRTRORotateJointLA(2);" abRTEOZPos90Bn;
	button -label "-90 X" -c "abRTRORotateJointLA(3);" abRTEOXNeg90Bn;
	button -label "-90 Y" -c "abRTRORotateJointLA(4);" abRTEOYNeg90Bn;
	button -label "-90 Z" -c "abRTRORotateJointLA(5);" abRTEOZNeg90Bn;
	button -label "Toggle Selected Local Axes" -c "abRTROToggleLRA(true);" abRTEOToggleSelLRA0Bn;
	button -label "Toggle Hierarchy Local Axes" -c "abRTROToggleLRA(false);" abRTEOToggleHierarchyLRA0Bn;
	
	int $lmargin = 3;
	int $rmargin = 3;
	int $tmargin = 5;
	
	formLayout -e
	
	-af abRTEOXPos90Bn "top" $tmargin
	-af abRTEOXPos90Bn "left" $lmargin
	-ap abRTEOXPos90Bn "right" $rmargin 33
	
	-af abRTEOYPos90Bn "top" $tmargin
	-ac abRTEOYPos90Bn "left" $lmargin abRTEOXPos90Bn
	-ap abRTEOYPos90Bn "right" $rmargin 66
	
	-af abRTEOZPos90Bn "top" $tmargin
	-ac abRTEOZPos90Bn "left" $lmargin abRTEOYPos90Bn
	-af abRTEOZPos90Bn "right" $rmargin
	
	
	-ac abRTEOXNeg90Bn "top" $tmargin abRTEOXPos90Bn
	-af abRTEOXNeg90Bn "left" $lmargin
	-ap abRTEOXNeg90Bn "right" $rmargin 33
	
	-ac abRTEOYNeg90Bn "top" $tmargin abRTEOYPos90Bn
	-ac abRTEOYNeg90Bn "left" $lmargin abRTEOXNeg90Bn
	-ap abRTEOYNeg90Bn "right" $rmargin 66
	
	-ac abRTEOZNeg90Bn "top" $tmargin abRTEOZPos90Bn
	-ac abRTEOZNeg90Bn "left" $lmargin abRTEOYNeg90Bn
	-af abRTEOZNeg90Bn "right" $rmargin
	
	-ac abRTEOToggleSelLRA0Bn "top" $tmargin abRTEOZNeg90Bn
	-af abRTEOToggleSelLRA0Bn "left" $lmargin
	-af abRTEOToggleSelLRA0Bn "right" $rmargin
	
	-ac abRTEOToggleHierarchyLRA0Bn "top" $tmargin abRTEOToggleSelLRA0Bn
	-af abRTEOToggleHierarchyLRA0Bn "left" $lmargin
	-af abRTEOToggleHierarchyLRA0Bn "right" $rmargin
	
	
	abRTROForm
	;
	
	// showWindow
	showWindow abRTROWin;
}


global proc abRTRORotateJointLA(int $axis){
	// rotates the selected joint(s) LRA positive 90 degrees around X, Y, Z ($axis: 0,1,2) axes or negative 90 degrees around X, Y, Z ($axis: 3,4,5)
	
	float $aRot[] = {0, 0, 0};
	
	switch ($axis){
		case 0: $aRot[0] = 90; break;
		case 1: $aRot[1] = 90; break;
		case 2: $aRot[2] = 90; break;
		case 3: $aRot[0] = -90; break;
		case 4: $aRot[1] = -90; break;
		case 5: $aRot[2] = -90; break;
	}
	
	xform -r -os -ra $aRot[0] $aRot[1] $aRot[2];
	joint -e -zso;
	makeIdentity -apply true;
	
}


global proc abRTROToggleLRA(int $selected){
	// toggles selected joint LRAs if $selected is true, otherwises toggles all children joints
	
	string $aJnts[] = `ls -sl -type joint`;
	string $aRel[], $jnt;
	
	// if no joints are selected, toggle them all
	if (size($aJnts) == 0) $aJnts = `ls -type joint`;
	
	if (size($aJnts) > 0){
		
		int $targVal = 1-(`toggle -q -la $aJnts[0]`);
		
		if (!$selected){
			$aRel = `listRelatives -ad -fullPath -type joint $aJnts`;
			$aJnts = stringArrayCatenate($aJnts, $aRel);
		}
		
		for ($jnt in $aJnts) if (`toggle -q -la $jnt` != $targVal) toggle -la $jnt;
	}
	
}


/* global proc abRTCaptureAttsOnSel(){
	// utility function
	
	string $aSel[] = `ls -sl`;
	string $ret, $att, $attVal;
	
	if (size($aSel) == 1){
		
		string $aAtt[] = `listAttr -k -sn $aSel[0]`;
		for ($att in $aAtt){
			
			$attVal = string(`getAttr ($aSel[0]+"."+$att)`);
			
			$ret += $att;
			$ret += " "+$attVal;
			$ret += "\n";
		}
		
	}
	
	print $ret;
} */

global proc string abRTGetRigGrpFromSelCtrl(){
	// attempts to return the rigGrp from a selected control curve on the rig
	
	string $aSel[] = `ls -sl -type transform`;
	string $rigGrp, $aParents[];
	int $i;
	
	if (size($aSel) == 0){
		warning "Select at least one control on your character and try again.";
		return $rigGrp;
	}
	
	// find rigGrp
	string $obj = $aSel[0];
	
	while ($obj != ""){
		$aParents[size($aParents)] = $obj;
		$obj = firstParentOf($obj);
	}
	
	// now sort through aParents in reverse order to get master rig_grp
	for ($i=size($aParents)-1;$i>=0;$i--){
		if (endsWith($aParents[$i], "rig_grp")){
			$rigGrp = $aParents[$i];
			break;
		}
	}
	
	if ($rigGrp == "") warning "Unable to determine character rigGrp.";
	
	return $rigGrp;
}



global proc abRTResetCharPose(int $resetAll){
	// called from UI to reset the pose of the selected character (select rootCon)
	// if $resetAll, it will reset all of the controls for the character, otherwise it will only reset the selected controls
	
	string $rigGrp = abRTGetRigGrpFromSelCtrl();
	
	if ($rigGrp == "") return; 
	else abRTQuickCharDefaultPose($rigGrp, $resetAll);
	
}


global proc abRTQuickCharDefaultPose(string $rigGrp, int $resetAll){
	// quick and dirty way to reset character to default pose -- if $resetAll, all controls will be reset; otherwise only selected
	
	if (!objExists($rigGrp)) return;
	
	string $aCtrlCrvs[] = abRTGetCtrlCrvs($rigGrp);
	string $ctrl, $attType, $att, $aAtts[], $aAttTable[], $aValueTable[], $aCBSelAtt[], $myIntersector;
	int $i, $attInd;
	int $useCBSel = false;
	
	// if using selection in channelBox, create an intersector to quickly suss which atts need to be reset
	if (!$resetAll){
		$aCBSelAtt = `channelBox -q -sma mainChannelBox`;
		if (size($aCBSelAtt) > 0){
			$useCBSel = true;
			$myIntersector = `stringArrayIntersector`;
			print "Resetting channelBox selection";
		}
	}
	
	string $aDef[] = {"tx","0","ty","0","tz","0","rx","0","ry","0","rz","0","ikFkBlend","1","ikVis","0","fkVis","0","ikCtrlVis","0","legStretch","0","kneeStretch","0","ankleStretch","0","armStretch","0","elbowStretch","0","wristStretch","0","armTwist","0","pvControl","1","maxStretch","3","stretchyLeg","0","legTwist","0","footRoll","0","footBreak","40","toeRoll","0","toeTwist","0","ballTwist","0","rootCtrl","1","cogCtrl","0","lowSpineCtrl","0","hiSpineCtrl","0","headCtrl","0","head","0","lfArmIkCtrl","0","rtArmIkCtrl","0","snapElbow","0","snapKnee","0","align","0","useRootSpace","0","spineShaper","1","masterScale","1","skeletonVis","1","ikSpineVis","0","spineSplitCtrlVis","1","fkAlign","0","masterCup","0","masterFist","0","masterSpread","0","thumbFistDamp","0.3","midCurlAmt","1","tipCurlAmt","1.4","thumbCurl","0","indexCurl","0","middleCurl","0","ringCurl","0","pinkyCurl","0","thumbBase","0","thumbMid","0","thumbTip","0","thumbSpread","0","thumbRoll","0","thumbIK","0","indexBase","0","indexMid","0","indexTip","0","indexSpread","0","indexRoll","0","indexIK","0","middleBase","0","middleMid","0","middleTip","0","middleSpread","0","middleRoll","0","middleIK","0","ringBase","0","ringMid","0","ringTip","0","ringSpread","0","ringRoll","0","ringIK","0","pinkyBase","0","pinkyMid","0","pinkyTip","0","pinkySpread","0","pinkyRoll","0","pinkyIK","0"};
	
	// put $aDef info into two arrays
	for ($i=0;$i<size($aDef);$i+=2){
		$aAttTable[size($aAttTable)] = $aDef[$i];
		$aValueTable[size($aValueTable)] = $aDef[$i+1];
	}
	
	for ($ctrl in $aCtrlCrvs){
		
		if (!$resetAll && size(`ls -sl $ctrl`) == 0) continue; // if this control isn't selected and resetAll is false, then skip it
		
		$aAtts = `listAttr -k -sn $ctrl`;
		
		if ($useCBSel){
			stringArrayIntersector -edit -reset $myIntersector;
			stringArrayIntersector -edit -intersect $aAtts $myIntersector;
			stringArrayIntersector -edit -intersect $aCBSelAtt $myIntersector;
			$aAtts = `stringArrayIntersector -query $myIntersector`;
		}
		
		for ($att in $aAtts){
			$attInd = abRTGetPosInStrArray($att, $aAttTable);
			
			if ($attInd > -1 && attributeExists($att, $ctrl)){
				
				$attType = `getAttr -type ($ctrl+"."+$att)`;
				
				if ($attType == "float" || $attType == "double" || $attType == "doubleLinear" || $attType == "doubleAngle"){
					setAttr ($ctrl+"."+$att) (float($aValueTable[$attInd]));
				}else if($attType == "string"){
					setAttr -type "string" ($ctrl+"."+$att) ($aValueTable[$attInd]);
				}else if($attType == "int" || $attType == "enum" || $attType == "short" || $attType == "long" || $attType == "bool"){
					setAttr ($ctrl+"."+$att) (int($aValueTable[$attInd]));
				}
			}
		}
	}
	
	if ($myIntersector != "") deleteUI $myIntersector;
}


global proc string[] abRTDuplicateJointHierarchy(string $aTargets[], string $aNames[], string $grp){
	// will create joint chain based on location of objects in $aTargets, rename them the names in $aNames, and place the result in the existing group $grp
	// returns new pathNames
	
	string $aRet[], $aRel[];
	int $aIsJnt[], $i; // tracks non joints so they can be aligned after the chain has been created
	
	if (size($aTargets) == size($aNames)){
		
		float $xForm[], $jointXform[], $radius;
		string $jnt, $aStr[];
		
		string $tLoc = abRTMakeLocator("abRTDupJntHierarchy_loc");
		
		for ($i=0;$i<size($aTargets);$i++){
			
			if (`nodeType $aTargets[$i]` == "joint"){
				// duplicate the joint
				
				$aStr = `duplicate -rr -name $aNames[$i] $aTargets[$i]`;
				$aRel = `listRelatives -c -fullPath $aStr[0]`;
				if (size($aRel) > 0) delete $aRel;
				
				$jnt = $aStr[0];
				$aIsJnt[size($aIsJnt)] = true;
			}else{
				
				select -r $aTargets[$i] $tLoc;
				abRTPointOrient(1);
				select -clear;
				
				$xForm = `xform -q -ws -t $tLoc`;
				
				$jnt = `joint -p $xForm[0] $xForm[1] $xForm[2] -n $aNames[$i]`;
				$aIsJnt[size($aIsJnt)] = false;
			}
			
			if ($i == 0){
				if ($grp != "" && `objExists $grp`) $jnt = abRTParent($jnt, $grp);
				else if (firstParentOf($jnt) != "") $jnt = `parent -w $jnt`;
			}else{
				$jnt = abRTParent($jnt, $aRet[$i-1]);
			}
			
			$aRet[$i] = $jnt;
		}
		
		delete $tLoc;
		
	}
	
	for ($i=0;$i<size($aIsJnt);$i++){
		if (!$aIsJnt[$i]) joint -e -zso -oj xyz -sao yup $aRet[$i];
	}
	
	select -clear;
	
	return $aRet;
	
}


global proc string abRTRigRootFolder(){
	// makes the root folder for all the riggery or returns it's path if it already exists
	
	string $charName = abRTGetGlobal("name");
	string $folderName = $charName+"_rig_grp";
	if (!`objExists $folderName`) group -em -name $folderName;
	return $folderName;
	
}


global proc abRTColorObj(string $obj, int $index){
	// sets $obj color to $index
	
	string $aRel[] = `listRelatives -c -fullPath -type shape $obj`;
	if (size($aRel) == 1) $obj = $aRel[0];
	
	if (`attributeExists "overrideColor" $obj`){
		if (!`getAttr ($obj+".overrideEnabled")`) setAttr ($obj+".overrideEnabled") true;
		
		if (`getAttr -settable ($obj+".overrideColor")`){
			setAttr ($obj+".overrideColor") $index;
		}else{
			print ("\nUnable to set color on "+(abRTStripPath($obj))+".  Ignored and moving on.");
		}
	}
}


/* global proc abRTDisplayType(string $obj, int $type){
	// sets $obj display type to 0: normal, 1: template, or 2: reference
	
	if ($type >= 0 && $type >= 2){
		if (`attributeExists "overrideDisplayType" $obj`){
			if (!`getAttr ($obj+".overrideEnabled")`) setAttr ($obj+".overrideEnabled") true;
			setAttr ($obj+".overrideDisplayType") $type;
		}
	}
} */


global proc string[] abRTMassOrientConstraint(string $aParent[], string $aChildren[], string $aNames[]){
	// $aParent[0] is constrained to $aChildren[0], $aParent[1] to $aChildren[1], etc -- named to $aNames[n]
	// array of constraint.weight returned
	
	string $aRet[], $aStr[], $constraint, $weightAtt;
	
	if (size($aParent) <= size($aChildren) && size($aParent) <= size($aNames)){
		
		int $i;
		for ($i=0;$i<size($aParent);$i++){
			
			$aStr = `orientConstraint -name $aNames[$i] $aParent[$i] $aChildren[$i]`;
			$constraint = $aStr[0];
			$aStr = `orientConstraint -q -wal $constraint`;
			$weightAtt = $aStr[size($aStr)-1];
			$aRet[size($aRet)] = $constraint+"."+$weightAtt;
			
		}
	}
	
	return $aRet;
	
}


global proc abRTAddSplitAttsToSpineCurve(string $ctrl, float $aSplitRatios[], string $splitRotMultDiv, string $attLabel, string $attBaseName, string $prefix, string $limbName){
	// adds attributes for split joint rotation ratios to $ctrl.  $aSplitRatios is an array of ratios for split joints; $splitRotMultDiv is node where final joint rx is determined;
	// $attLabel is category name for atts eg "________LEFT_UPARM___"
	// $attBaseName is name to use for the attributes (splitJoint rotations) eg "Uparm"
	// $limbName used to record atts on spineCurve for later rig removal
	
	string $longPrefix = ($prefix == "l") ? "left" : "right";
	string $aAxes[] = {"X","Y","Z"};
	string $att, $aAtts[];
	
	// exit if the $ctrl object doesn't exist or size($aSplitRatios) > 3
	if (!`objExists $ctrl` || size($aSplitRatios) > 3) return;
	
	int $i;
	
	// add att label
	if (!attributeExists($attLabel, $ctrl)){
		addAttr -ln $attLabel -at bool -dv 0 -keyable true $ctrl;
		setAttr  -lock true ($ctrl+"."+$attLabel);
		
		// record atts to charVars
		$aAtts[size($aAtts)] = ($ctrl+"."+$attLabel);
	}
	
	// add atts
	for ($i=0;$i<size($aSplitRatios);$i++){
		
		$att = $longPrefix+(capitalizeString($attBaseName))+"_"+($i+1);
		if (!attributeExists($att, $ctrl)) addAttr -ln $att -at double  -min -0 -max 1 -dv $aSplitRatios[0] -keyable true $ctrl;
		connectAttr ($ctrl+"."+$att) ($splitRotMultDiv+".input2"+$aAxes[$i]);
		
		// record atts to charVars
		$aAtts[size($aAtts)] = ($ctrl+"."+$att);
	}
	
	abRTSaveToCharVars($aAtts, $limbName);
}


global proc abRTConnectToMasterScale(string $grp){
	// connects rig and space switching groups (or any transform) to masterScale
	
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	
	if ($rootCtrl == "" || `nodeType $grp` != "transform") return;
	
	// add masterScale if it doesn't exist
	if (!(`attributeExists "masterScale" $rootCtrl`)) addAttr -ln "masterScale" -at "float" -dv 1 -keyable true -min .001 -max 10 $rootCtrl;
	
	if (!(`isConnected ($rootCtrl+".masterScale") ($grp+".sx")`)) connectAttr ($rootCtrl+".masterScale") ($grp+".sx");
	if (!(`isConnected ($rootCtrl+".masterScale") ($grp+".sy")`)) connectAttr ($rootCtrl+".masterScale") ($grp+".sy");
	if (!(`isConnected ($rootCtrl+".masterScale") ($grp+".sz")`)) connectAttr ($rootCtrl+".masterScale") ($grp+".sz");
	
}


global proc int abRTRigSpine(string $rootJnt, string $hipJnt){
	// creates a spine rig -- returns 1 on success, -1 on failure
	
	int $ret = -1;
	
	if ($rootJnt == "" || $hipJnt == "") return $ret;
	
	string $aStr[], $aRel[], $rel, $str, $aNames[], $spineCurve, $tLoc, $axis, $tPlsMns, $tMltDiv, $tMltDiv2, $name;
	int $i, $k, $deg, $spans, $numCvs, $int, $int2;
	float $aTrans[], $aTrans2[], $float, $floatSum;
	string $alpha = "abcdefghijklmnopqrstuvwxyz";
	string $aAxes[] = {"X","Y","Z"};
	
	string $charName = abRTGetGlobal("name");
	string $limbName = "spine";
	
	// set the scale
	abRTSetScale($rootJnt);
	
	// get back joints
	$aRel = `listRelatives -c -fullPath -type joint $rootJnt`;
	if (size($aRel) != 2){
		warning "Root joint needs to be parent to both the hip joint and the mid spine joint";
		return $ret;
	}
	string $midJnt = ($aRel[0] == $hipJnt) ? $aRel[1] : $aRel[0];
	
	$aRel = `listRelatives -c -fullPath -type joint $midJnt`;
	if (size($aRel) != 1){
		warning "Mid spine joint should only have one child joint.";
		return $ret;
	}
	string $hiJnt = $aRel[0];
	
	$aRel = `listRelatives -c -fullPath -type joint $hiJnt`;
	if (size($aRel) != 1){
		warning "High spine joint should only have one child joint.";
		return $ret;
	}
	string $endJnt = $aRel[0];
	
	// make rootCon
	abRTMakeRootCon($rootJnt);
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	
	// create spine rig group
	string $rigRootFolder = abRTRigRootFolder();
	string $spineGrp = (abRTRigNamer("spine", "", "rigGrp", true));
	if (!`objExists ($rigRootFolder+"|"+$spineGrp)`){
		$spineGrp = `group -em -name $spineGrp`;
		$spineGrp = abRTParent($spineGrp, $rigRootFolder);
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($spineGrp);
	
	// create non scaling group inside of spine rig group to place ikCurve, clusters, ikhandle
	string $spineNSGrp = `group -em -p $spineGrp -name (abRTRigNamer("spineNoScale", "", "rigGrp", true))`;
	setAttr ($spineNSGrp+".inheritsTransform") 0;
	
	// get skeleton group
	string $skeletonGrp = firstParentOf($rootJnt);
	
	// connect rootCon masterScale att skeletonGrp and rigGroup
	connectAttr ($rootCtrl+".masterScale") ($rootCtrl+".sx");
	connectAttr ($rootCtrl+".masterScale") ($rootCtrl+".sy");
	connectAttr ($rootCtrl+".masterScale") ($rootCtrl+".sz");
	if ($skeletonGrp != ""){
		connectAttr ($rootCtrl+".masterScale") ($skeletonGrp+".sx");
		connectAttr ($rootCtrl+".masterScale") ($skeletonGrp+".sy");
		connectAttr ($rootCtrl+".masterScale") ($skeletonGrp+".sz");
	}
	
	abRTHideAttr($rootCtrl, {"sx","sy","sz"});
	
	// save spineGrp to charVars
	abRTSaveRigGrpToCharVars($spineGrp, $limbName);
	abRTSaveToCharVars({$rootCtrl}, $limbName);
	
	// create curve for ikSpline
	// need to place shaper_loc
	
	string $shaperLoc = abRTMakeLocator("shaper_loc");
	parentConstraint $midJnt $hiJnt $shaperLoc;
	
	string $aBackRigCtrlJnts[] = {$hipJnt,$rootJnt,$midJnt,$shaperLoc,$hiJnt,$endJnt};
	
	$tLoc = abRTMakeLocator("abRTSkeletonizeTemp_loc");
	
	string $curveStr = "curve -d 3";
	for ($i=0;$i<size($aBackRigCtrlJnts);$i++){
		
		select -r $aBackRigCtrlJnts[$i] $tLoc;
		abRTPointOrient(1);
		select -clear;
		
		$aTrans = `xform -q -ws -t $tLoc`;
		$curveStr += " -p "+$aTrans[0]+" "+$aTrans[1]+" "+$aTrans[2];
		
	}
	
	$curveStr += " -n "+(abRTRigNamer("ikSpline", "", "crv", true));
	string $spineCurve = eval($curveStr);
	$spineCurve = abRTParent($spineCurve, $spineNSGrp);
	
	delete $tLoc;
	delete $shaperLoc;
	
	select -clear;
	
	int $spineJntNum = int(abRTGetFromUI("SpineJnts"));
	string $aSpineJntNames[];
	
	// fill aSpineJntNames
	
	for ($i=0;$i<$spineJntNum;$i++){
		$str = "spineRig_"+(substring($alpha, ($i+1), ($i+1)));
		$aSpineJntNames[size($aSpineJntNames)] = abRTRigNamer($str, "", "jnt", true);
	}
	
	
	// create spine joints
	
	$aStr = `rebuildCurve -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 $spineCurve`;
	string $rebuiltSpineCurve = $aStr[0];
	string $aRigSpineJnts[] = abRTMakeSpineJntsFromCurve($rebuiltSpineCurve, $aSpineJntNames, $spineGrp);
	delete $rebuiltSpineCurve;
	
	// done with back
	abRTOrientJoints($aRigSpineJnts, "xyz", "zdown");
	
	// make ref spine
	
	clear($aNames);
	for ($i=0;$i<size($aRigSpineJnts);$i++){
		$str = substring($alpha, ($i+1), ($i+1));
		$aNames[size($aNames)] = "refSpine_"+$str;
	}
	
	string $aRefSpineJnts[] = abRTDuplicateJointHierarchy($aRigSpineJnts, $aNames, $spineGrp);
	
	
	// make weight joints
	// dup from second rig spine joint to next to last rig spine joint to make binding joints (which have to be unparented from each other to do the twist)
	
	string $aCroppedRigSpineJnts[];
	string $tmpJntSuf = "abTmpJnt";
	
	clear($aNames);
	for ($i=1;($i<size($aRigSpineJnts)-1);$i++){
		$str = substring($alpha, ($i+1), ($i+1));
		$aNames[size($aNames)] = abRTRigNamer(("weightSpine_"+$str), "", $tmpJntSuf, true);
		$aCroppedRigSpineJnts[size($aCroppedRigSpineJnts)] = $aRigSpineJnts[$i];
	}
	
	// create weight spine group rootDir first, then move it to skelWSGrp if needed
	string $weightSpineGrp = `group -em -name (abRTRigNamer("weightSpine", "", "rigGrp", true))`;
	string $aWeightSpineJnts[] = abRTDuplicateJointHierarchy($aCroppedRigSpineJnts, $aNames, $weightSpineGrp);
	
	// unparent joints from heirarchy and group freeze them
	for ($i=(size($aWeightSpineJnts)-1);$i>=0;$i--){
		$aWeightSpineJnts[$i] = abRTParent($aWeightSpineJnts[$i], $weightSpineGrp);
		
		// replace temp suffix (if I didn't do it this way I'd get names ending in _jnt1 due to the way duplicateJointHierarchy works when aNames matches the existing hierarchy's names)
		$aStr = abRTRename($aWeightSpineJnts[$i], substitute($tmpJntSuf, abRTStripPath($aWeightSpineJnts[$i]), "jnt"));
		$aWeightSpineJnts[$i] = $aStr[1];
		
	}
	
	// The skeleton group should already have a weight spine group if it's been rigged before.  If it does, the freezeGrp positions will be matched against the positions in the $weightSpineGrp.  If they don't match, these will be substituted.
	// If there is no existing weight spine group (in the skeleton group) then $weightSpineGrp will be moved into it
	
	string $skelWeightSpineGroupName = "weightSpine_grp";
	string $skelWSGrp = $skeletonGrp+"|"+$skelWeightSpineGroupName;
	if (objExists($skelWSGrp)){
		// group exists.  if the number and positions of the members match up with the joints in $weightSpineGrp, then leave them, otherwise delete the group and it will be recreated
		
		int $delOldWghtGrp = false;
		float $matchTol = .005;
		
		$aStr = sort(`listRelatives -c -fullPath -type joint $skelWSGrp`); // sort it -- otherwise order of joints in skelWSGrp would matter
		
		if (size($aStr) == size($aWeightSpineJnts)){
			
			// check to make sure positions are the same
			
			string $aExistingWeightSpineJnts[];
			string $aPosMatchTracker[] = $aWeightSpineJnts;
			int $posMatch;
			
			for ($i=0;$i<size($aStr);$i++){
				
				$aExistingWeightSpineJnts[$i] = $aStr[$i];
				
				$aTrans = `joint -q -p -a $aStr[$i]`;
				$posMatch = false;
				
				for ($k=0;$k<size($aWeightSpineJnts);$k++){
					
					if ($aPosMatchTracker[$k] == "m") continue; // make sure we don't match the same joint more than once
					
					$aTrans2 = `joint -q -p -a $aWeightSpineJnts[$k]`;
					
					if (abs($aTrans[0]-$aTrans2[0]) < $matchTol && abs($aTrans[1]-$aTrans2[1]) < $matchTol && abs($aTrans[2]-$aTrans2[2]) < $matchTol){
						$aPosMatchTracker[$k] = "m";
						$posMatch = true;
						break;
					}
				}
				if (!$posMatch){
					// there was no match for current $aStr joint in $aWeightSpineJnts -- delete it all
					$delOldWghtGrp = true;
					break;
				}
				
			}
			if ($posMatch){
				// we're using the existing weightjnts and frzGrp so we need to update the arrays
				$aWeightSpineJnts = $aExistingWeightSpineJnts;
			}
		}else{
			$delOldWghtGrp = true;
		}
		
		if ($delOldWghtGrp){
			$str = `confirmDialog -title "Confirm" -message "This character's existing skeleton group\nweight joints don't match the newly created\nweight joints and will have to be deleted." -button "Ok" -button "Cancel" -defaultButton "Ok" -cancelButton "Cancel" -dismissString "Cancel"`;
			if ($str == "Cancel") return $ret;
			delete $skelWSGrp;
		}
	}
	
	
	if (!objExists($skelWSGrp)){
		// create the weight joints in $skelWSGrp by moving contents of weightSpineGrp to skelGrp
		
		group -em -name $skelWeightSpineGroupName -parent $skeletonGrp;
		for ($i=0;$i<size($aWeightSpineJnts);$i++){
			// move freezGrp to skelWSGrp
			$aWeightSpineJnts[$i] = abRTParent($aWeightSpineJnts[$i], $skelWSGrp);
		}
	}
	
	for ($i=0;$i<size($aWeightSpineJnts);$i++){
		parentConstraint $aRigSpineJnts[$i+1] $aWeightSpineJnts[$i];
		if (`attributeExists "skeletonVis" $rootCtrl` && !`isConnected ($rootCtrl+".skeletonVis") ($aWeightSpineJnts[$i]+".v")`) connectAttr -f ($rootCtrl+".skeletonVis") ($aWeightSpineJnts[$i]+".v");
	}
	
	delete $weightSpineGrp;
	
	// done
	
	
	// need to get positions of cvs (beside end pts) on $spineCurve to place control crvs
	
	string $curveInfoNode = abRTCreateNode("curveInfo", "spine", "", $limbName);
	
	connectAttr ($spineCurve +".worldSpace")  ($curveInfoNode+".inputCurve");
	
	$deg = `getAttr ($spineCurve+".degree")`;
	$spans = `getAttr ($spineCurve+".spans")`;
	$numCvs = $deg+$spans;
	
	if ($numCvs != 6){
		warning "Spine curve has too many cvs.  Your spine hierarchy needs to be changed.";
		return $ret;
	}
	
	// make scale adjusted arcLen
	string $arcLenMltDiv = abRTCreateNode("multiplyDivide", "scaleAdjustedArcLen", "", $limbName);
	setAttr ($arcLenMltDiv+".operation") 2;
	connectAttr ($curveInfoNode+".arcLength") ($arcLenMltDiv+".input1X");
	connectAttr ($rootCtrl+".masterScale") ($arcLenMltDiv+".input2X");
	string $scaleAdjustedArcLen = $arcLenMltDiv+".outputX";
	
	string $hipCtrlCrv,$cogCtrlCrv,$lowCtrlCrv,$midCtrlCrv,$shaperCtrlCrv,$hiCtrlCrv;
	
	// make spine controls
	$hipCtrlCrv = abRTWireContoller("pyramid", 4, {}, 25, false);
	abRTMoveWireRelativeToPivot($hipCtrlCrv, 0, -.8, 0, true);
	$cogCtrlCrv = abRTWireContoller("circle", 1, {}, 60, false);
	$lowCtrlCrv = abRTWireContoller("flattenedCircle", 1, {}, 45, false);
	$midCtrlCrv = abRTWireContoller("flattenedCircle", 1, {}, 45, false);
	$shaperCtrlCrv = abRTWireContoller("flattenedCircle", 1, {}, 45, false);
	$hiCtrlCrv = abRTWireContoller("flattenedCircle", 1, {}, 45, false);
	
	// add attributes now to preserve attribute position
	addAttr -ln "spineShaper" -at bool -dv 1 -keyable true $cogCtrlCrv;
	addAttr -ln "stretchValue" -at double -keyable false $cogCtrlCrv;      
	setAttr -cb true ($cogCtrlCrv+".stretchValue");
	
	// rename
	$aStr = abRTRename($hipCtrlCrv, (abRTRigNamer("hip", "", "ctrl", true)));
	$hipCtrlCrv = $aStr[0];
	$aStr = abRTRename($cogCtrlCrv, (abRTRigNamer("cog", "", "ctrl", true)));
	$cogCtrlCrv = $aStr[0];
	$aStr = abRTRename($lowCtrlCrv, (abRTRigNamer("spineLow", "", "ctrl", true)));
	$lowCtrlCrv = $aStr[0];
	$aStr = abRTRename($midCtrlCrv, (abRTRigNamer("spineMid", "", "ctrl", true)));
	$midCtrlCrv = $aStr[0];
	$aStr = abRTRename($shaperCtrlCrv, (abRTRigNamer("spineShaper", "", "ctrl", true)));
	$shaperCtrlCrv = $aStr[0];
	$aStr = abRTRename($hiCtrlCrv, (abRTRigNamer("spineHigh", "", "ctrl", true)));
	$hiCtrlCrv = $aStr[0];
	
	// place in spineGrp
	$hipCtrlCrv = abRTParent($hipCtrlCrv, $spineGrp);
	$cogCtrlCrv = abRTParent($cogCtrlCrv, $spineGrp);
	$lowCtrlCrv = abRTParent($lowCtrlCrv, $spineGrp);
	$midCtrlCrv = abRTParent($midCtrlCrv, $spineGrp);
	$shaperCtrlCrv = abRTParent($shaperCtrlCrv, $spineGrp);
	$hiCtrlCrv = abRTParent($hiCtrlCrv, $spineGrp);
	
	// position curves
	$aTrans = `xform -q -ws -t ($spineCurve+".cv[1]")`;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $hipCtrlCrv;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $cogCtrlCrv;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $lowCtrlCrv;
	
	$aTrans = `xform -q -ws -t ($spineCurve+".cv[2]")`;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $midCtrlCrv;
	
	$aTrans = `xform -q -ws -t ($spineCurve+".cv[3]")`;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $shaperCtrlCrv;
	
	$aTrans = `xform -q -ws -t ($spineCurve+".cv[4]")`;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $hiCtrlCrv;
	
	// orient mid and hi spine ctrls (if necessary)
	if (int(abRTGetFromUI("OrientSpineCtrls"))){
		$aStr = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "none" $hiJnt $midCtrlCrv`;
		delete $aStr[0];
		$aStr = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "none" $endJnt $hiCtrlCrv`;
		delete $aStr[0];
	}
	
	// groupFreeze mid and hi spine ctrl curves to zero out transforms
	$midCtrlCrv = abRTGroupFreezeReturnObj($midCtrlCrv, 1);
	string $midCtrlCrvFrzGrp = firstParentOf($midCtrlCrv);
	$hiCtrlCrv = abRTGroupFreezeReturnObj($hiCtrlCrv, 1);
	string $hiCtrlCrvFrzGrp = firstParentOf($hiCtrlCrv);
	
	// freeze the rest of the curves' transforms
	makeIdentity -apply true -t 1 -r 0 -s 0 $hipCtrlCrv;
	makeIdentity -apply true -t 1 -r 0 -s 0 $cogCtrlCrv;
	makeIdentity -apply true -t 1 -r 0 -s 0 $lowCtrlCrv;
	
	// set hidden ui text fields for space parenting
	abRTSetUITxtFld("hipCtrl", $hipCtrlCrv);
	abRTSetUITxtFld("cogCtrl", $cogCtrlCrv);
	abRTSetUITxtFld("lowSpineCtrl", $lowCtrlCrv);
	abRTSetUITxtFld("midSpineCtrl", $midCtrlCrv);
	abRTSetUITxtFld("hiSpineCtrl", $hiCtrlCrv);
	
	// set up spaces for spineCtrlCurves (need to update UI because space parenting changes path)
	$hiCtrlCrvFrzGrp = abRTParentConstrainToSpace($hiCtrlCrvFrzGrp, $hiCtrlCrv, {"rootCtrl","midSpineCtrl"}, "hiSpineCtrl", "midSpineCtrl");
	$aRel = `listRelatives -f -c $hiCtrlCrvFrzGrp`;
	$hiCtrlCrv = $aRel[0];
	abRTSetUITxtFld("hiSpineCtrl", $hiCtrlCrv);
	$midCtrlCrvFrzGrp = abRTParentConstrainToSpace($midCtrlCrvFrzGrp, $midCtrlCrv, {"rootCtrl","lowSpineCtrl"}, "midSpineCtrl", "lowSpineCtrl");
	$aRel = `listRelatives -f -c $midCtrlCrvFrzGrp`;
	$midCtrlCrv = $aRel[0];
	abRTSetUITxtFld("midSpineCtrl", $midCtrlCrv);
	$lowCtrlCrv = abRTParentConstrainToSpace($lowCtrlCrv, $lowCtrlCrv, {"rootCtrl","cogCtrl"}, "lowSpineCtrl", "cogCtrl");
	abRTSetUITxtFld("lowSpineCtrl", $lowCtrlCrv);
	$hipCtrlCrv = abRTParentConstrainToSpace($hipCtrlCrv, $hipCtrlCrv, {"rootCtrl","cogCtrl"}, "hipCtrl", "cogCtrl");
	abRTSetUITxtFld("hipCtrl", $hipCtrlCrv);
	$cogCtrlCrv = abRTParentConstrainToSpace($cogCtrlCrv, $cogCtrlCrv, {"rootCtrl"}, "cogCtrl","rootCtrl");
	abRTSetUITxtFld("cogCtrl", $cogCtrlCrv);
	
	// hide space atts on select curves
	string $aCtrlCrvs[] = {$lowCtrlCrv, $hiCtrlCrv, $midCtrlCrv, $hipCtrlCrv};
	string $tCurve;
	for ($tCurve in $aCtrlCrvs){
		$aStr = `listAttr -userDefined $tCurve`;
		for ($str in $aStr) setAttr -keyable false -cb false ($tCurve+"."+$str);
	}
	
	// connect rootSpace to space.
	string $baseName, $spaceAtt;
	$aStr = {$hipCtrlCrv, "hipRootSpaceRev", "cogCtrl", $midCtrlCrv, "midRootSpaceRev", "lowSpineCtrl", $hiCtrlCrv, "hiRootSpaceRev", "midSpineCtrl"}; // ctrl, plsMinusBaseName, parentCurveSpaceAttName
	for ($i=0;$i<size($aStr);$i+=3){
		
		$tCurve = $aStr[$i];
		$baseName = $aStr[$i+1];
		$spaceAtt = $aStr[$i+2];
		
		// add rootSpace atts to curves
		addAttr -ln "useRootSpace" -at bool -dv false -keyable true $tCurve;
		
		connectAttr ($tCurve+".useRootSpace") ($tCurve+".rootCtrl");
		
		$tPlsMns = abRTCreateNode("plusMinusAverage", $baseName, "", $limbName);
		setAttr ($tPlsMns+".operation") 2;
		setAttr ($tPlsMns+".input1D[0]") 1;
		
		connectAttr ($tCurve+".useRootSpace") ($tPlsMns+".input1D[1]");
		connectAttr ($tPlsMns+".output1D") ($tCurve+"."+$spaceAtt);
		
	}
	
	// set up shaperCtrl
	$shaperCtrlCrv = abRTGroupFreezeReturnObj($shaperCtrlCrv, 1);
	$shaperCtrlCrv = abRTGroupFreezeReturnObj($shaperCtrlCrv, 1);
	$str = firstParentOf($shaperCtrlCrv);
	$str = firstParentOf($str);
	string $aShaperGrpFrz[];
	$aShaperGrpFrz = {$str};
	$aShaperGrpFrz[1] = firstParentOf($shaperCtrlCrv);
	parentConstraint -mo $midCtrlCrv $aShaperGrpFrz[0];
	$aStr = `parentConstraint -mo $midCtrlCrv $hiCtrlCrv $aShaperGrpFrz[1]`;
	
	// set the interp type on the shaper curve parentConstraint to no flip
	setAttr ($aStr[0]+".interpType") 0;
	
	// constrain loRes spine joints to ctrl curves
	parentConstraint -mo $hipCtrlCrv $hipJnt;
	parentConstraint -mo $lowCtrlCrv $rootJnt;
	parentConstraint -mo $midCtrlCrv $midJnt;
	parentConstraint -mo $hiCtrlCrv $hiJnt;
	
	// set rotate order on ctrls
	setAttr ($cogCtrlCrv+".rotateOrder") 2; //zxy
	setAttr ($hipCtrlCrv+".rotateOrder") 2;
	setAttr ($lowCtrlCrv+".rotateOrder") 3; //xzy
	setAttr ($midCtrlCrv+".rotateOrder") 3;
	setAttr ($hiCtrlCrv+".rotateOrder") 3;
	
	// create ikSpline
	string $aSpineIkHandle[] = `ikHandle
	-name (abRTRigNamer("spine", "", "ikHndl", true))
	-solver "ikSplineSolver"
	-startJoint $aRigSpineJnts[0]
	-endEffector $aRigSpineJnts[size($aRigSpineJnts)-1]
	-createCurve false
	-curve $spineCurve
	-simplifyCurve false
	-rootOnCurve true
	-snapHandleFlagToggle on
	-twistType "linear"
	-createRootAxis true
	-rootTwistMode false
	-connectEffector true
	-parentCurve false`
	;
	
	$aSpineIkHandle[0] = abRTParent($aSpineIkHandle[0], $spineNSGrp);
	$spineCurve = `ikHandle -q -curve $aSpineIkHandle[0]`;
	
	// create clusters on curve
	string $aSpineClusters[], $aSpineClusterHandles[];
	for ($i=0;$i<$numCvs;$i++){
		
		select -r ($spineCurve+".cv["+$i+"]");
		
		if ($i == 3) $aStr = `cluster -relative -name (abRTRigNamer(("spine"+$i), "", "clstr", true))`;
		else $aStr = `cluster -name (abRTRigNamer(("spine"+$i), "", "clstr", true))`;
		
		$aSpineClusters[size($aSpineClusters)] = $aStr[0];
		$aSpineClusterHandles[size($aSpineClusterHandles)] = $aStr[1];
		setAttr ($aSpineClusterHandles[$i]+".v") 0;
		
	}
	
	for ($i=0;$i<size($aSpineClusterHandles);$i++) $aSpineClusterHandles[$i] = abRTParent($aSpineClusterHandles[$i], $spineNSGrp);
	
	parentConstraint -mo $hipJnt $aSpineClusterHandles[0];
	parentConstraint -mo $rootJnt $aSpineClusterHandles[1];
	parentConstraint -mo $midJnt $aSpineClusterHandles[2];
	
	parentConstraint -mo $shaperCtrlCrv $aSpineClusterHandles[3];
	
	parentConstraint -mo $hiJnt $aSpineClusterHandles[4];
	parentConstraint -mo $hiJnt $aSpineClusterHandles[5];
	
	
	// connect curve info node for stretch
	
	// add ref spine joints to the denominator for determining each joints ratio
	string $spineRefStrPlsMns = abRTCreateNode("plusMinusAverage", "spineRefStr", "", $limbName);
	
	for ($i=0;$i<size($aRefSpineJnts);$i++){
		connectAttr ($aRefSpineJnts[$i]+".tx") ($spineRefStrPlsMns+".input1D["+$i+"]");
	}
	
	// create joint ratios
	string $aSpineRatioMltDiv[], $tNode;
	for ($i=0;$i<size($aRefSpineJnts);$i++){
		
		$int = $i % 3;
		if ($int == 0){
			$tNode = abRTCreateNode("multiplyDivide", ("spineJntRatio"+(ceil(($i+1)/3))), "", $limbName);
			$aSpineRatioMltDiv[size($aSpineRatioMltDiv)] = $tNode;
			setAttr ($tNode+".operation") 2;
		}else{
			$tNode = $aSpineRatioMltDiv[size($aSpineRatioMltDiv)-1];
		}
		
		connectAttr -f ($aRefSpineJnts[$i]+".tx") ($tNode+".input1"+$aAxes[$int]);
		connectAttr -f ($spineRefStrPlsMns+".output1D") ($tNode+".input2"+$aAxes[$int]);
		
	}
	
	// multiply ratios and current curve length
	string $aSpineArcLenMltDiv[];
	for ($i=0;$i<size($aRigSpineJnts);$i++){
		
		$int = $i % 3;
		$int2 = floor($i/3);
		if ($int == 0){
			$tNode = abRTCreateNode("multiplyDivide", ("spineArcLen"+(ceil(($i+1)/3))), "", $limbName);
			$aSpineArcLenMltDiv[size($aSpineArcLenMltDiv)] = $tNode;
		}else{
			$tNode = $aSpineArcLenMltDiv[size($aSpineArcLenMltDiv)-1];
		}
		
		connectAttr -f ($aSpineRatioMltDiv[$int2]+".output"+$aAxes[$int]) ($tNode+".input1"+$aAxes[$int]);
		connectAttr -f $scaleAdjustedArcLen ($tNode+".input2"+$aAxes[$int]);
		
		connectAttr -f ($tNode+".output"+$aAxes[$int]) ($aRigSpineJnts[$i]+".tx");
	}
	
	
	// create a control curve to put rotate distribution attributes on
	string $spineRotDistCtrlCrv = abRTWireContoller("octagonFilled", 2, {}, 4, false);
	
	$aStr = abRTRename($spineRotDistCtrlCrv, ($charName+"_spineSplitRot_ctrl"));
	$spineRotDistCtrlCrv = $aStr[1];
	
	select $midCtrlCrv $spineRotDistCtrlCrv;
	abRTPointOrient(1);
	$float = abRTGetMaxDim($midCtrlCrv);
	setAttr ($spineRotDistCtrlCrv+".tx") ($float*.6);
	$spineRotDistCtrlCrv = abRTParent($spineRotDistCtrlCrv, $midCtrlCrv);
	
	// update UI with spineSplit ctrl
	abRTSetUITxtFld("spineSplitCtrl", $spineRotDistCtrlCrv);
	
	
	// add spline twist
	
	// set the loc as the ikSpline's up object
	setAttr ($aSpineIkHandle[0]+".dTwistControlEnable") 1;
	setAttr ($aSpineIkHandle[0]+".dWorldUpType") 4;
	setAttr ($aSpineIkHandle[0]+".dWorldUpAxis") 0;
	setAttr ($aSpineIkHandle[0]+".dWorldUpVector") 0 0 -1;
	setAttr ($aSpineIkHandle[0]+".dWorldUpVectorEnd") 0 0 -1;
	
	connectAttr -f ($lowCtrlCrv+".worldMatrix[0]") ($aSpineIkHandle[0]+".dWorldUpMatrix");
	connectAttr -f ($hiCtrlCrv+".worldMatrix[0]") ($aSpineIkHandle[0]+".dWorldUpMatrixEnd");
	
	
	// hide stuff no one wants to see
	setAttr ($aRefSpineJnts[0]+".v") 0;
	setAttr ($spineCurve+".v") 0;
	setAttr ($aSpineIkHandle[0]+".v") 0;
	
	// create more atts
	addAttr -ln "ikSpineVis" -at bool -dv 0 -keyable true $rootCtrl;
	
	// connect spineSplitAdjuster
	addAttr -ln "spineSplitCtrlVis" -at bool -dv 1 -keyable true $rootCtrl;
	connectAttr ($rootCtrl+".spineSplitCtrlVis") ($spineRotDistCtrlCrv+".v");
	
	// connect stretch value
	string $spineStrAmtMltDiv = abRTCreateNode("multiplyDivide", "spineStrAmt", "", $limbName);
	
	setAttr ($spineStrAmtMltDiv+".operation") 2;
	connectAttr $scaleAdjustedArcLen ($spineStrAmtMltDiv+".input1X");
	connectAttr ($spineRefStrPlsMns+".output1D") ($spineStrAmtMltDiv+".input2X");
	connectAttr ($spineStrAmtMltDiv+".outputX") ($cogCtrlCrv+".stretchValue");
	
	// connect attributes
	connectAttr ($cogCtrlCrv+".spineShaper") ($shaperCtrlCrv+".v");
	connectAttr ($rootCtrl+".ikSpineVis") ($aRigSpineJnts[0]+".v");
	
	// hide undesired attributes
	abRTHideAttr($cogCtrlCrv, {"sx","sy","sz","v"});
	abRTHideAttr($hipCtrlCrv, {"sx","sy","sz","v"});
	abRTHideAttr($lowCtrlCrv, {"tx","ty","tz","sx","sy","sz","v"});
	abRTHideAttr($midCtrlCrv, {"sx","sy","sz","v"});
	abRTHideAttr($shaperCtrlCrv, {"rx","ry","rz","sx","sy","sz","v"});
	abRTHideAttr($hiCtrlCrv, {"sx","sy","sz","v"});
	abRTHideAttr($spineRotDistCtrlCrv, {"tx","ty","tz","rx","ry","rz","sx","sy","sz","v"});
	
	// color the ctrls
	int $colorIndex = int(abRTGetGlobal("cogCtrlColor"));
	abRTColorObj($cogCtrlCrv, $colorIndex);
	
	int $colorIndex = int(abRTGetGlobal("ctrCtrlColor"));
	abRTColorObj($hipCtrlCrv, $colorIndex);
	abRTColorObj($lowCtrlCrv, $colorIndex);
	abRTColorObj($midCtrlCrv, $colorIndex);
	abRTColorObj($shaperCtrlCrv, $colorIndex);
	abRTColorObj($hiCtrlCrv, $colorIndex);
	
	print "\n";  //keep generic ikSpline warning from appearing
	
	$ret = 1;
	return $ret;
}


global proc int abRTRigHead(string $neck, string $head){
	// rigs head and neck -- returns 1 on success, -1 on failure
	
	int $ret = -1;
	
	if ($neck == "" || $head == "") return $ret;
	
	string $aStr[], $aRel[], $jnt, $str;
	float $float, $aTrans[];
	
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	
	abRTSetScale($neck);
	
	// create head rig group
	string $headGrp = (abRTRigNamer("head", "", "rigGrp", true));
	if (!`objExists ((abRTRigRootFolder())+"|"+$headGrp)`){
		$headGrp = `group -em -name $headGrp`;
		$headGrp = abRTParent($headGrp, abRTRigRootFolder());
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($headGrp);
	
	string $limbName = "head";
	
	// save headGrp to charVars
	abRTSaveRigGrpToCharVars($headGrp, $limbName);
	
	$aRel = `listRelatives -p -fullPath -type joint $neck`;
	if (size($aRel) == 0){
		warning "Neck joint needs to be child of another joint";
		return $ret;
	}
	
	// get last spine jnt
	string $lastSpineJnt = firstParentOf($neck);
	
	$aStr = abRTAddFkControls({$neck,$head}, {"neck","head"}, {0,1}, $lastSpineJnt, "sphere", $headGrp, $limbName);
	
	string $neckCtrl = $aStr[1];
	string $headCtrl = $aStr[3];
	
	abRTSetUITxtFld("neckCtrl", $neckCtrl);
	abRTSetUITxtFld("headCtrl", $headCtrl);
	
	// set the rotate order to zxy
	if (attributeExists("rotateOrder", $neckCtrl)) setAttr ($neckCtrl+".rotateOrder") 2;
	if (attributeExists("rotateOrder", $headCtrl)) setAttr ($headCtrl+".rotateOrder") 2;
	
	// replace the controls
	abRTReplaceWireController($neckCtrl, "circle", 1, false);
	abRTReplaceWireController($headCtrl, "circle", 1, false);
	
	abRTScaleWireController($neckCtrl, 35, true);
	abRTScaleWireController($headCtrl, 50, true);
	
	// color the ctrls
	int $ctrColorIndex = int(abRTGetGlobal("ctrCtrlColor"));
	abRTColorObj($neckCtrl, $ctrColorIndex);
	abRTColorObj($headCtrl, $ctrColorIndex);
	
	
	// HEAD IK CTRL
	
	if ($rootCtrl != ""){
		
		// make it
		string $ikHeadCtrlCrv = abRTWireContoller("circle", 1, {}, 45, false);
		$aStr = abRTRename($ikHeadCtrlCrv, abRTRigNamer("head", "", "ikCtrl", true));
		$ikHeadCtrlCrv = $aStr[1];
		
		// place it
		$aStr = `pointConstraint $head $ikHeadCtrlCrv`;
		if (size($aStr) > 0) delete $aStr[0];
		
		$ikHeadCtrlCrv = abRTParent($ikHeadCtrlCrv, $headGrp);
		
		// freeze transforms 
		makeIdentity -apply true -t 1 -r 1 -s 1 $ikHeadCtrlCrv;
		abRTHideAttr($ikHeadCtrlCrv, {"rx","ry","rz","sx","sy","sz"});
		
		// point contrain head to ikCtrl
		pointConstraint $ikHeadCtrlCrv $head;
		
		// set up space switching
		//$ikHeadCtrlCrv = abRTParentConstrainToSpace($ikHeadCtrlCrv, $ikHeadCtrlCrv, {"rootCtrl","neck"}, "head", "neck");
		$ikHeadCtrlCrv = abRTParentConstrainToSpace($ikHeadCtrlCrv, $ikHeadCtrlCrv, {"rootCtrl","neckCtrl"}, "headCtrl", "neckCtrl");
		
		// hide space atts and vis
		$aStr = `listAttr -userDefined $ikHeadCtrlCrv`;
		$aStr[size($aStr)] = "v";
		for ($str in $aStr) setAttr -keyable false -cb false ($ikHeadCtrlCrv+"."+$str);
		
		// add useRootSpace att
		addAttr -ln "useRootSpace" -at bool -dv false -keyable true $ikHeadCtrlCrv;
		
		// connect useRootSpace att
		string $ikHeadCtrlSpacePlsMns = abRTCreateNode("plusMinusAverage", "ikHeadSpace", "", $limbName);
		
		setAttr ($ikHeadCtrlSpacePlsMns+".input1D[0]") 1;
		setAttr ($ikHeadCtrlSpacePlsMns+".operation") 2;
		connectAttr ($ikHeadCtrlCrv+".useRootSpace") ($ikHeadCtrlSpacePlsMns+".input1D[1]");
		
		connectAttr ($ikHeadCtrlCrv+".useRootSpace") ($ikHeadCtrlCrv+".rootCtrl");
		//connectAttr ($ikHeadCtrlSpacePlsMns+".output1D") ($ikHeadCtrlCrv+".neck");
		connectAttr ($ikHeadCtrlSpacePlsMns+".output1D") ($ikHeadCtrlCrv+".neckCtrl");
		
		// override align -- need to enable it if using rootSpace
		$aStr = `connectionInfo -destinationFromSource ($headCtrl+".align")`;
		if (size($aStr) > 0){
			
			string $ikHeadCtrlSpaceCond = abRTCreateNode("condition", "ikHeadSpace", "", $limbName);
			
			setAttr ($ikHeadCtrlSpaceCond+".operation") 0;
			setAttr ($ikHeadCtrlSpaceCond+".secondTerm") 0;
			setAttr ($ikHeadCtrlSpaceCond+".colorIfFalseR") 1;
			
			connectAttr ($ikHeadCtrlCrv+".useRootSpace") ($ikHeadCtrlSpaceCond+".firstTerm");
			connectAttr ($headCtrl+".align") ($ikHeadCtrlSpaceCond+".colorIfTrueR");
			
			for ($str in $aStr) connectAttr -f ($ikHeadCtrlSpaceCond+".outColorR") $str;
			
		}
		
		// add ability to toggle visibility of ikCurve to fkCurve
		addAttr -ln "ikCtrlVis" -at bool -dv false -keyable true $headCtrl;
		connectAttr ($headCtrl+".ikCtrlVis") ($ikHeadCtrlCrv+".v");
		
		// color the curve
		abRTColorObj($ikHeadCtrlCrv, (int(abRTGetGlobal("cogCtrlColor"))));
		
	}
	
	// /HEAD IK CTRL
	
	
	// make eye ctrls
	string $eyeJnt = abRTGetFromUI("eye");
	if ($eyeJnt != ""){
		
		float $scale = float(abRTGetGlobal("globalScale"));
		
		float $eyeCtrlOffset = float(abRTGetGlobal("eyeCtrlOffset"));
		
		string $mEyeJnt = abRTGetMirrorObj($eyeJnt);
		if ($mEyeJnt != ""){
		
		string $prefix = abRTGetObjSide($eyeJnt);
		string $mPrefix = ($prefix == "l") ? "r" : "l";
		
		string $eyeWire = "leftEye_1";
		string $mEyeWire = "rightEye_1";
		
		if ($prefix == "r"){
			$str = $eyeWire;
			$eyeWire = $mEyeWire;
			$mEyeWire = $str;
		}
		
		
		// create and position eyeCtrl
		string $eyeCtrl = abRTWireContoller($eyeWire, 5, {}, 5, false);
		$aStr = abRTRename($eyeCtrl, abRTRigNamer("eye", $prefix, "ctrl", true));
		$eyeCtrl = $aStr[1];
		
		$eyeCtrl = abRTParent($eyeCtrl, $headGrp);
		
		select -r $eyeJnt $eyeCtrl;
		abRTPointOrient(1);
		select -clear;
		
		string $eyeFrzGrp1 = abRTGroupFreeze($eyeCtrl, 1);
		$eyeCtrl = $eyeFrzGrp1+"|"+abRTStripPath($eyeCtrl);
		
		string $tLoc = abRTMakeLocator("abEyePlacement_loc");
		select -r $eyeJnt $tLoc;
		abRTPointOrient(1);
		select -clear;
		$aTrans = `xform -q -ws -t $tLoc`;
		
		setAttr ($eyeCtrl+".tz") ($aTrans[2]+$eyeCtrlOffset*$scale);
		
		string $eyeFrzGrp2 = abRTGroupFreeze($eyeCtrl, 1);
		$eyeCtrl = $eyeFrzGrp2+"|"+abRTStripPath($eyeCtrl);
		
		
		// mirror eye ctrl
		string $mEyeCtrl = abRTWireContoller($mEyeWire, 5, {}, 5, false);
		$aStr = abRTRename($mEyeCtrl, abRTRigNamer("eye", $mPrefix, "ctrl", true));
		$mEyeCtrl = $aStr[1];
		
		$mEyeCtrl = abRTParent($mEyeCtrl, $headGrp);
		
		select -r $mEyeJnt $mEyeCtrl;
		abRTPointOrient(1);
		select -clear;
		
		string $mEyeFrzGrp1 = abRTGroupFreeze($mEyeCtrl, 1);
		$mEyeCtrl = $mEyeFrzGrp1+"|"+abRTStripPath($mEyeCtrl);
		
		select -r $mEyeJnt $tLoc;
		abRTPointOrient(1);
		select -clear;
		$aTrans = `xform -q -ws -t $tLoc`;
		
		setAttr ($mEyeCtrl+".tz") ($aTrans[2]+$eyeCtrlOffset*$scale);
		
		string $mEyeFrzGrp2 = abRTGroupFreeze($mEyeCtrl, 1);
		$mEyeCtrl = $mEyeFrzGrp2+"|"+abRTStripPath($mEyeCtrl);
		
		delete $tLoc;
		
		
		// create and position master control and parent eye ctrls to it
		string $eyeMasterCtrl = abRTWireContoller("eyeHolder_1", 5, {}, 18, false);
		$eyeMasterCtrl = abRTParent($eyeMasterCtrl, $headGrp);
		$aStr = abRTRename($eyeMasterCtrl, abRTRigNamer("eyeMaster", "", "ctrl", true));
		$eyeMasterCtrl = $aStr[0];
		
		$aStr = `pointConstraint $eyeCtrl $eyeMasterCtrl`;
		pointConstraint $mEyeCtrl $eyeMasterCtrl;
		delete $aStr;
		$aStr = `orientConstraint $eyeCtrl $eyeMasterCtrl`;
		orientConstraint $mEyeCtrl $eyeMasterCtrl;
		delete $aStr;
		
		string $eyeMasterFrzGrp = abRTGroupFreeze($eyeMasterCtrl, 1);
		$eyeMasterCtrl = $eyeMasterFrzGrp+"|"+abRTStripPath($eyeMasterCtrl);
		
		parentConstraint -mo $eyeMasterCtrl $eyeFrzGrp2;
		parentConstraint -mo $eyeMasterCtrl $mEyeFrzGrp2;
		
		// create eye aim constraints
		aimConstraint -aimVector 0 0 1 $eyeCtrl $eyeJnt;
		aimConstraint -aimVector 0 0 1 $mEyeCtrl $mEyeJnt;
		
		// hide control atts
		abRTHideAttr($eyeMasterCtrl, {"sx","sy","sz","v"});
		abRTHideAttr($eyeCtrl, {"rx","ry","rz","sx","sy","sz","v"});
		abRTHideAttr($mEyeCtrl, {"rx","ry","rz","sx","sy","sz","v"});
		
		// color the eye ctrls
		abRTColorObj($eyeMasterCtrl, $ctrColorIndex);
		int $lfColorIndex = int(abRTGetGlobal("lfCtrlColor"));
		int $rtColorIndex = int(abRTGetGlobal("rtCtrlColor"));
		int $eyeColorIndex = ($prefix == "l") ? $lfColorIndex : $rtColorIndex;
		int $mEyeColorIndex = ($mPrefix == "l") ? $lfColorIndex : $rtColorIndex;
		
		abRTColorObj($eyeCtrl, $eyeColorIndex);
		abRTColorObj($mEyeCtrl, $mEyeColorIndex);
		
		// parent to spaces
		abRTParentConstrainToSpace($eyeMasterFrzGrp, $eyeMasterCtrl, {"rootCtrl","headCtrl"}, "eyeFrzGrp", "rootCtrl");
		
		}
	}
	
	select -clear;
	
	$ret = 1;
	return $ret;
}


global proc int abRTRigArm(string $upArmJnt){
	// rigs an arm -- returns 1 on success,  -1 on fail
	
	int $ret = -1;
	
	if ($upArmJnt == "") return $ret;
	
	int $i;
	string $aRel[];
	
	abRTSetScale($upArmJnt);
	
	int $upArmSplitNum = int(abRTGetFromUI("UpArmSplit"));
	int $foreArmSplitNum = int(abRTGetFromUI("ForeArmSplit"));
	
	// move down hierarchy to get wrist joint
	string $aAllArmJnts[];
	$aAllArmJnts[0] = $upArmJnt;
	
	for ($i=0;$i<($upArmSplitNum+$foreArmSplitNum+2);$i++){
		$aRel = `listRelatives -c -fullPath -type joint $aAllArmJnts[$i]`;
		if (size($aRel) == 1){
			$aAllArmJnts[size($aAllArmJnts)] = $aRel[0];;
		}else{
			break;
		}
	}
	
	// get the elbow and wrist
	string $elbowJnt, $wristJnt;
	if (size($aAllArmJnts) == ($upArmSplitNum+$foreArmSplitNum+3)){
		$elbowJnt = $aAllArmJnts[1+$upArmSplitNum];
		$wristJnt = $aAllArmJnts[2+$upArmSplitNum+$foreArmSplitNum];
	}else{
		warning "Incorrect number of joints in hierarchy.  Make sure you've entered the correct number of split joints in the UI.";
		return $ret;
	}
	
	
	// sort split joints into separate arrays
	string $aArmJnts[], $aUpArmSplitJnts[], $aForeArmSplitJnts[];
	for ($i=0;$i<size($aAllArmJnts);$i++){
		if ($i > 0){
			if ($i <= $upArmSplitNum){
				$aUpArmSplitJnts[size($aUpArmSplitJnts)] = $aAllArmJnts[$i];
				continue;
			}else if ($i > ($upArmSplitNum + 1) && $i < ($upArmSplitNum + $foreArmSplitNum + 2)){
				$aForeArmSplitJnts[size($aForeArmSplitJnts)] = $aAllArmJnts[$i];
				continue;
			}
		}
		
		$aArmJnts[size($aArmJnts)] = $aAllArmJnts[$i];
	}
	
	int $colorIndex, $int;
	float $xForm[], $xForm2[], $float, $float2;
	string $aStr[], $aJnts[], $globalKey, $name, $aNames[], $str, $jnt;
	string $aCtrlCurves[]; // all ctrl curves put in this array will be colored according to the side of the body
	string $aIkCtrls[]; // objects in this array will have visibility switched according to ikFk switch on footCtrl
	string $aFkCtrls[]; // objects in this array will have visibility switched according to ikFk switch on footCtrl
	string $aArmJntKeyNames[] = {"upArm","elbow","wrist"};
	
	string $shoulderJnt = firstParentOf($upArmJnt);
	
	$aRel = `listRelatives -c -fullPath -type joint $wristJnt`;
	if (size($aRel) != 1){
		warning "There needs to be a single hand joint beneath the wrist joint.";
		return $ret;
	}
	string $handJnt = $aRel[0];
	
	string $prefix = abRTGetObjSide($upArmJnt);
	string $limbName = ($prefix == "l") ? "leftArm" : "rightArm";
	
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	int $mirroredBehavior = abRTJointMirroredBehavior($elbowJnt);
	
	// create arm rig group
	string $armGrp = (abRTRigNamer("arm", $prefix, "rigGrp", true)); // arm group -- all arm rig transforms created from here out will be placed in this group
	if (!`objExists ((abRTRigRootFolder())+"|"+$armGrp)`){
		$armGrp = `group -em -name $armGrp`;
		$armGrp = abRTParent($armGrp, abRTRigRootFolder());
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($armGrp);
	
	// save armGrp to charVars
	abRTSaveRigGrpToCharVars($armGrp, $limbName);
	abRTSaveToCharVars($aAllArmJnts, $limbName);
	
	// put fk ctrls on shoulder
	$aStr = abRTAddFkControls({$shoulderJnt}, {"clavicle"}, {}, "", "sphere", $armGrp, $limbName);
	$shouderJnt =  $aStr[0];
	$shouderCtrl = $aStr[1];
	
	abRTHideAttr($shouderCtrl, {"rx"});
	abRTReplaceWireController($shouderCtrl, "simpleCurve", 3, false);
	
	$xForm = objectCenter($shoulderJnt);
	$xForm2 = objectCenter($upArmJnt);
	abRTMoveWireRelativeToPivot($shouderCtrl, (($xForm2[0]-$xForm[0])), 2, 0, true);
	
	// make ref arm
	clear($aNames);
	for ($globalKey in $aArmJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "refJnt", false);
	string $aRefJnts[] = abRTDuplicateJointHierarchy({$upArmJnt,$elbowJnt,$wristJnt}, $aNames, $armGrp);
	
	// make invisible
	for ($jnt in $aRefJnts) setAttr ($jnt+".v") 0;
	
	// done
	
	// make fk arm
	string $fkArmGrp = `group -em -name ((abRTRigNamer("armFK", $prefix, "Grp", true))) -p $armGrp`;
	
	if ($shoulderJnt != ""){
		select -r $shoulderJnt $fkArmGrp;
	}else{
		select -r $upArmJnt $fkArmGrp;
	}
	
	abRTPointOrient(1);
	select -clear;
	
	clear($aNames);
	for ($globalKey in $aArmJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "fkJnt", false);
	$aJnts = abRTDuplicateJointHierarchy($aArmJnts, $aNames, $fkArmGrp);
	
	if ($shoulderJnt != "") parentConstraint -mo $shoulderJnt $fkArmGrp;
	
	// add fk controls
	$aStr = abRTAddFkControls({$aJnts[0],$aJnts[1]}, $aArmJntKeyNames, {0}, $shoulderJnt, "sphere", $armGrp, $limbName);
	// limit knee to z
	
	string $aFkJnts[];
	for ($i=0;$i<size($aStr);$i+=2){
		$aFkJnts[size($aFkJnts)] = $aStr[$i];
		$aFkCtrls[size($aFkCtrls)] = $aStr[$i+1];
	}
	
	$aFkJnts[size($aFkJnts)] = $aJnts[size($aJnts)-1]; // add wrist joint into aFkJnts;
	
	// color it
	$colorIndex = int(abRTGetGlobal("fkJntColor"));
	for ($jnt in $aFkJnts) abRTColorObj($jnt, $colorIndex);
	
	// color them
	$aCtrlCurves = stringArrayCatenate($aCtrlCurves,$aFkCtrls);
	
	// fk done
	
	
	// make ik arm
	// start with names
	
	// make grp for ik arm
	string $ikArmGrp = `group -em -name ((abRTRigNamer("armIK", $prefix, "Grp", true))) -p $armGrp`;
	if ($shoulderJnt != ""){
		select -r $shoulderJnt $ikArmGrp;
	}else{
		select -r $upArmJnt $ikArmGrp;
	}
	
	abRTPointOrient(1);
	select -clear;
	
	clear($aNames);
	for ($globalKey in $aArmJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "ikJnt", false);
	string $aIkJnts[] = abRTDuplicateJointHierarchy({$upArmJnt,$elbowJnt,$wristJnt}, $aNames, $ikArmGrp);
	
	if ($shoulderJnt != "") parentConstraint -mo $shoulderJnt $ikArmGrp;
	
	
	// color it 
	$colorIndex = int(abRTGetGlobal("ikJntColor"));
	for ($jnt in $aIkJnts) abRTColorObj($jnt, $colorIndex);
	
	// create ik control curve
	string $ikCtrlCrv = abRTWireContoller("diamond", 8, {}, 10, false);
	select -r $wristJnt $ikCtrlCrv;
	abRTPointOrient(1);
	select -clear;
	
	$ikCtrlCrv = abRTParent($ikCtrlCrv, $armGrp);
	$aStr = abRTRename($ikCtrlCrv, (abRTRigNamer("arm", $prefix, "ikCtrl", true)));
	$ikCtrlCrv = $aStr[1];
	
	
	int $alignIkWithWorld = int(abRTGetFromUI("AlignHandIK"));
	string $ikCtrlGrp; // only used if the hand is not aligned to the world
	
	if ($alignIkWithWorld){
		// freeze transforms on ikCtrlCrv and hide rotation atts
		setAttr ($ikCtrlCrv+".r") 0 0 0;
		$ikCtrlGrp = abRTGroupFreeze($ikCtrlCrv, 1);
		$ikCtrlCrv = $ikCtrlGrp+"|"+abRTStripPath($ikCtrlCrv);
		
	}else{
		if ($mirroredBehavior && $prefix == "r"){
			// rotate the ikCtrlCrv into proper orientation
			$float = `getAttr ($ikCtrlCrv+".rx")`;
			$float = ($float > 0) ? $float - 180 : $float + 180;
			setAttr ($ikCtrlCrv+".rx") $float;
		}
		$ikCtrlGrp = abRTGroupFreeze($ikCtrlCrv, 1);
		$ikCtrlCrv = $ikCtrlGrp+"|"+abRTStripPath($ikCtrlCrv);
	}
	
	if ($prefix == "l") abRTSetUITxtFld("lfArmIkCtrl", $ikCtrlCrv);
	else abRTSetUITxtFld("rtArmIkCtrl", $ikCtrlCrv);
	
	// hide undesired attributes
	abRTHideAttr($ikCtrlCrv, {"sx","sy","sz","v"});
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $ikCtrlCrv;
	
	// set up its visibility (later
	$aIkCtrls[size($aIkCtrls)] = $ikCtrlCrv;
	
	// create arm ikHandle
	string $ikArmHandle = abRTMakeIkHandle($aIkJnts[0], $aIkJnts[2], abRTRigNamer("arm", $prefix, "ikHndl", true), $ikCtrlCrv, $armGrp);
	
	// add attributes to ik control
	
	// arm twist
	addAttr -ln "armTwist" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	connectAttr ($ikCtrlCrv+".armTwist") ($ikArmHandle+".twist");
	
	// create hand control curve (attached to bottom of hand)
	string $handCtrlCrv = abRTWireContoller("circle", 0, {}, 12, false);
	
	select -r $handJnt $handCtrlCrv;
	abRTPointOrient(1);
	select -clear;
	
	$handCtrlCrv = abRTParent($handCtrlCrv, $armGrp);
	$aStr = abRTRename($handCtrlCrv, (abRTRigNamer("hand", $prefix, "ctrl", true)));
	$handCtrlCrv = $aStr[1];
	
	string $handCtrlParGrp = `group -w -em -n (abRTRigNamer("handCtrl", $prefix, "grp", true))`;
	$handCtrlParGrp = abRTParent($handCtrlParGrp, $armGrp);
	
	select -r $wristJnt $handCtrlParGrp;
	abRTPointOrient(1);
	select -clear;
	
	$handCtrlCrv = abRTParent($handCtrlCrv, $handCtrlParGrp);
	
	string $handCtrlPtGrpFrz = abRTGroupFreeze($handCtrlCrv, 1);
	$handCtrlCrv = $handCtrlPtGrpFrz+"|"+abRTStripPath($handCtrlCrv);
	
	string $handCtrlOrGrpFrz = abRTGroupFreeze($handCtrlCrv, 1);
	$handCtrlCrv = $handCtrlOrGrpFrz+"|"+abRTStripPath($handCtrlCrv);
	
	parentConstraint $wristJnt $handCtrlParGrp;
	
	$aStr = `pointConstraint $handJnt $handCtrlPtGrpFrz`;
	string $handAlignPtCons = $aStr[0];
	
	$aStr = `orientConstraint -mo $ikCtrlCrv $handCtrlOrGrpFrz`;
	string $handIkOrCons = $aStr[0];
	
	orientConstraint $handCtrlCrv $handJnt;
	
	// rotate order
	setAttr ($ikCtrlCrv+".rotateOrder") 2;
	setAttr ($handCtrlCrv+".rotateOrder") 2;
	
	// hide undesired attributes
	abRTHideAttr($handCtrlCrv, {"tx","ty","tz","sx","sy","sz","v"});
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $handCtrlCrv;
	
	// add attributes
	addAttr -ln "fkAlign" -at bool -keyable true $handCtrlCrv;
	
	addAttr -ln "ikFkBlend" -at double -min 0 -max 1 -dv 1 -keyable true $handCtrlCrv;
	
	addAttr -ln "ikVis" -at bool -keyable true $handCtrlCrv;
	setAttr ($handCtrlCrv+".ikVis") 0;
	connectAttr ($handCtrlCrv+".ikVis") ($aIkJnts[0]+".v");
	
	addAttr -ln "fkVis" -at bool -keyable true $handCtrlCrv;
	setAttr ($handCtrlCrv+".fkVis") 0;
	connectAttr ($handCtrlCrv+".fkVis") ($aFkJnts[0]+".v");
	
	// create ikFkBlend reverse
	string $ikFkReverse = abRTCreateNode("reverse", "armIkFkSwitch", $prefix, $limbName);
	
	connectAttr -f ($handCtrlCrv+".ikFkBlend") ($ikFkReverse+".inputX");
	
	// allow hand to align by keeping the orient constraint of the ikCtrl over the handCtrl active in fkMode
	$str = abRTCreateNode("condition", "fkHandAlign", $prefix, $limbName);
	
	connectAttr ($handCtrlCrv+".fkAlign") ($str+".firstTerm");
	setAttr ($str+".secondTerm") 1;
	setAttr ($str+".colorIfTrueR") 1;
	connectAttr ($handCtrlCrv+".ikFkBlend") ($str+".colorIfFalseR");
	$aStr = `orientConstraint -q -wal $handIkOrCons`;
	connectAttr ($str+".outColorR") ($handIkOrCons+"."+$aStr[0]);
	
	// hand ctrl done
	
	
	// expose rotate order on controls
	setAttr -lock false -channelBox true ($ikCtrlCrv+".rotateOrder");
	setAttr -lock false -channelBox true ($handCtrlCrv+".rotateOrder");
	
	
	// create pv control
	$aStr = abRTMakePvControl($aIkJnts, $ikArmHandle, $elbowJnt, 5, "elbow", $armGrp);
	string $pvCtrl = $aStr[0];
	string $pvCtrlGrp = $aStr[2];
	$aIkCtrls[size($aIkCtrls)] = $pvCtrlGrp; // add to ik vis nodes
	
	// pv vis controls on ik arm ctrl
	addAttr -ln "pvControl" -at bool -keyable true $ikCtrlCrv;
	setAttr ($ikCtrlCrv+".pvControl") 1;
	
	// $aStr[0] - pv control, $aStr[1] - pv constraint, $aStr[3] - pv line, $aStr[4] - lineJointLoc
	connectAttr -f ($ikCtrlCrv+".pvControl") ($pvCtrl+".v");
	connectAttr ($ikCtrlCrv+".pvControl") ($aStr[1]+"."+(abRTStripPath($pvCtrl))+"W0");
	connectAttr -f ($ikCtrlCrv+".pvControl") ($aStr[3]+".v");
	connectAttr -f ($ikCtrlCrv+".pvControl") ($aStr[4]+".v");
	
	// create blend for pv control (between pv constraint and 0 0 0)
	string $tCon[];
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikArmHandle+".poleVectorX")`;
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikArmHandle+".poleVectorY")`;
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikArmHandle+".poleVectorZ")`;
	
	string $pvCtrlBlnd = abRTCreateNode("blendColors", "armPvCtrl", $prefix, $limbName);
	
	connectAttr ($ikCtrlCrv+".pvControl") ($pvCtrlBlnd+".blender");
	
	connectAttr $tCon[0] ($pvCtrlBlnd+".color1R");
	connectAttr $tCon[1] ($pvCtrlBlnd+".color1G");
	connectAttr $tCon[2] ($pvCtrlBlnd+".color1B");
	
	setAttr ($pvCtrlBlnd+".color2") 0 0 0;
	
	connectAttr -f ($pvCtrlBlnd+".outputR") ($ikArmHandle+".poleVectorX");
	connectAttr -f ($pvCtrlBlnd+".outputG") ($ikArmHandle+".poleVectorY");
	connectAttr -f ($pvCtrlBlnd+".outputB") ($ikArmHandle+".poleVectorZ");
	
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $pvCtrl;
	
	// pv done (except for snap, which will be plugged into elbow after orient stuff)
	
	
	// add stretch
	abRTMakeIKStretchy($aArmJnts, $aIkJnts, $aFkJnts, $aRefJnts, $ikCtrlCrv, $handCtrlCrv, $ikCtrlCrv, $armGrp, $limbName);
	
	
	// tx constrain arm to fk and ik
	string $armTxBlnd = abRTCreateNode("blendColors", "armTrans", $prefix, $limbName);
	
	connectAttr ($handCtrlCrv+".ikFkBlend") ($armTxBlnd+".blender");
	connectAttr ($aIkJnts[1]+".tx") ($armTxBlnd+".color1R");
	connectAttr ($aIkJnts[2]+".tx") ($armTxBlnd+".color1G");
	connectAttr ($aFkJnts[1]+".tx") ($armTxBlnd+".color2R");
	connectAttr ($aFkJnts[2]+".tx") ($armTxBlnd+".color2G");
	
	// connect upArm and elbow jnts tx (including splits) to $armTxBlnd outputs
	float $upSplitRatios[] = abRTSetupSplitJointTx($aUpArmSplitJnts, $aRefJnts[1], $elbowJnt, ($armTxBlnd+".outputR"), "upArm", $limbName);
	float $foreSplitRatios[] = abRTSetupSplitJointTx($aForeArmSplitJnts, $aRefJnts[2], $wristJnt, ($armTxBlnd+".outputG"), "foreArm", $limbName);
	
	// stretch done
	
	
	// orient constrain arm to fk and ik
	// constrain ik
	clear $aNames;
	for ($globalKey in $aArmJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "ikFkCons", false);
	string $aIkJntCons[] = abRTMassOrientConstraint({$aIkJnts[0],$aIkJnts[1]}, $aArmJnts, $aNames);
	
	// constrain fk (using same $aNames because these are the same constraints)
	string $aFkJntCons[] = abRTMassOrientConstraint({$aFkJnts[0],$aFkJnts[1]}, $aArmJnts, $aNames);
	
	// set orientconstraints interpType to shortest (less flipping)
	for ($str in $aFkJntCons) setAttr ((`match "[A-Za-z0-9_]+" $str`)+".interpType") 2;
	
	for ($str in $aIkJntCons) connectAttr -f ($handCtrlCrv+".ikFkBlend") $str;
	for ($str in $aFkJntCons) connectAttr -f ($ikFkReverse+".outputX") $str; 
	
	
	// set up upArmSplit joint rotation
	
	$aStr = {"X","Y","Z"}; // used to iterate through multDivNode inputs
	
	string $spineSplitCtrl = abRTGetFromUI("spineSplitCtrl");
	
	string $attLabel;
	
	if (size($aUpArmSplitJnts) > 0){
		
		string $upArmSplitRotMltDiv, $upArmSplitRotBlnd;
		for ($i=0;$i<size($upSplitRatios);$i++){
			$jnt = $aAllArmJnts[$i];
			$str = $aStr[$i];
			
			if ($i == 0){
				
				// first need to release x rot from orientConstraint on upArm ($aIkJntCons[0]) and elbow ($aIkJntCons[1])
				orientConstraint -e -skip "x" (`match "[A-Za-z0-9_]+" $aIkJntCons[0]`);
				$upArmSplitRotBlnd = abRTCreateNode("blendColors", "upArmSplitRot", $prefix, $limbName);
				
				connectAttr ($handCtrlCrv+".ikFkBlend") ($upArmSplitRotBlnd+".blender");
				connectAttr ($aIkJnts[0]+".rx") ($upArmSplitRotBlnd+".color1R");
				connectAttr ($aFkCtrls[0]+".rx") ($upArmSplitRotBlnd+".color2R");
				
				if (size($upSplitRatios) == 1){
					connectAttr ($upArmSplitRotBlnd+".outputR") ($jnt+".rx");
					break;
				}else{
					$upArmSplitRotMltDiv = abRTCreateNode("multiplyDivide", "upArmSplitRot", $prefix, $limbName);
				}
			}
			
			setAttr ($upArmSplitRotMltDiv+".input2"+$str) $upSplitRatios[$i];
			connectAttr ($upArmSplitRotBlnd+".outputR") ($upArmSplitRotMltDiv+".input1"+$str);
			connectAttr ($upArmSplitRotMltDiv+".output"+$str) ($jnt+".rx");
			
		}
		
		
		// write to spineSplit ctrl if it exists
		if ($spineSplitCtrl != "" && `objExists $spineSplitCtrl`){
			
			$attLabel = ($prefix == "l") ? "________LF_UPARM___" : "________RT_UPARM___";
			abRTAddSplitAttsToSpineCurve($spineSplitCtrl, $upSplitRatios, $upArmSplitRotMltDiv, $attLabel, "Uparm", $prefix, $limbName);
		}
	}
	
	// set up elbowSplit joint rotation 
	
	if (size($aForeArmSplitJnts) > 0){
		
		int $startInt = size($aUpArmSplitJnts) + 2;
		int $endInt = $startInt + size($foreSplitRatios); // don't want wrist (last joint in foreArmSplitJnts) to rotate so cut out before then
		string $foreArmSplitRotMltDiv, $foreArmSplitRotBlnd, $ikAndHandCtrlRxPlsMns, $rotXSourceAtt;
		
		for ($i=$startInt;$i<$endInt;$i++){
			$int = $i - $startInt;
			$jnt = $aAllArmJnts[$i];
			$str = $aStr[$int];
			
			if ($i == $startInt){
				if (size($foreSplitRatios) == 1){
					connectAttr ($handCtrlCrv+".rx") ($jnt+".rx");
					break;
				}else{
					$foreArmSplitRotMltDiv = abRTCreateNode("multiplyDivide", "foreArmSplitRot", $prefix, $limbName);
					
					// add ikCtrlCrv and handCtrlCrv rx -- ikCtrlCrv and HandCtrl can rotate hand since LRAs match
					$ikAndHandCtrlRxPlsMns = abRTCreateNode("plusMinusAverage", "ikAndHandCtrlRx", $prefix, $limbName);
					connectAttr ($handCtrlCrv+".rx") ($ikAndHandCtrlRxPlsMns+".input1D[0]");
					connectAttr ($ikCtrlCrv+".rx") ($ikAndHandCtrlRxPlsMns+".input1D[1]");
					$rotXSourceAtt = $ikAndHandCtrlRxPlsMns+".output1D";
				}
			}
			
			setAttr ($foreArmSplitRotMltDiv+".input2"+$str) $foreSplitRatios[$int];
			connectAttr $rotXSourceAtt ($foreArmSplitRotMltDiv+".input1"+$str);
			connectAttr ($foreArmSplitRotMltDiv+".output"+$str) ($jnt+".rx");
			
		}
		
		if ($spineSplitCtrl != "" && `objExists $spineSplitCtrl`){
			
			// add rot ratio attributes to spineSplitCtrl
			$attLabel = ($prefix == "l") ? "________LF_FOREARM___" : "________RT_FOREARM___";
			abRTAddSplitAttsToSpineCurve($spineSplitCtrl, $foreSplitRatios, $foreArmSplitRotMltDiv, $attLabel, "Forearm", $prefix, $limbName);
		}
		
	}
	
	// attach visibility
	string $ikVisCond = abRTCreateNode("condition", "armIkVis", $prefix, $limbName);
	string $fkVisCond = abRTCreateNode("condition", "armFkVis", $prefix, $limbName);
	
	connectAttr -f ($handCtrlCrv+".ikFkBlend") ($ikVisCond+".firstTerm"); 
	setAttr ($ikVisCond+".operation") 2;
	setAttr ($ikVisCond+".colorIfTrueR") 1;
	setAttr ($ikVisCond+".colorIfFalseR") 0;
	
	connectAttr -f ($handCtrlCrv+".ikFkBlend") ($fkVisCond+".firstTerm"); 
	setAttr ($fkVisCond+".operation") 4;
	setAttr ($fkVisCond+".secondTerm") 1;
	setAttr ($fkVisCond+".colorIfTrueR") 1;
	setAttr ($fkVisCond+".colorIfFalseR") 0;
	
	for ($str in $aIkCtrls) connectAttr -f ($ikVisCond+".outColorR") ($str+".v"); 
	for ($str in $aFkCtrls) connectAttr -f ($fkVisCond+".outColorR") ($str+".v"); 
	
	// color the curves in $aCtrlCurves
	$str = ($prefix == "l") ? "lfCtrlColor" : "rtCtrlColor"; // get global colorIndex for this side of the body
	int $colorIndex = int(abRTGetGlobal($str));
	for ($str in $aCtrlCurves) abRTColorObj($str, $colorIndex);
	
	// add pv snap
	addAttr -ln "snapElbow" -at double -min 0 -max 1 -dv 0 -keyable true $pvCtrl;
	
	// make distanceDim -- upArm to pvCtrl
	$aStr = abRTMakeDistanceDim({abRTRigNamer("upArmPvCtrl",$prefix,"dist",true),abRTRigNamer("upArmPvCtrl",$prefix,"dist_sp",true),abRTRigNamer("upArmPvCtrl",$prefix,"dist_ep",true)}, $aIkJnts[0], $pvCtrl, $armGrp);
	
	string $upArmPvDistShape = $aStr[3];
	pointConstraint $aIkJnts[0] $aStr[1];
	pointConstraint $pvCtrl $aStr[2];
	
	// make distanceDim -- pvCtrl to ikCtrl
	$aStr = abRTMakeDistanceDim({abRTRigNamer("armPvIkCtrl",$prefix,"dist",true),abRTRigNamer("armPvIkCtrl",$prefix,"dist_sp",true),abRTRigNamer("armPvIkCtrl",$prefix,"dist_ep",true)}, $pvCtrl, $ikCtrlCrv, $armGrp);
	
	string $pvIkCtrlDistShape = $aStr[3];
	pointConstraint $pvCtrl $aStr[1];
	pointConstraint $ikCtrlCrv $aStr[2];
	
	// divide distance values by the masterScale on the rootCtrl
	string $upArmPvDistAtt, $pvIkCtrlDistAtt;
	
	if ($rootCtrl == ""){
		$upArmPvDistAtt = $upArmPvDistShape+".distance";
		$pvIkCtrlDistAtt = $pvIkCtrlDistShape+".distance";
	}else{
		// create multDiv node to divide values by masterScale
		string $pvDistMltDiv = abRTCreateNode("multiplyDivide", "armPvDistScaleAdjust", $prefix, $limbName);
		setAttr ($pvDistMltDiv+".operation") 2;
		connectAttr ($upArmPvDistShape+".distance") ($pvDistMltDiv+".input1X");
		connectAttr ($pvIkCtrlDistShape+".distance") ($pvDistMltDiv+".input1Y");
		connectAttr ($rootCtrl+".masterScale") ($pvDistMltDiv+".input2X");
		connectAttr ($rootCtrl+".masterScale") ($pvDistMltDiv+".input2Y");
		
		$upArmPvDistAtt = ($pvDistMltDiv+".outputX");
		$pvIkCtrlDistAtt = ($pvDistMltDiv+".outputY");
		
	}
	
	if ($mirroredBehavior && $prefix == "r"){
		// if skeleton was created with mirror behavior, tx will be negative for the -X limb joints, need to negate it to get PV snap to move the joints the correct way
		
		string $pvNegateTxMltDiv = abRTCreateNode("multiplyDivide", "armPvNegate", $prefix, $limbName);
		setAttr ($pvNegateTxMltDiv+".input2") -1 -1 0;
		connectAttr $upArmPvDistAtt ($pvNegateTxMltDiv+".input1X");
		connectAttr $pvIkCtrlDistAtt ($pvNegateTxMltDiv+".input1Y");
		
		$upArmPvDistAtt = ($pvNegateTxMltDiv+".outputX");
		$pvIkCtrlDistAtt = ($pvNegateTxMltDiv+".outputY");
	}
	
	abRTSpliceConnection(($aIkJnts[1]+".tx"), $upArmPvDistAtt, ($pvCtrl+".snapElbow"), false, "upArmSnap", $prefix, $limbName);
	abRTSpliceConnection(($aIkJnts[2]+".tx"), $pvIkCtrlDistAtt, ($pvCtrl+".snapElbow"), false, "elbowSnap", $prefix, $limbName);
	
	// pv snap done
	
	// add spaces to hand and pvctrl
	string $txtFldPrefix = ($prefix == "l") ? "lf" : "rt";
	
	$pvCtrl = abRTParentConstrainToSpace($pvCtrl, $pvCtrl, {"rootCtrl","lowSpineCtrl","hiSpineCtrl",($txtFldPrefix+"ArmIkCtrl")}, "armPvCtrlGrp","rootCtrl");
	
	// if not aligned to world then need to send ikCtrlGrp to abRTParentConstrainToSpace
	$ikCtrlGrp = abRTParentConstrainToSpace($ikCtrlGrp, $ikCtrlCrv, {"rootCtrl","lowSpineCtrl","hiSpineCtrl","headCtrl"}, "armIkCtrl","rootCtrl");
	$ikCtrlCrv = $ikCtrlGrp+"|"+abRTStripPath($ikCtrlCrv);
	
	// create/add fk/ik snap button to shelf
	abRTMakeFkToIkSnapShelfBn(abRTGetGlobal("name"), $limbName, $aFkCtrls, $aFkJnts, $ikCtrlCrv, $handCtrlCrv, $pvCtrl, {$aIkJnts[0],$aIkJnts[1]}, $aArmJnts);
	
	select -clear;
	
	$ret = 1;
	return $ret;
}


global proc int abRTJointMirroredBehavior(string $kneeElbJnt){
	// returns true if the mirror joint of jnt has been mirrored using behavior, false if mirrored with orientation, -1 if it can't find a mirror joint
	// $kneeElbJnt must be a knee or elbow jnt
	
	int $ret = -1;
	float $tol = .001;
	
	string $mJnt = abRTGetMirrorObj($kneeElbJnt);
	
	if ($mJnt == "") return $ret;
	
	float $kneeElbJntTx = `getAttr ($kneeElbJnt+".tx")`;
	float $mJntTx = `getAttr ($mJnt+".tx")`;
	
	$ret = (abs($kneeElbJntTx + $mJntTx) < $tol);
	
	return $ret;
	
}

global proc abRTFingerRigHelper(string $aFinger[], string $CBLabel, string $baseName, string $handCtrl, string $curlSpreadRollAxes, string $mstrFistAtt, string $mstrSpreadAtt, string $fingerSpreadAmtAtt, string $fingerCurlAtt, string $midCurlAmtAtt, string $tipCurlAmtAtt, string $curlDampener, int $makeIk, string $prefix, string $handGrp, string $limbName){
	/*
	takes care of some of the repetitive stuff in finger rigging
	$aFinger is array of {baseFingerJnt, midFingerJnt, tipFingerJnt}
	$CBLabel (channelBox label) is locked category name to precede finger channels with (eg. "________THUMB___")
	$baseName is name of finger (eg. "thumb")
	$handCtrl is path to ctrlCrv to add attributes
	$curlSpreadRollAxes is string specifying (in order) the curl, spread and roll axes for the finger in the form of "xyz". (thumb is default "zyx", fingers are "yzx")
	$rtReverseCurl will reverse the curl axes if the finger is located on the -x side of the z axis (true for fingers, false for thumb)
	$mstrFistAtt, $mstrSpread, $fingerSpreadAmtAtt, $fingerCurlAtt, $midCurlAtt, $tipCurlAtt, and $curlDampener are respective attributes including control curve ("controlCrv.masterFist") (fingerSpreadAmt (optional) is multiplier for given finger to use with masterSpread) (curlDampener (optional) modifies the amount of masterFist inherited by finger -- used to slow thumb curl)
	$makeIk will add finger IK controls if true
	$prefix, $handGrp and $limbName are obvious
	*/
	
	string $mstrSpread = ($handCtrl+".masterSpread");
	
	string $aAxes[] = {"X","Y","Z"};
	string $aPlsMns3dPlug[] = {"3Dx","3Dy","3Dz"};
	string $aBaseNames[] = {"Base","Mid","Tip"};
	string $attName, $plsMns, $curlMultDiv, $curlPlsMns, $rtMltDiv, $rvSpreadPlsMns, $rvRollPlsMns, $dampMltDiv;
	
	string $curlAxis = "r"+(substring($curlSpreadRollAxes, 1, 1));
	string $spreadAxis = "r"+(substring($curlSpreadRollAxes, 2, 2));
	string $rollAxis = "r"+(substring($curlSpreadRollAxes, 3, 3));
	
	int $rtReverseCurl = int(abRTGetGlobal("reverseFingerCurl"));
	
	// curl
	
	for ($i=0;$i<size($aBaseNames);$i++){
		if ($i == size($aFinger)) break;
		
		if ($i == 0){
			if (!attributeExists($CBLabel, $handCtrl)) addAttr -ln $CBLabel -at bool -keyable false $handCtrl;
			setAttr -lock true -cb true ($handCtrl+"."+$CBLabel);
			$plsMns = abRTCreateNode("plusMinusAverage", $baseName, $prefix, $limbName);
			
			// curl stuff
			$curlMultDiv = abRTCreateNode("multiplyDivide", ($baseName+"Curl"), $prefix, $limbName);
			$curlPlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"Curl"), $prefix, $limbName);
			
			// add curl to masterFist
			if ($curlDampener != ""){
				$dampMltDiv = abRTCreateNode("multiplyDivide", ($baseName+"CurlDamp"), $prefix, $limbName);
				connectAttr $mstrFistAtt ($dampMltDiv+".input1X");
				connectAttr $curlDampener ($dampMltDiv+".input2X");
				connectAttr ($dampMltDiv+".outputX") ($curlPlsMns+".input1D[0]");
			}else{
				connectAttr $mstrFistAtt ($curlPlsMns+".input1D[0]");
			}
			
			connectAttr $fingerCurlAtt ($curlPlsMns+".input1D[1]");
			
			// make connections
			setAttr ($curlMultDiv+".input1X") 1;
			connectAttr $midCurlAmtAtt ($curlMultDiv+".input1Y");
			connectAttr $tipCurlAmtAtt ($curlMultDiv+".input1Z");
			connectAttr ($curlPlsMns+".output1D") ($curlMultDiv+".input2X");
			connectAttr ($curlPlsMns+".output1D") ($curlMultDiv+".input2Y");
			connectAttr ($curlPlsMns+".output1D") ($curlMultDiv+".input2Z");
			
			// reverse curl if fingerJnts are on the right side and $rtReverCurl is true
			if ($prefix == "r" && $rtReverseCurl && $baseName != "thumb"){
				$rtMltDiv= abRTCreateNode("multiplyDivide", "indexRev", $prefix, $limbName);
				setAttr ($rtMltDiv+".input1") -1 -1 -1;
			}else{
				$rtMltDiv = "";
			}
		}
		$attName = $baseName+$aBaseNames[$i];
		if (!attributeExists($attName, $handCtrl)) addAttr -ln $attName -at double  -min -90 -max 150 -dv 0 -keyable true $handCtrl;
		
		connectAttr ($curlMultDiv+".output"+$aAxes[$i]) ($plsMns+".input3D[0].input"+$aPlsMns3dPlug[$i]);
		connectAttr ($handCtrl+"."+$attName) ($plsMns+".input3D[1].input"+$aPlsMns3dPlug[$i]);
		
		if ($prefix == "r" && $rtReverseCurl && $baseName != "thumb"){
			connectAttr ($plsMns+".output"+$aPlsMns3dPlug[$i]) ($rtMltDiv+".input2"+$aAxes[$i]);
			connectAttr ($rtMltDiv+".output"+$aAxes[$i]) ($aFinger[$i]+"."+$curlAxis);
		}else{
			connectAttr ($plsMns+".output"+$aPlsMns3dPlug[$i]) ($aFinger[$i]+"."+$curlAxis);
		}
	}
	
	string $spreadPlsMns, $spreadMultDiv;
	string $fingerSpread = $baseName+"Spread";
	string $fingerRoll = $baseName+"Roll";
	string $fingerIk = $baseName+"IK";
	
	// spread
	
	if (!attributeExists($fingerSpread, $handCtrl)) addAttr -ln $fingerSpread -at double  -min -50 -max 50 -dv 0 -keyable true $handCtrl;
	
	$spreadMultDiv = abRTCreateNode("multiplyDivide", ($baseName+"Spread"), $prefix, $limbName);
	$spreadPlsMns = abRTCreateNode("plusMinusAverage", ($baseName+"Spread"), $prefix, $limbName);
	
	// connect atts
	
	// mltDiv
	connectAttr $mstrSpread ($spreadMultDiv+".input1X");
	if ($fingerSpreadAmtAtt != ""){
		connectAttr $fingerSpreadAmtAtt ($spreadMultDiv+".input2X");
	}else{
		// in this case (where there's no spineCtrl with spread att) use default based on five fingered hand
		
		string $aDefaultSpreadValuesTable[] = {"thumb","index","middle","ring","pinky"};
		float $spreadScalar;
		
		int $fingerInd = abRTGetPosInStrArray($baseName, $aDefaultSpreadValuesTable);
		if ($fingerInd != -1) $spreadScalar = -1*(float($fingerInd)/2 - 1);
		else $spreadScalar = 1;
		
		setAttr ($spreadMultDiv+".input2X") $spreadScalar; // connect spreadVal here
		
	}
	
	
	// plsMns
	connectAttr ($handCtrl+"."+$fingerSpread) ($spreadPlsMns+".input1D[0]");
	connectAttr ($spreadMultDiv+".outputX") ($spreadPlsMns+".input1D[1]");
	
	if ((!$rtReverseCurl && $baseName == "thumb") || ($rtReverseCurl && $baseName == "thumb" && $prefix == "l")){
		connectAttr ($spreadPlsMns+".output1D") ($aFinger[0]+"."+$spreadAxis);
	}else{
		
		$rvSpreadPlsMns = abRTCreateNode("plusMinusAverage", ($fingerSpread+"Rev"), $prefix, $limbName);
		
		setAttr ($rvSpreadPlsMns+".input1D[0]") 0;
		setAttr ($rvSpreadPlsMns+".operation") 2;
		
		connectAttr ($spreadPlsMns+".output1D") ($rvSpreadPlsMns+".input1D[1]");
		connectAttr ($rvSpreadPlsMns+".output1D") ($aFinger[0]+"."+$spreadAxis);
	}
	
	// roll
	
	if (!attributeExists($fingerRoll, $handCtrl)) addAttr -ln $fingerRoll -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
	
	if (!$rtReverseCurl || ($rtReverseCurl && $prefix == "l")){
		connectAttr ($handCtrl+"."+$fingerRoll) ($aFinger[0]+"."+$rollAxis);
	}else{
		$rvRollPlsMns = abRTCreateNode("plusMinusAverage", ($fingerRoll+"Rev"), $prefix, $limbName);
		setAttr ($rvRollPlsMns+".input1D[0]") 0;
		setAttr ($rvRollPlsMns+".operation") 2;
		
		connectAttr ($handCtrl+"."+$fingerRoll) ($rvRollPlsMns+".input1D[1]");
		connectAttr ($rvRollPlsMns+".output1D") ($aFinger[0]+"."+$rollAxis);
	}
	
	
	// add ik
	if ($makeIk){
		if (!attributeExists($fingerIk, $handCtrl)) addAttr -ln $fingerIk -at double  -min 0 -max 1 -dv 0 -keyable true $handCtrl;
		abRTMakeFingerIK($aFinger[0], $aFinger[1], $aFinger[2], $baseName, ($handCtrl+"."+$fingerIk), $handGrp, $limbName);
	}
	
}


global proc int abRTRigHand(string $handCtrl, string $thumbJnt, string $indexJnt, string $middleJnt, string $ringJnt, string $pinkyJnt, string $pinkyCup, string $ringCup){
	// rigs a hand -- returns 1 on success, -1 on failure
	
	int $ret = -1;
	
	if ($handCtrl == "" || $thumbJnt == "" || $indexJnt == "") return $ret;
	
	abRTSetScale($indexJnt);
	
	int $i;
	string $aThumb[], $aIndex[], $aMiddle[], $aRing[], $aPinky[], $handGrp;
	string $prefix = abRTGetObjSide($handCtrl);
	string $limbName = ($prefix == "l") ? "leftHand" : "rightHand";
	int $makeIk = `checkBox -q -v abRTCreateIkFingerChkBx`;
	int $rtReverseCurl = int(abRTGetGlobal("reverseFingerCurl"));
	
	// create hand rig group (if necessary) -- ik is responsible for the only hand related transforms
	$handGrp = (abRTRigNamer("hand", $prefix, "rigGrp", true)); // hand group -- all hand rig transforms created from here out will be placed in this group
	if (!`objExists ((abRTRigRootFolder())+"|"+$handGrp)`){
		$handGrp = `group -em -name $handGrp`;
		$handGrp = abRTParent($handGrp, abRTRigRootFolder());
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($handGrp);
	
	string $aAllHandJnts[]; // used to save all hand Jnts to charVars
	
	if ($thumbJnt != "") $aThumb = abRTGetHierarchy($thumbJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aThumb);
	if ($indexJnt != "") $aIndex = abRTGetHierarchy($indexJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aIndex);
	if ($middleJnt != "") $aMiddle = abRTGetHierarchy($middleJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aMiddle);
	if ($ringJnt != "") $aRing = abRTGetHierarchy($ringJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aRing);
	if ($pinkyJnt != "") $aPinky = abRTGetHierarchy($pinkyJnt, "", true); $aAllHandJnts = stringArrayCatenate($aAllHandJnts, $aPinky);
	
	// finish and clean up $aAllHandJnts
	$aAllHandJnts = stringArrayCatenate($aAllHandJnts, {$pinkyCup, $ringCup});
	$aAllHandJnts = stringArrayRemove({""}, $aAllHandJnts);
	
	// save to charVars
	abRTSaveRigGrpToCharVars($handGrp, $limbName);
	abRTSaveToCharVars($aAllHandJnts, $limbName);
	
	// want to capture newly added $handCtrl atts, so first must capture list of current custom $handCtrl atts
	string $aOrigAtts[] = `listAttr -userDefined $handCtrl`;
	string $aOtherNewAtts[]; // used to capture new spread atts on spine control curve
	string $tAtt;
	string $longPrefix = ($prefix == "l") ? "left" : "right";
	string $cupRotStr = "r"+(abRTGetGlobal("fingerCupAxis")); // rx, ry, or rz (from fingerCupAxis global)
	
	if ($pinkyCup != ""){
		
		string $ringCupMltDiv;
		
		if (!attributeExists("masterCup", $handCtrl)) addAttr -ln "masterCup" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		
		if (!$rtReverseCurl || $rtReverseCurl && $prefix == "l"){
			connectAttr ($handCtrl+".masterCup") ($pinkyCup+"."+$cupRotStr);
		}else{
			$ringCupMltDiv = abRTCreateNode("multiplyDivide", "pinkyRingCup", $prefix, $limbName);
			
			setAttr ($ringCupMltDiv+".input1Y") -1;
			connectAttr ($handCtrl+".masterCup") ($ringCupMltDiv+".input2Y");
			connectAttr ($ringCupMltDiv+".outputY") ($pinkyCup+"."+$cupRotStr);
			
		}
		
		if ($ringCup != ""){
			
			if ($ringCupMltDiv == "") $ringCupMltDiv = abRTCreateNode("multiplyDivide", "pinkyRingCup", $prefix, $limbName);
			
			if (!$rtReverseCurl || $rtReverseCurl && $prefix == "l") setAttr ($ringCupMltDiv+".input1X") .5;
			else setAttr ($ringCupMltDiv+".input1X") -.5;
			
			connectAttr ($handCtrl+".masterCup") ($ringCupMltDiv+".input2X");
			connectAttr ($ringCupMltDiv+".outputX") ($ringCup+"."+$cupRotStr);
			
		}
	}
	
	// add master fist att
	if (!attributeExists("masterFist", $handCtrl)) addAttr -ln "masterFist" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
	if (!attributeExists("masterSpread", $handCtrl)) addAttr -ln "masterSpread" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
	
	// add thumb dampener att (modifies masterFist effect on thumb)
	if (!attributeExists("thumbFistDamp", $handCtrl)) addAttr -ln "thumbFistDamp" -at double  -min -100 -max 100 -dv .3 -keyable true $handCtrl;
	
	// add finger curl atts (instead of master fist)
	if (!attributeExists("midCurlAmt", $handCtrl)) addAttr -ln "midCurlAmt" -at double  -min -100 -max 100 -dv 1 -keyable true $handCtrl;
	if (!attributeExists("tipCurlAmt", $handCtrl)) addAttr -ln "tipCurlAmt" -at double  -min -100 -max 100 -dv 1.4 -keyable true $handCtrl;
	
	string $thumbCurlAtt, $indexCurlAtt, $middleCurlAtt, $ringCurlAtt, $pinkyCurlAtt;
	string $mstrFistAtt = ($handCtrl+".masterFist");
	string $mstrSpreadAtt = ($handCtrl+".masterSpread");
	string $thumbCurlDampAtt = ($handCtrl+".thumbFistDamp");
	string $midCurlAmtAtt = ($handCtrl+".midCurlAmt");
	string $tipCurlAmtAtt = ($handCtrl+".tipCurlAmt");
	
	
	if (!attributeExists("________CURL___", $handCtrl)) addAttr -ln "________CURL___" -at bool -keyable false $handCtrl;
	setAttr -lock true -cb true ($handCtrl+".________CURL___");
	
	// set up finger curl
	if (size($aThumb) > 0){
		if (!attributeExists("thumbCurl", $handCtrl)) addAttr -ln "thumbCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$thumbCurlAtt = ($handCtrl+".thumbCurl");
	}
	if (size($aIndex) > 0){
		if (!attributeExists("indexCurl", $handCtrl)) addAttr -ln "indexCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$indexCurlAtt = ($handCtrl+".indexCurl");
	}
	if (size($aMiddle) > 0){
		if (!attributeExists("middleCurl", $handCtrl)) addAttr -ln "middleCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$middleCurlAtt = ($handCtrl+".middleCurl");
	}
	if (size($aRing) > 0){
		if (!attributeExists("ringCurl", $handCtrl)) addAttr -ln "ringCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$ringCurlAtt = ($handCtrl+".ringCurl");
	}
	if (size($aPinky) > 0){
		if (!attributeExists("pinkyCurl", $handCtrl)) addAttr -ln "pinkyCurl" -at double  -min -100 -max 100 -dv 0 -keyable true $handCtrl;
		$pinkyCurlAtt = ($handCtrl+".pinkyCurl");
	}
	
	
	// add masterSpread individual finger amounts to spineSplitCtrl
	
	float $aSpreadAmts[] = {1.0, .5, 0.0, -.5, -1.0}; // array to hold spread amounts by finger index (starting with the thumb)
	string $spineSplitCtrl = abRTGetFromUI("spineSplitCtrl");
	string $aSpreadAmtAtts[];  // contains attributes ("transform.att") for fingers spread amounts (starting with the thumb)
	
	if ($spineSplitCtrl != ""){
		
		int $totNumFingers = 0;
		
		// count fingers
		if ($thumbJnt != "") $totNumFingers ++;
		if ($indexJnt != "") $totNumFingers ++;
		if ($middleJnt != "") $totNumFingers ++;
		if ($ringJnt != "") $totNumFingers ++;
		if ($pinkyJnt != "") $totNumFingers ++;
		
		float $spreadDelta = 2/float($totNumFingers-1);
		float $cSpread = 1;
		
		// add attributes
		string $attLabel = ($prefix == "l") ? "________LF_SPREAD___" : "________RT_SPREAD___";
		if (!attributeExists($attLabel, $spineSplitCtrl)){
			addAttr -ln $attLabel -at bool -dv 0 -keyable true $spineSplitCtrl;
			setAttr  -lock true ($spineSplitCtrl+"."+$attLabel);
			
			// record atts to charVars
			$aOtherNewAtts[size($aOtherNewAtts)] = ($spineSplitCtrl+"."+$attLabel);
		}
		
		if ($thumbJnt != ""){
			$aSpreadAmts[0] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"ThumbAmt";
			if (!attributeExists($tAtt, $spineSplitCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[0] -keyable true $spineSplitCtrl;
			$aSpreadAmtAtts[0] = ($spineSplitCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[0];
		}
		if ($indexJnt != ""){
			$aSpreadAmts[1] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"IndexAmt";
			if (!attributeExists($tAtt, $spineSplitCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[1] -keyable true $spineSplitCtrl;
			$aSpreadAmtAtts[1] = ($spineSplitCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[1];
		}
		if ($middleJnt != ""){
			$aSpreadAmts[2] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"MiddleAmt";
			if (!attributeExists($tAtt, $spineSplitCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[2] -keyable true $spineSplitCtrl;
			$aSpreadAmtAtts[2] = ($spineSplitCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[2];
		}
		if ($ringJnt != ""){
			$aSpreadAmts[3] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"RingAmt";
			if (!attributeExists($tAtt, $spineSplitCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[3] -keyable true $spineSplitCtrl;
			$aSpreadAmtAtts[3] = ($spineSplitCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[3];
		}
		if ($pinkyJnt != ""){
			$aSpreadAmts[4] = $cSpread;
			$cSpread-=$spreadDelta;
			$tAtt = $longPrefix+"PinkyAmt";
			if (!attributeExists($tAtt, $spineSplitCtrl)) addAttr -ln $tAtt -at double  -min -100 -max 100 -dv $aSpreadAmts[4] -keyable true $spineSplitCtrl;
			$aSpreadAmtAtts[4] = ($spineSplitCtrl+"."+$tAtt);
			$aOtherNewAtts[size($aOtherNewAtts)] = $aSpreadAmtAtts[4];
		}
		
	}
	
	string $thumbCSRAxes =  abRTGetGlobal("thumbCurlSpreadRoll");
	string $fingerCSRAxes =  abRTGetGlobal("fingerCurlSpreadRoll");
	
	// rig fingers
	if (size($aThumb) > 0){
		abRTFingerRigHelper($aThumb, "________THUMB___", "thumb", $handCtrl, $thumbCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[0], $thumbCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, $thumbCurlDampAtt, $makeIk, $prefix, $handGrp, $limbName);
	}
	if (size($aIndex) > 0){
		abRTFingerRigHelper($aIndex, "________INDEX___", "index", $handCtrl, $fingerCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[1], $indexCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, "", $makeIk, $prefix, $handGrp, $limbName);
	}
	if (size($aMiddle) > 0){
		abRTFingerRigHelper($aMiddle, "________MIDDLE___", "middle", $handCtrl, $fingerCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[2], $middleCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, "", $makeIk, $prefix, $handGrp, $limbName);
	}
	if (size($aRing) > 0){
		abRTFingerRigHelper($aRing, "________RING___", "ring", $handCtrl, $fingerCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[3], $ringCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, "", $makeIk, $prefix, $handGrp, $limbName);
	}
	if (size($aPinky) > 0){
		abRTFingerRigHelper($aPinky, "________PINKY___", "pinky", $handCtrl, $fingerCSRAxes, $mstrFistAtt, $mstrSpreadAtt, $aSpreadAmtAtts[4], $pinkyCurlAtt, $midCurlAmtAtt, $tipCurlAmtAtt, "", $makeIk, $prefix, $handGrp, $limbName);
	}
	
	select -clear;
	
	// compare orig with current handCtrl atts to get an array of newly added atts
	string $aNewAtts[] = `listAttr -userDefined $handCtrl`;
	$aNewAtts = stringArrayRemove($aOrigAtts, $aNewAtts);
	
	// add handCtrl to atts ("handCtrl.att")
	for ($i=0;$i<size($aNewAtts);$i++) $aNewAtts[$i] = $handCtrl+"."+$aNewAtts[$i];
	
	// add new other atts to new atts
	$aNewAtts = stringArrayCatenate($aNewAtts, $aOtherNewAtts);
	
	// save new atts to charVars
	abRTSaveToCharVars($aNewAtts, $limbName);
	
	$ret = 1;
	return $ret;
}


global proc int abRTRigLeg(string $upLegJnt, string $heelLoc){
	// rigs a leg -- returns 1 on success, -1 on failure
	
	int $ret = -1;
	
	if ($upLegJnt == "" || $heelLoc == "") return $ret;
	
	int $i;
	
	abRTSetScale($upLegJnt);
	
	int $upLegSplitNum = int(abRTGetFromUI("UpLegSplit"));
	int $kneeSplitNum = 0;
	
	// get joints
	string $aAllLegJnts[] = abRTGetHierarchy($upLegJnt, "", true);
	
	string $aLegJnts[], $aUpLegSplitJnts[], $aKneeSplitJnts[];
	for ($i=0;$i<size($aAllLegJnts);$i++){
		if ($i > 0){
			if ($i <= $upLegSplitNum){
				$aUpLegSplitJnts[size($aUpLegSplitJnts)] = $aAllLegJnts[$i];
				continue;
			}else if ($i > ($upLegSplitNum + 1) && $i < ($upLegSplitNum + $kneeSplitNum + 2)){
				$aKneeSplitJnts[size($aKneeSplitJnts)] = $aAllLegJnts[$i];
				continue;
			}
		}
		
		$aLegJnts[size($aLegJnts)] = $aAllLegJnts[$i];
	}
	
	if (size($aLegJnts) != 5){
		warning "Incorrect number of joints in the hierarchy.  Make sure you've entered the correct number of split joints in the UI.";
		return $ret;
	}
	
	int $colorIndex;
	float $xForm[], $xForm2[], $float, $float2;
	string $aStr[], $globalKey, $name, $aNames[], $str, $jnt;
	string $aCtrlCurves[]; // all ctrl curves put in this array will be colored according to the side of the body
	string $aIkCtrls[]; // objects in this array will have visibility switched according to ikFk switch on footCtrl
	string $aFkCtrls[]; // objects in this array will have visibility switched according to ikFk switch on footCtrl
	string $aLegJntKeyNames[] = {"upLeg","knee","ankle","ball","toe"};
	
	string $kneeJnt = $aLegJnts[1];
	string $ankleJnt = $aLegJnts[2];
	string $ballJnt = $aLegJnts[3];
	string $toeJnt = $aLegJnts[4];
	
	string $hipJnt = firstParentOf($upLegJnt);
	string $prefix = abRTGetObjSide($upLegJnt);
	string $limbName = ($prefix == "l") ? "leftLeg" : "rightLeg";
	
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	int $mirroredBehavior = abRTJointMirroredBehavior($kneeJnt);
	
	// create leg rig group
	string $legGrp = (abRTRigNamer("leg", $prefix, "rigGrp", true)); // leg group -- all leg rig transforms created from here out will be placed in this group
	if (!`objExists ((abRTRigRootFolder())+"|"+$legGrp)`){
		$legGrp = `group -em -name $legGrp`;
		$legGrp = abRTParent($legGrp, abRTRigRootFolder());
	}else{
		warning "This part of the character has already been rigged.  You must remove the current rig before you can continue.";
		return $ret;
	}
	
	abRTConnectToMasterScale($legGrp);
	
	// save legGrp to charVars
	abRTSaveRigGrpToCharVars($legGrp, $limbName);
	abRTSaveToCharVars($aAllLegJnts, $limbName);
	
	string $revFootGrp = `group -em -name (abRTRigNamer("reverseFoot", $prefix, "rigGrp", true))`;
	$revFootGrp = abRTParent($revFootGrp, $legGrp);
	
	
	// make ref leg
	string $aKeyNames[] = {"upLeg","knee","ankle"};
	clear($aNames);
	for ($globalKey in $aKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "refJnt", false);
	string $aRefJnts[] = abRTDuplicateJointHierarchy({$upLegJnt,$kneeJnt,$ankleJnt}, $aNames, $legGrp);
	
	// make invisible
	for ($jnt in $aRefJnts) setAttr ($jnt+".v") 0;
	// done
	
	
	// make fk leg
	string $fkLegGrp = `group -em -name ((abRTRigNamer("legFK", $prefix, "Grp", true))) -p $legGrp`;
	
	if ($hipJnt != ""){
		select -r $hipJnt $fkLegGrp;
	}else{
		select -r $upLegJnt $fkLegGrp;
	}
	
	abRTPointOrient(1);
	select -clear;
	
	clear($aNames);
	for ($globalKey in $aLegJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "fkJnt", false);
	$aStr = abRTDuplicateJointHierarchy($aLegJnts, $aNames, $fkLegGrp);
	
	if ($hipJnt != "") parentConstraint -mo $hipJnt $fkLegGrp;
	
	
	// add fk controls
	$aStr = abRTAddFkControls({$aStr[0],$aStr[1],$aStr[2],$aStr[3]}, $aLegJntKeyNames, {0}, $hipJnt, "sphere", $legGrp, $limbName);
	
	string $aFkJnts[];
	for ($i=0;$i<size($aStr);$i+=2){
		$aFkJnts[size($aFkJnts)] = $aStr[$i];
		$aFkCtrls[size($aFkCtrls)] = $aStr[$i+1];
	}
	
	// color it
	$colorIndex = int(abRTGetGlobal("fkJntColor"));
	for ($jnt in $aFkJnts) abRTColorObj($jnt, $colorIndex);
	
	// color them
	$aCtrlCurves = stringArrayCatenate($aCtrlCurves,$aFkCtrls);
	
	// fk done
	
	
	// make ik leg
	
	string $ikLegGrp = `group -em -name ((abRTRigNamer("legIK", $prefix, "Grp", true))) -p $legGrp`;
	
	if ($hipJnt != ""){
		select -r $hipJnt $ikLegGrp;
	}else{
		select -r $upLegJnt $ikLegGrp;
	}
	
	abRTPointOrient(1);
	select -clear;
	
	$aKeyNames = {"upLeg","knee","ankle"};
	clear($aNames);
	for ($globalKey in $aKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "ikJnt", false);
	string $aIkJnts[] = abRTDuplicateJointHierarchy({$upLegJnt,$kneeJnt,$ankleJnt}, $aNames, $ikLegGrp);
	
	if ($hipJnt != "") parentConstraint -mo $hipJnt $ikLegGrp;
	
	
	// color it 
	$colorIndex = int(abRTGetGlobal("ikJntColor"));
	for ($jnt in $aIkJnts) abRTColorObj($jnt, $colorIndex);
	
	
	// make heel loc
	string $tLoc = abRTMakeLocator("abRigLegHeelTemp_loc");
	select -r $heelLoc $tLoc;
	abRTPointOrient(1);
	select -clear;
	
	
	// create ik control curve
	
	string $ikCtrlCrv = abRTWireContoller("diamond", 1, {}, 10, false);
	select -r $tLoc $ikCtrlCrv;
	abRTPointOrient(1);
	select -clear;
	
	$ikCtrlCrv = abRTParent($ikCtrlCrv, $legGrp);
	$aStr = abRTRename($ikCtrlCrv, (abRTRigNamer("heel", $prefix, "ikCtrl", false)));
	$ikCtrlCrv = $aStr[1];
	
	// rotate order
	setAttr ($ikCtrlCrv+".rotateOrder") 3; // xzy
	
	abRTMoveWireRelativeToPivot($ikCtrlCrv, 0, .5, -1, false);
	
	float $aAnkleCreateRot[];
	float $rotTol = .0001;
	if (attributeExists("createRot", $ankleJnt)){
		$aAnkleCreateRot = `getAttr ($ankleJnt+".createRot")`;
		
		// add upLeg rotation (if any)
		if (attributeExists("createRot", $upLegJnt)){
			$xForm = `getAttr ($upLegJnt+".createRot")`;
			$aAnkleCreateRot[1] += $xForm[1];
		}
		
		if (abs($aAnkleCreateRot[0]) > $rotTol || abs($aAnkleCreateRot[1]) > $rotTol || abs($aAnkleCreateRot[2]) > $rotTol){
			setAttr ($ikCtrlCrv+".r") $aAnkleCreateRot[0] $aAnkleCreateRot[1] $aAnkleCreateRot[2];
		}
	}
	
	// using freezeGrp instead of freezeTransforms because want to keep ikCtrl local rotations aligned to the ankle if it's not aligned with z axis
	$ikCtrlCrv = abRTGroupFreezeReturnObj($ikCtrlCrv, true);
	
	if ($prefix == "l") abRTSetUITxtFld("lfLegIkCtrl", $ikCtrlCrv);
	else abRTSetUITxtFld("rtLegIkCtrl", $ikCtrlCrv);
	
	// hide undesired attributes
	abRTHideAttr($ikCtrlCrv, {"sx","sy","sz","v"});
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $ikCtrlCrv;
	
	// set up its visibility (later
	$aIkCtrls[size($aIkCtrls)] = $ikCtrlCrv;
	
	
	// expose rotate order on controls
	setAttr -lock false -channelBox true ($ikCtrlCrv+".rotateOrder");
	
	
	// make reverse foot rig
	$aKeyNames = {"heel","toe","ball","ankle"};
	clear($aNames);
	for ($globalKey in $aKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "rvRigJnt", false);
	
	string $aRevFootJnts[] = abRTDuplicateJointHierarchy({$tLoc,$toeJnt,$ballJnt,$ankleJnt}, $aNames, $revFootGrp);
	parentConstraint -mo $ikCtrlCrv $revFootGrp;
	
	delete $tLoc;
	
	for ($jnt in $aRevFootJnts) abRTColorObj($jnt, $colorIndex);
	
	// make toe heel joints
	// first joint is parent to ball toe rig -- keeps the joint orient close to that of the fk rig ball which causes less grief with flipping
	string $aIkHeelToeJntsParent[] = abRTDuplicateJointHierarchy({$ballJnt}, {(abRTRigNamer("ballToePar", $prefix, "ikJnt", false))}, $aRevFootJnts[1]);
	string $aIkHeelToeJnts[]  = abRTDuplicateJointHierarchy({$ballJnt,$toeJnt}, {(abRTRigNamer("ball", $prefix, "ikJnt", false)),(abRTRigNamer("toe", $prefix, "ikJnt", false))}, $aIkHeelToeJntsParent[0]);
	
	for ($jnt in $aIkHeelToeJnts) abRTColorObj($jnt, $colorIndex);
	
	// create leg ikHandle
	string $ikLegHandle = abRTMakeIkHandle($aIkJnts[0], $aIkJnts[2], abRTRigNamer("leg", $prefix, "ikHndl", true), $aRevFootJnts[3], $legGrp);
	
	// add attributes to ik control
	
	// leg twist
	addAttr -ln "legTwist" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	connectAttr ($ikCtrlCrv+".legTwist") ($ikLegHandle+".twist");
	
	addAttr -ln "footRoll" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	addAttr -ln "footBreak" -at double  -min -180 -max 180 -dv 40 -keyable true $ikCtrlCrv;
	addAttr -ln "toeRoll" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	addAttr -ln "toeTwist" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	addAttr -ln "ballTwist" -at double  -min -180 -max 180 -dv 0 -keyable true $ikCtrlCrv;
	
	// connect toe to toeRoll
	connectAttr -f ($ikCtrlCrv+".toeRoll") ($aIkHeelToeJnts[0]+".rz"); // toe roll
	
	// connect toe to toeTwist
	connectAttr -f ($ikCtrlCrv+".toeTwist") ($aRevFootJnts[1]+".ry"); // toe twist
	
	// connect toe to ballTwist
	connectAttr -f ($ikCtrlCrv+".ballTwist") ($aRevFootJnts[2]+".ry"); // ball twist
	connectAttr -f ($ikCtrlCrv+".ballTwist") ($aIkHeelToeJnts[0]+".ry");
	
	// connect heel to footRoll
	string $heelPlsMns = abRTCreateNode("plusMinusAverage", "heel", $prefix, $limbName);
	string $heelClmp = abRTCreateNode("clamp", "heel", $prefix, $limbName);
	
	setAttr ($heelClmp+".minR") -50;
	connectAttr ($ikCtrlCrv+".footRoll") ($heelClmp+".inputR");
	setAttr ($heelPlsMns+".input1D[0]") 0;
	setAttr ($heelPlsMns+".operation") 2;
	connectAttr ($heelClmp+".outputR") ($heelPlsMns+".input1D[1]");
	connectAttr ($heelPlsMns+".output1D") ($aRevFootJnts[0]+".rz");
	
	// connect rev ball jnt to footRoll and footBreak
	string $ballClamp = abRTCreateNode("clamp", "toe", $prefix, $limbName);
	
	connectAttr ($ikCtrlCrv+".footRoll") ($ballClamp+".inputR");
	connectAttr ($ikCtrlCrv+".footBreak") ($ballClamp+".maxR");
	connectAttr ($ballClamp+".outputR") ($aRevFootJnts[2]+".rz");
	
	// connect rev toe jnt to footRoll and footBreak
	string $toePlsMns = abRTCreateNode("plusMinusAverage", "ball", $prefix, $limbName);
	string $toeClamp = abRTCreateNode("clamp", "ball", $prefix, $limbName);
	connectAttr ($ikCtrlCrv+".footRoll") ($toePlsMns+".input1D[0]");
	connectAttr ($ikCtrlCrv+".footBreak") ($toePlsMns+".input1D[1]");
	setAttr ($toePlsMns+".operation") 2;
	connectAttr ($toePlsMns+".output1D") ($toeClamp+".inputR");
	setAttr ($toeClamp+".maxR") 90;
	connectAttr ($toeClamp+".outputR") ($aRevFootJnts[1]+".rx");
	
	// ik done
	
	
	// create foot control curve (attached to bottom of foot)
	string $footCtrlCrv = abRTWireContoller("square", 1, {}, 13, false);
	
	$xForm = `xform -q -ws -t $toeJnt`;
	$xForm2 = `xform -q -ws -t $aRevFootJnts[0]`; // heel joint
	
	//setAttr ($footCtrlCrv+".tx") ($xForm[0]);
	setAttr ($footCtrlCrv+".tx") ($xForm[0] + ($xForm2[0] - $xForm[0])/2);
	setAttr ($footCtrlCrv+".ty") 0;
	setAttr ($footCtrlCrv+".tz") ($xForm2[2] + (($xForm[2] - $xForm2[2])/2)*.8);
	
	// rotate into position if the ankle is rotated out of z
	if (size($aAnkleCreateRot) > 0){
		if (abs($aAnkleCreateRot[1]) > $rotTol) setAttr ($footCtrlCrv+".ry") $aAnkleCreateRot[1];
	}
	
	
	$footCtrlCrv = abRTParent($footCtrlCrv, $legGrp);
	$aStr = abRTRename($footCtrlCrv, (abRTRigNamer("foot", $prefix, "ctrl", true)));
	$footCtrlCrv = $aStr[1];
	
	parentConstraint -mo $ankleJnt $footCtrlCrv;
	
	// hide undesired attributes
	abRTHideAttr($footCtrlCrv, {"tx","ty","tz","rx","ry","rz","sx","sy","sz","v"});
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $footCtrlCrv;
	
	// add attributes
	addAttr -ln "ikFkBlend" -at double -min 0 -max 1 -dv 1 -keyable true $footCtrlCrv;
	
	addAttr -ln "ikVis" -at bool -keyable true $footCtrlCrv;
	setAttr ($footCtrlCrv+".ikVis") 0;
	connectAttr ($footCtrlCrv+".ikVis") ($aRevFootJnts[0]+".v");
	connectAttr ($footCtrlCrv+".ikVis") ($aIkJnts[0]+".v");
	
	addAttr -ln "fkVis" -at bool -keyable true $footCtrlCrv;
	setAttr ($footCtrlCrv+".fkVis") 0;
	connectAttr ($footCtrlCrv+".fkVis") ($aFkJnts[0]+".v");
	
	// foot ctrl done
	
	// create pv control
	$aStr = abRTMakePvControl($aIkJnts, $ikLegHandle, $kneeJnt, 1, "knee", $legGrp);
	string $pvCtrl = $aStr[0];
	string $pvCtrlGrp = $aStr[2];
	$aIkCtrls[size($aIkCtrls)] = $pvCtrlGrp; // add to ik vis nodes
	
	// pv vis controls on ik leg ctrl
	addAttr -ln "pvControl" -at bool -keyable true $ikCtrlCrv;
	setAttr ($ikCtrlCrv+".pvControl") 1;
	
	// $aStr[0] - pv control, $aStr[1] - pv constraint, $aStr[3] - pv line, $aStr[4] - lineJointLoc
	connectAttr -f ($ikCtrlCrv+".pvControl") ($pvCtrl+".v");
	connectAttr ($ikCtrlCrv+".pvControl") ($aStr[1]+"."+(abRTStripPath($pvCtrl))+"W0");
	connectAttr -f ($ikCtrlCrv+".pvControl") ($aStr[3]+".v");
	connectAttr -f ($ikCtrlCrv+".pvControl") ($aStr[4]+".v");
	
	// create blend for pv control (between pv constraint and 0 0 0)
	string $tCon[];
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikLegHandle+".poleVectorX")`;
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikLegHandle+".poleVectorY")`;
	$tCon[size($tCon)] = `connectionInfo -sourceFromDestination ($ikLegHandle+".poleVectorZ")`;
	
	string $pvCtrlBlnd = abRTCreateNode("blendColors", "legPvCtrl", $prefix, $limbName);
	
	connectAttr ($ikCtrlCrv+".pvControl") ($pvCtrlBlnd+".blender");
	
	connectAttr $tCon[0] ($pvCtrlBlnd+".color1R");
	connectAttr $tCon[1] ($pvCtrlBlnd+".color1G");
	connectAttr $tCon[2] ($pvCtrlBlnd+".color1B");
	
	setAttr ($pvCtrlBlnd+".color2") 0 0 0;
	
	connectAttr -f ($pvCtrlBlnd+".outputR") ($ikLegHandle+".poleVectorX");
	connectAttr -f ($pvCtrlBlnd+".outputG") ($ikLegHandle+".poleVectorY");
	connectAttr -f ($pvCtrlBlnd+".outputB") ($ikLegHandle+".poleVectorZ");
	
	// color it (later)
	$aCtrlCurves[size($aCtrlCurves)] = $pvCtrl;
	
	// pv done (except for snap, which will be plugged into knee after orient stuff)
	
	
	// add stretch
	abRTMakeIKStretchy($aLegJnts, $aIkJnts, $aFkJnts, $aRefJnts, $ikCtrlCrv, $footCtrlCrv, $aRevFootJnts[3], $legGrp, $limbName);
	
	
	// tx constrain leg to fk and ik
	string $legTxBlnd = abRTCreateNode("blendColors", "legTrans", $prefix, $limbName);
	
	connectAttr ($footCtrlCrv+".ikFkBlend") ($legTxBlnd+".blender");
	connectAttr ($aIkJnts[1]+".tx") ($legTxBlnd+".color1R");
	connectAttr ($aIkJnts[2]+".tx") ($legTxBlnd+".color1G");
	connectAttr ($aFkJnts[1]+".tx") ($legTxBlnd+".color2R");
	connectAttr ($aFkJnts[2]+".tx") ($legTxBlnd+".color2G");
	
	// connect upLeg and knee jnts tx (including splits) to $legTxBlnd outputs
	float $upSplitRatios[] = abRTSetupSplitJointTx($aUpLegSplitJnts, $aRefJnts[1], $kneeJnt, ($legTxBlnd+".outputR"), "upLeg", $limbName);
	float $kneeSplitRatios[] = abRTSetupSplitJointTx($aKneeSplitJnts, $aRefJnts[2], $ankleJnt, ($legTxBlnd+".outputG"), "knee", $limbName);
	
	// stretch done
	
	
	// orient constrain leg to fk and ik
	// constrain ik
	clear $aNames;
	for ($globalKey in $aLegJntKeyNames) $aNames[size($aNames)] = abRTRigNamer($globalKey, $prefix, "ikFkCons", false);
	string $aIkJntCons[] = abRTMassOrientConstraint({$aIkJnts[0],$aIkJnts[1],$aRevFootJnts[3],$aIkHeelToeJnts[0],$aIkHeelToeJnts[1]}, $aLegJnts, $aNames);
	
	// constrain fk (using same $aNames because these are the same constraints)
	string $aFkJntCons[] = abRTMassOrientConstraint({$aFkJnts[0],$aFkJnts[1],$aFkJnts[2],$aFkJnts[3]}, $aLegJnts, $aNames);
	
	// set orientconstraints interpType to shortest (less flipping)
	for ($str in $aFkJntCons) setAttr ((`match "[A-Za-z0-9_]+" $str`)+".interpType") 2;
	
	// hook up ik/fk switch
	string $ikFkReverse = abRTCreateNode("reverse", "legIkFkSwitch", $prefix, $limbName);
	
	connectAttr -f ($footCtrlCrv+".ikFkBlend") ($ikFkReverse+".inputX");
	
	for ($str in $aIkJntCons) connectAttr -f ($footCtrlCrv+".ikFkBlend") $str;
	for ($str in $aFkJntCons) connectAttr -f ($ikFkReverse+".outputX") $str;
	
	// set up upLegSplit joint rotation
	
	$aStr = {"X","Y","Z"}; // used to iterate through multDivNode inputs
	
	string $attLabel, $ikReader;
	
	if (size($aUpLegSplitJnts) > 0){
		
		// since there are split joints we need to make an ik reader grp for them to get rx from (aIkJnt[0] is unreliable when the rootCtrl is rotated)
		if ($hipJnt != "") $ikReader = abRTCreateIKJntReader($aIkJnts[0], $hipJnt, "leg", $legGrp);
		else $ikReader = $aIkJnts[0];
		
		// now on with it
		string $spineSplitCtrl = abRTGetFromUI("spineSplitCtrl");
		
		string $upLegSplitRotMltDiv, $upLegSplitRotBlnd;
		for ($i=0;$i<size($upSplitRatios);$i++){
			$jnt = $aAllLegJnts[$i];
			$str = $aStr[$i];
			
			if ($i == 0){
				// first need to release x rot from orientConstraint on upLeg ($aIkJntCons[0]) and knee ($aIkJntCons[1])
				orientConstraint -e -skip "x" (`match "[A-Za-z0-9_]+" $aIkJntCons[0]`);
				
				$upLegSplitRotBlnd = abRTCreateNode("blendColors", "upLegSplitRot", $prefix, $limbName);
				
				connectAttr ($footCtrlCrv+".ikFkBlend") ($upLegSplitRotBlnd+".blender");
				connectAttr ($ikReader+".rx") ($upLegSplitRotBlnd+".color1R");
				connectAttr ($aFkCtrls[0]+".rx") ($upLegSplitRotBlnd+".color2R");
				
				if (size($upSplitRatios) == 1){
					connectAttr ($upLegSplitRotBlnd+".outputR") ($jnt+".rx");
					break;
				}else{
					$upLegSplitRotMltDiv = abRTCreateNode("multiplyDivide", "upLegSplitRot", $prefix, $limbName);
				}
			}
			
			setAttr ($upLegSplitRotMltDiv+".input2"+$str) $upSplitRatios[$i];
			connectAttr ($upLegSplitRotBlnd+".outputR") ($upLegSplitRotMltDiv+".input1"+$str);
			connectAttr ($upLegSplitRotMltDiv+".output"+$str) ($jnt+".rx");
			
		}
		
		// write to spineSplit ctrl if it exists
		if ($spineSplitCtrl != "" && `objExists $spineSplitCtrl`){
			
			$attLabel = ($prefix == "l") ? "________LF_UPLEG___" : "________RT_UPLEG___";
			abRTAddSplitAttsToSpineCurve($spineSplitCtrl, $upSplitRatios, $upLegSplitRotMltDiv, $attLabel, "Upleg", $prefix, $limbName);
		}
		
	}
	
	// attach visibility
	string $ikVisCond = abRTCreateNode("condition", "legIkVis", $prefix, $limbName);
	string $fkVisCond = abRTCreateNode("condition", "legFkVis", $prefix, $limbName);
	
	connectAttr -f ($footCtrlCrv+".ikFkBlend") ($ikVisCond+".firstTerm"); 
	setAttr ($ikVisCond+".operation") 2;
	setAttr ($ikVisCond+".colorIfTrueR") 1;
	setAttr ($ikVisCond+".colorIfFalseR") 0;
	
	connectAttr -f ($footCtrlCrv+".ikFkBlend") ($fkVisCond+".firstTerm"); 
	setAttr ($fkVisCond+".operation") 4;
	setAttr ($fkVisCond+".secondTerm") 1;
	setAttr ($fkVisCond+".colorIfTrueR") 1;
	setAttr ($fkVisCond+".colorIfFalseR") 0;
	
	for ($str in $aIkCtrls) connectAttr -f ($ikVisCond+".outColorR") ($str+".v"); 
	for ($str in $aFkCtrls) connectAttr -f ($fkVisCond+".outColorR") ($str+".v"); 
	
	// color the curves in $aCtrlCurves
	$str = ($prefix == "l") ? "lfCtrlColor" : "rtCtrlColor"; // get global colorIndex for this side of the body
	int $colorIndex = int(abRTGetGlobal($str));
	for ($str in $aCtrlCurves) abRTColorObj($str, $colorIndex);
	
	// set IK and FK upLeg jnts rotateOrder to YZX (1) -- helps split joint rotation above the knee
	setAttr ($aIkJnts[0]+".ro") 1;
	setAttr ($aFkJnts[0]+".ro") 1;
	
	// add pv snap
	addAttr -ln "snapKnee" -at double -min 0 -max 1 -dv 0 -keyable true $pvCtrl;
	
	// make distanceDim -- upLeg to pvCtrl
	$aStr = abRTMakeDistanceDim({abRTRigNamer("upLegPvCtrl",$prefix,"dist",true),abRTRigNamer("upLegPvCtrl",$prefix,"dist_sp",true),abRTRigNamer("upLegPvCtrl",$prefix,"dist_ep",true)}, $aIkJnts[0], $pvCtrl, $legGrp);
	
	string $upLegPvDistShape = $aStr[3];
	pointConstraint $aIkJnts[0] $aStr[1];
	pointConstraint $pvCtrl $aStr[2];
	
	// make distanceDim -- pvCtrl to ikCtrl
	$aStr = abRTMakeDistanceDim({abRTRigNamer("legPvIkCtrl",$prefix,"dist",true),abRTRigNamer("legPvIkCtrl",$prefix,"dist_sp",true),abRTRigNamer("legPvIkCtrl",$prefix,"dist_ep",true)}, $pvCtrl, $aRevFootJnts[3], $legGrp);
	
	string $pvIkCtrlDistShape = $aStr[3];
	pointConstraint $pvCtrl $aStr[1];
	pointConstraint $aRevFootJnts[3] $aStr[2];
	
	// divide distance values by the masterScale on the rootCtrl
	string $upLegPvDistAtt, $pvIkCtrlDistAtt;
	
	if ($rootCtrl == ""){
		$upLegPvDistAtt = $upLegPvDistShape+".distance";
		$pvIkCtrlDistAtt = $pvIkCtrlDistShape+".distance";
	}else{
		// create multDiv node to divide values by masterScale
		string $pvDistMltDiv = abRTCreateNode("multiplyDivide", "LegPvDistScaleAdjust", $prefix, $limbName);
		setAttr ($pvDistMltDiv+".operation") 2;
		connectAttr ($upLegPvDistShape+".distance") ($pvDistMltDiv+".input1X");
		connectAttr ($pvIkCtrlDistShape+".distance") ($pvDistMltDiv+".input1Y");
		connectAttr ($rootCtrl+".masterScale") ($pvDistMltDiv+".input2X");
		connectAttr ($rootCtrl+".masterScale") ($pvDistMltDiv+".input2Y");
		
		$upLegPvDistAtt = ($pvDistMltDiv+".outputX");
		$pvIkCtrlDistAtt = ($pvDistMltDiv+".outputY");
		
	}
	
	if ($mirroredBehavior && $prefix == "r"){
		// if skeleton was created with mirror behavior, tx will be negative for the -X limb joints, need to negate it to get PV snap to move the joints the correct way
		
		string $pvNegateTxMltDiv = abRTCreateNode("multiplyDivide", "armPvNegate", $prefix, $limbName);
		setAttr ($pvNegateTxMltDiv+".input2") -1 -1 0;
		connectAttr $upLegPvDistAtt ($pvNegateTxMltDiv+".input1X");
		connectAttr $pvIkCtrlDistAtt ($pvNegateTxMltDiv+".input1Y");
		
		$upLegPvDistAtt = ($pvNegateTxMltDiv+".outputX");
		$pvIkCtrlDistAtt = ($pvNegateTxMltDiv+".outputY");
	}
	
	abRTSpliceConnection(($aIkJnts[1]+".tx"), $upLegPvDistAtt, ($pvCtrl+".snapKnee"), false, "upLegSnap", $prefix, $limbName);
	abRTSpliceConnection(($aIkJnts[2]+".tx"), $pvIkCtrlDistAtt, ($pvCtrl+".snapKnee"), false, "kneeSnap", $prefix, $limbName);
	
	// pv snap done
	
	// add spaces to foot and pvctrl
	string $txtFldPrefix = ($prefix == "l") ? "lf" : "rt";
	
	$pvCtrl = abRTParentConstrainToSpace($pvCtrl, $pvCtrl, {"rootCtrl","hipCtrl",($txtFldPrefix+"LegIkCtrl")}, "legPvCtrlGrp","rootCtrl");
	
	//$ikCtrlCrv = abRTParentConstrainToSpace($ikCtrlCrv, $ikCtrlCrv, {"rootCtrl","cogCtrl"}, "legIkCtrl","rootCtrl");
	string $ikCtrlGrp = abRTParentConstrainToSpace(firstParentOf($ikCtrlCrv), $ikCtrlCrv, {"rootCtrl","cogCtrl"}, "legIkCtrl","rootCtrl");
	$ikCtrlCrv = $ikCtrlGrp+"|"+abRTStripPath($ikCtrlCrv);
	
	
	// make ankle and ball rotation reader jnts (so we can match fk leg to ik leg, because the ankle and ball on my ik rig are funky)
	// first dup knee, ankle and ball
	
	$aNames = {abRTRigNamer("ankleBallReader_UpLeg",$prefix,"jnt",true), abRTRigNamer("ankleBallReader_Knee",$prefix,"jnt",true), abRTRigNamer("ankleBallReader_Ankle",$prefix,"jnt",true), abRTRigNamer("ankleBallReader_Ball",$prefix,"jnt",true)};
	string $aAnkleReaderJnts[] = abRTDuplicateJointHierarchy({$upLegJnt,$kneeJnt,$ankleJnt,$ballJnt}, $aNames, $legGrp);
	
	select -r $upLegJnt $aAnkleReaderJnts[0];
	abRTPointOrient(0);
	select -clear;
	
	orientConstraint -name (abRTRigNamer("ankleReader_knee",$prefix,"orCons",true)) $kneeJnt $aAnkleReaderJnts[1];
	orientConstraint -name (abRTRigNamer("ankleReader_ankle",$prefix,"orCons",true)) $aRevFootJnts[3] $aAnkleReaderJnts[2];
	orientConstraint -name (abRTRigNamer("ankleReader_ball",$prefix,"orCons",true)) $aIkHeelToeJnts[0] $aAnkleReaderJnts[3];
	
	// hide it
	setAttr ($aAnkleReaderJnts[0]+".v") 0;
	
	// create/add fk/ik snap button to shelf
	abRTMakeFkToIkSnapShelfBn(abRTGetGlobal("name"), $limbName, $aFkCtrls, $aFkJnts, $ikCtrlCrv, $footCtrlCrv, $pvCtrl, {$aIkJnts[0],$aIkJnts[1],$aAnkleReaderJnts[2],$aAnkleReaderJnts[3]}, $aLegJnts);
	
	select -clear;
	
	$ret = 1;
	return $ret;
}


global proc string abRTCreateIKJntReader(string $ikJnt, string $upJnt, string $baseName, string $grp){
	/*
	creates a reader for split joints to read ik chain upJnt rotation
	$ikJnt is the joint to read, $upJnt is the upJoint of the corresponding joint (ikJnt) in the skeleton, $baseName is "leg" or "arm", and $grp is the group in which to place the readers.
	*/
	
	string $reader, $frzGrp, $aStr[];
	string $prefix = abRTGetObjSide($ikJnt);
	
	if (`objExists $grp`) $reader = `group -em -parent $grp`;
	else $reader = `group -em -w`;
	
	// rename reader
	$aStr = abRTRename($reader, abRTRigNamer(($baseName+"Reader"), $prefix, "grp", true));
	$reader = $aStr[1];
	
	// snap it to the joint
	select -r $ikJnt $reader;
	abRTPointOrient(1);
	select -clear;
	
	// freeze reader
	$reader = abRTGroupFreezeReturnObj($reader, 1);
	
	// parent constrain frzGrp to upJnt
	$frzGrp = firstParentOf($reader);
	parentConstraint -mo $upJnt $frzGrp;
	
	// orient constrain reader to ikJnt
	orientConstraint -mo $ikJnt $reader;
	
	// set rotate order on reader to that of $upJnt
	int $rotateOrder = `getAttr ($upJnt+".rotateOrder")`;
	setAttr ($reader+".rotateOrder") $rotateOrder;
	
	// return reader
	return $reader;
	
}


global proc float[] abRTSetupSplitJointTx(string $aPassedSplitJnts[], string $postRefJnt, string $postSplitJnt, string $postJntTxBlndAtt, string $baseName, string $limbName){
	/*
	$postRefJnt is the joint after the last split joint on the ref leg -- for uplegSplits it would be the knee ref jnt
	$postSplitJnt is the same joint on the skeleton -- for upLegSplits the actual knee joint
	$postJntTxBlndAtt is the output on the tx blend for $postSplitJnt (between ik and fk) -- whereever $postSplitJnt is getting its .tx -- for upLegSplits its "legTxBlnd.outputR"
	$limbName is for recording created nodes in charVars
	returns $splitRatios
	*/
	
	int $i;
	string $jnt, $str, $aStr[];
	float $float, $float2;
	float $aSplitRatios[];
	string $aSplitJnts[] = $aPassedSplitJnts;
	
	if (size($aSplitJnts) == 0){
		$aSplitRatios[0] = 1;
		connectAttr $postJntTxBlndAtt ($postSplitJnt+".tx");
	}else{
		
		string $prefix = abRTGetObjSide($postRefJnt);
		$aSplitJnts[size($aSplitJnts)] = $postSplitJnt;
		$float2 = `getAttr ($postRefJnt+".tx")`;
		for ($jnt in $aSplitJnts){
			$float = `getAttr ($jnt+".tx")`;
			$aSplitRatios[size($aSplitRatios)] = $float/$float2;
		}
		
		
		string $splitTxMltDiv;
		$aStr = {"X","Y","Z"}; // used to iterate through multDivNode inputs
		
		for ($i=0;$i<size($aSplitJnts);$i++){
			$jnt = $aSplitJnts[$i];
			$str = $aStr[$i];
			
			if ($i == 0){
				$splitTxMltDiv = abRTCreateNode("multiplyDivide", ($baseName+"SplitTx"), $prefix, $limbName);
			}
			setAttr ($splitTxMltDiv+".input1"+$str) $aSplitRatios[$i];
			connectAttr $postJntTxBlndAtt ($splitTxMltDiv+".input2"+$str);
			connectAttr ($splitTxMltDiv+".output"+$str) ($jnt+".tx");
		}
	}
	
	return $aSplitRatios;
}


global proc string abRTGetRootFromJoint(string $jnt){
	// returns the root of a skeleton based on the selection of a child joint or "" if unsuccessful
	
	string $aRel[], $parent, $ret;
	float $float;
	
	$aRel = `listRelatives -p -fullPath -type joint $jnt`;
	
	// if $jnt has no joint parents then it's our rootJnt -- return it
	if (size($aRel) == 0) return $jnt;
	
	// keep moving up hierarchy until there are no more joints
	int $counter = 0;
	while (size($aRel) == 1 && `nodeType $aRel[0]` == "joint"){
		
		$float = `getAttr ($aRel[0]+".tx")`;
		if (abs($float) < .00000000000001){
			$ret = $aRel[0];
			break;
		}
		
		$parent = $aRel[0];
		$aRel = `listRelatives -p -fullPath -type joint $parent`;
		
		$counter ++;
		if ($counter > 80) break;
	}
	
	return $ret;
	
}


global proc string abRTSpliceConnection(string $destConAtt, string $newConAtt, string $blenderAtt, int $flip, string $baseName, string $prefix, string $limbName){
	/*
	destConAtt is destination connection -- the attribute that you want to splice in on ("knee.tx")
	$newConAtt is the attribute that you want to plug into $destConAtt along with its existing connection
	this proc will create a colorBlend and use $blenderAtt -- when blenderAtt is true, $newConnAtt will be output into $destConAtt, if $blenderAtt is false, the existing connection will be plugged in
	$baseName and $prefix are for naming the new nodes  (baseName "elbow", prefix "l")
	$limbName is limbName attribute to record newly created nodes to in charVars
	if $flip is true, when blenderAtt is false, $newConnAtt will be output into $destConAtt
	returns new blend node
	*/
	
	string $ret;
	string $existConAtt = `connectionInfo -sourceFromDestination $destConAtt`;
	
	if ($existConAtt != ""){
		
		disconnectAttr $existConAtt $destConAtt;
		string $blend = abRTCreateNode("blendColors", ($baseName+"Splice"), $prefix, $limbName);
		
		if ($flip){
			string $tConnAtt = $newConAtt;
			$newConAtt = $existConAtt;
			$existConAtt = $tConnAtt;
		}
		
		connectAttr $blenderAtt ($blend+".blender");
		connectAttr $newConAtt ($blend+".color1R");
		connectAttr $existConAtt ($blend+".color2R");
		connectAttr ($blend+".outputR") $destConAtt;
		
		$ret = $blend;
	}
	
	return $ret;
	
}


global proc string abRTParentConstrainToSpace(string $obj, string $objToAddAttrTo, string $aSpaces[], string $baseName, string $defaultEnabled){
	/*
	will parent constrain $obj to a given space (a null parented appropriately)
	spaces contained in $aSpaces, are key words that correspond to UI name conventions -- have to be able to retrieve object from abRTGetFromUI using the string
	space strings can be "world" or global loc name of a ui field (retrievable from abRTGetFromUI) like "upLeg", or "rootCtrl", etc
	$baseName is used in naming of constraint
	$defaultEnabled is the space name in $aSpaces that should be enabled by default
	creates attribute on $objToAddAttrTo for each space in $aSpaces -- had to do this because obj might be a freeze grp, yet want atts on frozen object
	
	returns $obj new path (placed in group which is constrained to spaces)
	*/
	
	string $prefix = abRTGetObjSide($obj);
	string $rigRootFolder = abRTRigRootFolder();
	string $ret, $parent, $parentPath, $parConsWeightAttr, $nullParent, $aStr[], $parentCons, $weightAtt, $space, $aNameParPath[], $objGrp;
	int $i;
	
	for ($i=0;$i<size($aSpaces);$i++){
		
		$space = $aSpaces[$i];
		
		if ($space == "world" || abRTGetFromUI($space) != ""){
			
			$parent = abRTRigNamer($space, "", "spcSwtchGrp", true);
			$parentPath = $rigRootFolder+"|"+$parent;
			
			if (!`objExists $parentPath`){
				string $grp = `group -em -n $parent`;
				$parentPath = abRTParent($grp, $rigRootFolder);
				
				if ($space != "world"){
					
					$nullParent = abRTGetFromUI($space);
					if ($nullParent != ""){
						
						// constrain null to the appropriate joint
						select -r $nullParent $parentPath;
						abRTPointOrient(1);
						select -clear;
						
						parentConstraint -mo -n (abRTRigNamer(($space+"Space"),"", "parCons", true)) $nullParent $parentPath;
						
					}
					
					// connect space switch grp to masterScale (except for world)
					abRTConnectToMasterScale($parentPath);
				}
			}
			
			$aNameParPath[size($aNameParPath)] = $space;
			$aNameParPath[size($aNameParPath)] = $parentPath;
		}
	}
	
	$objGrp = `group -em -n (abRTRigNamer($baseName, $prefix, "space_grp", true))`;
	
	string $ctrlGrp = firstParentOf($obj);
	if ($ctrlGrp != "") $objGrp = abRTParent($objGrp, $ctrlGrp);
	
	if (size($aNameParPath) > 0){
		
		int $aLock[], $val;
		string $aTrans[] = {"tx","ty","tz","rx","ry","rz","sx","sy","sz"};
		
		string $conName = abRTRigNamer($baseName, $prefix, ($space+"SpcParCon"), true);
		
		addAttr -ln "________SPACES___" -at bool -keyable false $objToAddAttrTo;
		setAttr -lock true -cb true ($objToAddAttrTo+".________SPACES___");
		
		
		for ($i=0;$i<size($aNameParPath);$i+=2){
			
			$space = $aNameParPath[$i];
			$parentPath = $aNameParPath[$i+1];
			
			// create constraints
			if ($i == 0) $aStr = `parentConstraint -mo -weight 1 -n $conName $parentPath $objGrp`;
			else  $aStr = `parentConstraint -mo -weight 0 $parentPath $objGrp`;
			$parentCons = $aStr[0];
			$aStr = `parentConstraint -q -wal $parentCons`;
			$weightAtt = $aStr[size($aStr)-1];
			$parConsWeightAttr = $parentCons+"."+$weightAtt;
			
			$val = ($defaultEnabled == $space);
			addAttr -ln $space -at double -min 0 -max 1 -dv $val -keyable true $objToAddAttrTo;
			connectAttr -f ($objToAddAttrTo+"."+$space) $parConsWeightAttr;
			
		}
		
		// place obj in $objGrp
		$obj = abRTParent($obj, $objGrp);
		$ret = $obj;
	}
	
	return $ret;
	
}


global proc abRTMakeFingerIK(string $baseJnt, string $midJnt, string $tipJnt, string $baseName, string $ikAtt, string $grp, string $limbName){
	/*
	adds ik to a finger
	baseJnt, midJnt, and tipJnt are the finger joints
	baseName is finger name used for naming new nodes and ctrls
	ikAtt is the attribute (prebuilt) to use for the ik/fk switching -- in the form of "lf_handCtrlCrv.midIK"
	grp is the rig group in which to place the control curve
	limbName is name of attribute to record nodes on charVars node
	*/
	
	string $aStr[], $aConn[];
	string $prefix = abRTGetObjSide($baseJnt);
	
	// we'll disconnect any incoming connections for the tip finger, so save those now to be reconnected later
	$aConn[size($aConn)] = `connectionInfo -sourceFromDestination ($tipJnt+".rx")`;
	$aConn[size($aConn)] = `connectionInfo -sourceFromDestination ($tipJnt+".ry")`;
	$aConn[size($aConn)] = `connectionInfo -sourceFromDestination ($tipJnt+".rz")`;
	
	int $i;
	string $aRotAtt[] = {"rx","ry","rz"};
	
	for ($i=0;$i<size($aConn);$i++){
		if ($aConn[$i] == "") continue;
		
		// disconnect the incoming att and, if the node in $aConn[$i] is a unitConversion node, delete it and find its source.  Otherwise the unitConversion node will have the wrong conversion value.
		
		disconnectAttr $aConn[$i] ($tipJnt+"."+$aRotAtt[$i]);
		
		if (`nodeType $aConn[$i]` == "unitConversion"){
			$aStr = stringToStringArray($aConn[$i], ".");
			if (size($aStr) > 1){
				$aConn[$i] = `connectionInfo -sourceFromDestination ($aStr[0]+".input")`;
				delete $aStr[0];
			}
		}
	}
	
	
	// make and position ctrl curve
	string $ikCtrl = abRTWireContoller("circle", 0, {}, 5, false);
	
	$aStr = abRTRename($ikCtrl, abRTRigNamer($baseName, $prefix, "ikCtrl", true));
	$ikCtrl = $aStr[1];
	
	select -r $tipJnt $ikCtrl;
	abRTPointOrient(1);
	select -clear;
	
	if (`objExists $grp`) $ikCtrl = abRTParent($ikCtrl, $grp);
	
	$ikCtrl = abRTGroupFreezeReturnObj($ikCtrl, 1);
	string $ikCtrlGrp = firstParentOf($ikCtrl);
	
	// make handle
	string $ikHandle = abRTMakeIkHandle($baseJnt, $tipJnt, abRTRigNamer($baseName, $prefix, "ikHandle", true), $ikCtrl, $grp);
	
	// orient constrain tip to ikCtrl
	$aStr = `orientConstraint -n (abRTRigNamer(($baseName+"IkCtrl"), $prefix, "orCons", true)) $ikCtrl $tipJnt`;
	string $orCons = $aStr[0];
	$aStr = `orientConstraint -q -wal $orCons`;
	string $orConsWeight = $aStr[0];
	
	
	// connect it to the ik attribute
	string $condition = abRTCreateNode("condition", ($baseName+"IkCtrl"), $prefix, $limbName);
	
	connectAttr $ikAtt ($condition+".firstTerm");
	connectAttr ($condition+".outColorR") ($ikCtrl+".v");
	
	connectAttr $ikAtt ($orCons+"."+$orConsWeight);
	connectAttr $ikAtt ($ikHandle+".ikBlend");
	
	// add twist
	addAttr -ln "twist" -at double  -min -360 -max 360 -dv 0 -keyable true $ikCtrl;
	connectAttr ($ikCtrl+".twist") ($ikHandle+".twist");
	
	// add attribute to change rotate order
	setAttr -lock false -channelBox true ($ikCtrl+".rotateOrder");
	
	// add spaces 
	string $txtFldPrefix = ($prefix == "l") ? "lf" : "rt";
	
	$ikCtrlGrp = abRTParentConstrainToSpace($ikCtrlGrp, $ikCtrl, {"rootCtrl",($txtFldPrefix+"HandCtrl"),"lowSpineCtrl","hiSpineCtrl","headCtrl"}, ($baseName+"Ctrl"),($txtFldPrefix+"HandCtrl"));
	if ($ikCtrlGrp != "") $ikCtrl = $ikCtrlGrp+"|"+abRTStripPath($ikCtrl);
	
	// hide atts
	abRTHideAttr($ikCtrl, {"sx","sy","sz","v"});
	
	// reconnect incoming connections to tipJnt
	string $newConn;
	
	if ($aConn[0] != ""){
		if ($newConn != $aConn[0]) abRTSpliceConnection(($tipJnt+".rx"), $aConn[0], $ikAtt, true, ($baseName+"Tip"), $prefix, $limbName);
	}
	if ($aConn[1] != ""){
		if ($newConn != $aConn[1]) abRTSpliceConnection(($tipJnt+".ry"), $aConn[1], $ikAtt, true, ($baseName+"Tip"), $prefix, $limbName);
	}
	if ($aConn[2] != ""){
		if ($newConn != $aConn[2]) abRTSpliceConnection(($tipJnt+".rz"), $aConn[2], $ikAtt, true, ($baseName+"Tip"), $prefix, $limbName);
	}
	
}


global proc abRTMakeStretchySplineWin(){
	
	if (`window -exists abRTStrSpnWin`){
		deleteUI -window abRTStrSpnWin;
	}
	window -t "abMakeStretchySpline" -w 202 -h 161 -minimizeButton false -maximizeButton false abRTStrSpnWin;
	
	int $lmargin = 3;
	int $rmargin = 3;
	
	formLayout -numberOfDivisions 100 abRTStrSpnForm;
	
	nameField abRTStrSpnCrvNmFld;
	nameField -manage false abRTStrSpnCrvShapeNmFld;
	
	button -label "Select Curve" -c "abRTStretchySplineSelCurve()" abRTStrSpnSelCrvBn;
	
	text -label "Number of Joints:" abRTStrSpnJointNumTxt;
	intSliderGrp -min 4 -max 60 -v 10 -field true -columnWidth2 30 100 -adjustableColumn2 2 abRTStrSpnJntNumIntSldrGrp;
	
	text -label "Naming Prefix:" abRTStrSpnPrefixTxt;
	textField -text "spline" abRTStrSpnPrefixTxtFld;
	
	separator abRTStrSpnSep1;
	separator abRTStrSpnSep2;
	button -l "Create Stretchy Spline" -en false -h 28 -c "abRTMakeStretchySpline();" abRTStrSpnBldBn;
	
	formLayout -e
	
	-af abRTStrSpnCrvNmFld "top" 6
	-af abRTStrSpnCrvNmFld "left" $lmargin
	-af abRTStrSpnCrvNmFld "right" 80
	
	-af abRTStrSpnSelCrvBn "top" 6
	-ac abRTStrSpnSelCrvBn "left" $lmargin abRTStrSpnCrvNmFld
	-af abRTStrSpnSelCrvBn "right" $rmargin
	
	-ac abRTStrSpnSep1 "top" 4 abRTStrSpnCrvNmFld
	-af abRTStrSpnSep1 "left" $lmargin
	-af abRTStrSpnSep1 "right" $rmargin
	
	-ac abRTStrSpnJointNumTxt "top" 7 abRTStrSpnSep1
	-af abRTStrSpnJointNumTxt "left" $lmargin
	
	-ac abRTStrSpnJntNumIntSldrGrp "top" 5 abRTStrSpnSep1
	-ac abRTStrSpnJntNumIntSldrGrp "left" $lmargin abRTStrSpnJointNumTxt
	-af abRTStrSpnJntNumIntSldrGrp "right" $rmargin
	
	-ac abRTStrSpnPrefixTxt "top" 6 abRTStrSpnJntNumIntSldrGrp
	-af abRTStrSpnPrefixTxt "left" $lmargin
	
	-ac abRTStrSpnPrefixTxtFld "top" 4 abRTStrSpnJntNumIntSldrGrp
	-ac abRTStrSpnPrefixTxtFld "left" $lmargin abRTStrSpnPrefixTxt
	-af abRTStrSpnPrefixTxtFld "right" $rmargin
	
	-ac abRTStrSpnSep2 "top" 5 abRTStrSpnPrefixTxtFld
	-af abRTStrSpnSep2 "left" $lmargin
	-af abRTStrSpnSep2 "right" $rmargin
	
	-ac abRTStrSpnBldBn "top" 6 abRTStrSpnSep2
	-af abRTStrSpnBldBn "left" $lmargin
	-af abRTStrSpnBldBn "right" $rmargin
	
	abRTStrSpnForm;
	
	showWindow abRTStrSpnWin;
	
}


global proc abRTStretchySplineSelCurve(){
	// services select curve button in makeStretchySplineUI
	
	string $aSel[] = `ls -sl`;
	string $aRel[], $curve, $curveShape;
	int $ok = false;
	
	if (size($aSel) == 1){
		$aRel = `listRelatives -shapes $aSel[0]`;
		if (size($aRel) >= 1){
			$ok = true;
			$curve = $aSel[0];
			$curveShape = $aRel[0];
		}
	}
	
	nameField -e -object $curve abRTStrSpnCrvNmFld;
	nameField -e -manage false -object $curveShape abRTStrSpnCrvShapeNmFld;
	button -e -en $ok abRTStrSpnBldBn;
	
	if (!$ok) warning "Select a single curve and try again";
	
}


global proc abRTMakeStretchySpline(){
	// creates a stretchy spline with joints from the selected curve and adds fk controls.
	
	if (!`window -exists abRTStrSpnWin`) return;
	
	int $i, $k, $int, $int2;
	int $jointNum = `intSliderGrp -q -v abRTStrSpnJntNumIntSldrGrp`;
	string $aStr[], $obj;
	string $curve = `nameField -q -object abRTStrSpnCrvNmFld`;
	string $curveShape = `nameField -q -object abRTStrSpnCrvShapeNmFld`;
	string $prefix = `textField -q -text abRTStrSpnPrefixTxtFld`;
	
	if (objExists($prefix+"Rig_grp") || objExists($prefix+"_ikHndl")){
		warning "A spline with the same prefix already exists in this scene.  Enter a new prefix and try again.";
		return;
	}
	
	if (!`objExists $curve` || !`objExists $curveShape`){
		abRTStretchySplineSelCurve();
		return;
	}
	
	// cache global scale (makeCurve uses it) and set it to 1
	string $cScale = abRTGetGlobal("globalScale");
	abRTSetGlobal("globalScale", 1);
	
	int $deg = `getAttr ($curveShape+".degree")`;
	int $spans = `getAttr ($curveShape+".spans")`;
	int $numCvs = $deg+$spans;
	
	// make array of spine joint names
	string $aNames[], $alphaId;
	
	for ($i=0;$i<$jointNum;$i++){
		
		$alphaId = abRTGetNumToAlphaId($i);
		$aNames[size($aNames)] = $prefix+"_"+$alphaId+"_jnt";
		
	}
	
	// make groups
	string $grp = `group -em -name ($prefix+"Rig_grp")`;
	string $scaleGrp = `group -em -p $grp -name ($prefix+"Scale_Rig_grp")`;
	
	// rebuild curve and make spine joints
	$aStr = `rebuildCurve -ch 1 -rpo 0 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 0 -d 3 -tol 0.01 $curve`;
	string $rebuiltSpineCurve = $aStr[0];
	string $aJnts[] = abRTMakeSpineJntsFromCurve($rebuiltSpineCurve, $aNames, "");
	delete $rebuiltSpineCurve;
	
	// orient joints
	abRTOrientJoints($aJnts, "xyz", "zup");
	
	// need to fix last joint's alignment (otherwise will scale in the wrong direction when masterScaled)
	// create a helper joint by duping next to last joint and moving it beyond the last joint tx
	$aStr = `duplicate -renameChildren $aJnts[size($aJnts)-1]`;
	string $tJoint = $aStr[0];
	float $flt = `getAttr (($aJnts[size($aJnts)-1])+".tx")`;
	setAttr ($tJoint+".tx") ($flt*2.0);
	$tJoint = abRTParent($tJoint, $aJnts[size($aJnts)-1]);
	
	// orient joints (again)
	abRTOrientJoints($aJnts, "xyz", "zup");
	
	// delete helper joint
	delete $tJoint;
	
	
	// create ikSpline
	string $aSpineIkHandle[] = `ikHandle
	-name ($prefix+"_ikHndl")
	-solver "ikSplineSolver"
	-startJoint $aJnts[0]
	-endEffector $aJnts[size($aJnts)-1]
	-createCurve false
	-curve $curveShape
	-simplifyCurve false
	-rootOnCurve true
	-snapHandleFlagToggle on
	-twistType "linear"
	-createRootAxis true
	-rootTwistMode false
	-connectEffector true
	-parentCurve false`
	;
	
	setAttr ($aSpineIkHandle[0]+".v") 0;
	
	// create clusters on curve
	string $aSpineClusters[], $aSpineClusterHandles[];
	for ($i=0;$i<$numCvs;$i++){
		
		select -r ($curveShape+".cv["+$i+"]");
		
		$alphaId = abRTGetNumToAlphaId($i);
		if ($i == 3) $aStr = `cluster -relative -name ($prefix+"_"+$alphaId+"_clstr")`;
		else $aStr = `cluster -name ($prefix+"_"+$alphaId+"_clstr")`;
		
		$aSpineClusters[size($aSpineClusters)] = $aStr[0];
		$aSpineClusterHandles[size($aSpineClusterHandles)] = $aStr[1];
		setAttr ($aSpineClusterHandles[$i]+".v") 0;
		
	}
	
	// need to create jointChain snapped to cvs of $curve so we can properly align the ctrl curves
	
	// position locs at curve cvs
	string $aLocs[], $aRigJntNames[], $aRigJnts[], $aCtrlCrvNames[];
	int $aJntsToAlign[];
	float $aTrans[];
	for ($i=0;$i<$numCvs;$i++){
		
		$aLocs[$i] = abRTMakeLocator($prefix+"TempStretchySpline_"+$i+"_loc");
		$aTrans = `pointPosition -w ($curveShape+".cv["+$i+"]")`;
		
		move -absolute $aTrans[0] $aTrans[1] $aTrans[2] $aLocs[$i];
		
		$alphaId = abRTGetNumToAlphaId($i);
		$aRigJntNames[$i] = $prefix+"Rig_"+$alphaId+"_jnt";
		
		if ($i < ($numCvs-1)){
			$aCtrlCrvNames[$i] = $prefix+"_"+$alphaId+"_ctrl";
			
			$aJntsToAlign[$i] = $i;
		}
	}
	
	// make jointChain from locs
	$aRigJnts = abRTDuplicateJointHierarchy($aLocs, $aRigJntNames, "");
	
	// delete locs
	for ($obj in $aLocs) delete $obj;
	
	// create control curves
	string $aCtrlCrvs[];
	float $startSize = 30;
	float $endSize = 10;
	float $sizeDelta = ($startSize - $endSize)/(size($aSpineClusterHandles));
	
	for ($i=0;$i<(size($aSpineClusterHandles)-1);$i++){
		$alphaId = abRTGetNumToAlphaId($i);
		$aCtrlCrvs[$i] = abRTWireContoller("circle", 0, {}, ($startSize-$sizeDelta*$i), false);
		$aStr = abRTRename($aCtrlCrvs[$i], ($prefix+"_"+$alphaId+"_ctrl"));
		
		$aCtrlCrvs[$i] = $aStr[1];
		
		// position curve
		select -r $aRigJnts[$i] $aCtrlCrvs[$i];
		abRTPointOrient(1);
		select -clear;
		
		// parent to previous curves
		if ($i > 0) $aCtrlCrvs[$i] = abRTParent($aCtrlCrvs[$i], $aCtrlCrvs[$i-1]);
		
		$aCtrlCrvs[$i] = abRTGroupFreezeReturnObj($aCtrlCrvs[$i], true);
		
		// parent clusters to curves
		parentConstraint $aCtrlCrvs[$i] $aSpineClusterHandles[$i];
		if ($i == (size($aSpineClusterHandles)-2)) parentConstraint -mo $aCtrlCrvs[$i] $aSpineClusterHandles[$i+1];
		
		// hide atts
		if ($i>0) abRTHideAttr($aCtrlCrvs[$i], {"sx","sy","sz"});
		
	}
	
	// delete rig joints
	delete $aRigJnts[0];
	
	// add stretch
	
	string $curveInfoNode = abRTCreateNode("curveInfo", $prefix, "", "");
	connectAttr ($curveShape +".worldSpace")  ($curveInfoNode+".inputCurve");
	
	// get jointLength/arcLen ratios
	float $arcLen = `getAttr ($curveInfoNode+".arcLength")`;
	float $aSpineLenRatios[], $float;
	for ($i=0;$i<size($aJnts);$i++){
		$float = `getAttr ($aJnts[$i]+".tx")`;
		$aSpineLenRatios[$i] = $float/$arcLen;
	}
	
	// add stretch switch and attribute
	addAttr -ln "stretchy" -at double -min 0 -max 1 -dv 1 -keyable true $aCtrlCrvs[0];
	
	// create scale and stretch amount atts
	addAttr -ln "masterScale" -at double -dv 1 -min .0001 -keyable true $aCtrlCrvs[0];
	addAttr -ln "stretchAmount" -at double -dv 0 -min 0 -keyable true $aCtrlCrvs[0];
	
	// create scale adjusted arcLen
	string $arcLenMultDiv = abRTCreateNode("multiplyDivide", ($prefix+"ScaleAdjustedArcLen"), "", "");
	setAttr ($arcLenMultDiv+".operation") 2;
	connectAttr -f ($curveInfoNode+".arcLength") ($arcLenMultDiv+".input1X");
	connectAttr -f ($aCtrlCrvs[0]+".masterScale") ($arcLenMultDiv+".input2X");
	string $saArcLenNodeAtt = $arcLenMultDiv+".outputX"; // scale adjusted arcLen node att
	
	string $curveLenBld = abRTCreateNode("blendColors", $prefix, "", "");
	setAttr ($curveLenBld+".color2R") $arcLen;
	connectAttr $saArcLenNodeAtt  ($curveLenBld+".color1R");
	connectAttr ($aCtrlCrvs[0]+".stretchy")  ($curveLenBld+".blender");
	
	// multiply ratios and current curve length
	string $aAxes[] = {"X","Y","Z"};
	string $aSpineArcLenMltDiv[], $tNode;
	for ($i=0;$i<size($aJnts);$i++){
		
		$int = $i % 3;
		$int2 = floor($i/3);
		if ($int == 0){
			$alphaId = abRTGetNumToAlphaId(ceil(($i+1)/3));
			$tNode = abRTCreateNode("multiplyDivide", ($prefix+"ArcLen_"+$alphaId), "", "");
			$aSpineArcLenMltDiv[size($aSpineArcLenMltDiv)] = $tNode;
		}else{
			$tNode = $aSpineArcLenMltDiv[size($aSpineArcLenMltDiv)-1];
		}
		
		setAttr ($tNode+".input1"+$aAxes[$int]) $aSpineLenRatios[$i];
		connectAttr -f ($curveLenBld+".outputR") ($tNode+".input2"+$aAxes[$int]);
		
		connectAttr -f ($tNode+".output"+$aAxes[$int]) ($aJnts[$i]+".tx");
	}
	
	// here's where we determine the stretch amount
	string $stretchAmtMltDiv = abRTCreateNode("multiplyDivide", ($prefix+"StretchAmt"), "", "");
	setAttr ($stretchAmtMltDiv+".operation") 2;
	connectAttr -f $saArcLenNodeAtt ($stretchAmtMltDiv+".input1X");
	setAttr ($stretchAmtMltDiv+".input2X") $arcLen;
	connectAttr -f ($stretchAmtMltDiv+".outputX") ($aCtrlCrvs[0]+".stretchAmount");
	
	// connect masterScale to root ctrlCurve
	connectAttr -f ($aCtrlCrvs[0]+".masterScale") ($aCtrlCrvs[0]+".sx");
	connectAttr -f ($aCtrlCrvs[0]+".masterScale") ($aCtrlCrvs[0]+".sy");
	connectAttr -f ($aCtrlCrvs[0]+".masterScale") ($aCtrlCrvs[0]+".sz");
	
	abRTHideAttr($aCtrlCrvs[0], {"sx","sy","sz"});
	
	// expose values to drive squash and stretch blendshapes
	addAttr -ln "squashFalloff" -at double -min 0 -max 10 -dv 1.6 -keyable true $aCtrlCrvs[0];
	addAttr -ln "squashScalar" -at double -min 0 -max 50 -dv 2.4 -keyable true $aCtrlCrvs[0];
	addAttr -ln "stretchFalloff" -at double -min 0 -max 10 -dv .7 -keyable true $aCtrlCrvs[0];
	addAttr -ln "stretchScalar" -at double -min 0 -max 50 -dv 1.4 -keyable true $aCtrlCrvs[0];
	addAttr -ln "stretchDriver" -at double -min 0 -max 1 -dv 0 -keyable true $aCtrlCrvs[0];
	addAttr -ln "squashDriver" -at double -min 0 -max 1 -dv 0 -keyable true $aCtrlCrvs[0];
	
	string $stretchReaderPlsMns = abRTCreateNode("plusMinusAverage", ($prefix+"StretchReader"), "", "");
	string $squashReaderPlsMns = abRTCreateNode("plusMinusAverage", ($prefix+"SquashReader"), "", "");
	string $sqStrFalloffMltDiv = abRTCreateNode("multiplyDivide", ($prefix+"SqStrFalloff"), "", "");
	string $sqStrScalarMltDiv = abRTCreateNode("multiplyDivide", ($prefix+"SqStrScalar"), "", "");
	string $sqStrClamp = abRTCreateNode("clamp", ($prefix+"SqStr"), "", "");
	string $stretchCond = abRTCreateNode("condition", ($prefix+"Stretch"), "", "");
	string $squashCond = abRTCreateNode("condition", ($prefix+"Squash"), "", "");
	
	// stretch plsMns
	setAttr ($stretchReaderPlsMns+".operation") 2;
	setAttr ($stretchReaderPlsMns+".input1D[1]") 1;
	connectAttr ($aCtrlCrvs[0]+".stretchAmount") ($stretchReaderPlsMns+".input1D[0]");
	
	// squash plsMns
	setAttr ($squashReaderPlsMns+".operation") 2;
	setAttr ($squashReaderPlsMns+".input1D[0]") 1;
	connectAttr ($aCtrlCrvs[0]+".stretchAmount") ($squashReaderPlsMns+".input1D[1]");
	
	// squash stretch falloff
	setAttr ($sqStrFalloffMltDiv+".operation") 3;
	connectAttr ($aCtrlCrvs[0]+".stretchFalloff") ($sqStrFalloffMltDiv+".input2X");
	connectAttr ($aCtrlCrvs[0]+".squashFalloff") ($sqStrFalloffMltDiv+".input2Y");
	connectAttr ($stretchReaderPlsMns+".output1D") ($sqStrFalloffMltDiv+".input1X");
	connectAttr ($squashReaderPlsMns+".output1D") ($sqStrFalloffMltDiv+".input1Y");
	
	// squash stretch scalar
	connectAttr ($aCtrlCrvs[0]+".stretchScalar") ($sqStrScalarMltDiv+".input2X");
	connectAttr ($aCtrlCrvs[0]+".squashScalar") ($sqStrScalarMltDiv+".input2Y");
	connectAttr ($sqStrFalloffMltDiv+".outputX") ($sqStrScalarMltDiv+".input1X");
	connectAttr ($sqStrFalloffMltDiv+".outputY") ($sqStrScalarMltDiv+".input1Y");
	
	// clamp
	setAttr ($sqStrClamp+".min") 0 0 0;
	setAttr ($sqStrClamp+".max") 1 1 1;
	connectAttr ($sqStrScalarMltDiv+".outputX") ($sqStrClamp+".inputR");
	connectAttr ($sqStrScalarMltDiv+".outputY") ($sqStrClamp+".inputG");
	
	// stretch condition
	setAttr ($stretchCond+".operation") 3;
	setAttr ($stretchCond+".secondTerm") 1;
	setAttr ($stretchCond+".colorIfFalseR") 0;
	connectAttr ($aCtrlCrvs[0]+".stretchAmount") ($stretchCond+".firstTerm");
	connectAttr ($sqStrClamp+".outputR") ($stretchCond+".colorIfTrueR");
	
	// squash condition
	setAttr ($squashCond+".operation") 4;
	setAttr ($squashCond+".secondTerm") 1;
	setAttr ($squashCond+".colorIfFalseR") 0;
	connectAttr ($aCtrlCrvs[0]+".stretchAmount") ($squashCond+".firstTerm");
	connectAttr ($sqStrClamp+".outputG") ($squashCond+".colorIfTrueR");
	
	// connect to atts
	connectAttr ($stretchCond+".outColorR") ($aCtrlCrvs[0]+".stretchDriver");
	connectAttr ($squashCond+".outColorR") ($aCtrlCrvs[0]+".squashDriver");
	
	// connect roll and twist
	connectAttr ($aCtrlCrvs[0]+".rx") ($aSpineIkHandle[0]+".roll");
	string $twistReaderPlsMns = abRTCreateNode("plusMinusAverage", ($prefix+"TwistReader"), "", "");
	
	for ($i=1;$i<size($aCtrlCrvs);$i++) connectAttr -f ($aCtrlCrvs[$i]+".rx") ($twistReaderPlsMns+".input1D["+($i-1)+"]");
	
	connectAttr -f ($twistReaderPlsMns+".output1D") ($aSpineIkHandle[0]+".twist");
	
	// connect masterScale to scaleGrp scale
	connectAttr -f ($aCtrlCrvs[0]+".masterScale") ($scaleGrp+".sx"); 
	connectAttr -f ($aCtrlCrvs[0]+".masterScale") ($scaleGrp+".sy"); 
	connectAttr -f ($aCtrlCrvs[0]+".masterScale") ($scaleGrp+".sz"); 
	
	// throw it all in a group
	abRTParent($aJnts[0], $scaleGrp);
	abRTParent($aSpineIkHandle[0], $grp);
	abRTParent(firstParentOf($aCtrlCrvs[0]), $grp);
	for ($obj in $aSpineClusterHandles) abRTParent($obj, $grp);
	
	// reset global scale
	abRTSetGlobal("globalScale", $cScale);
	
	// scroll past warning and deselect everything
	print "\n\n";
	select -clear;
}


global proc string abRTGetNumToAlphaId(int $num){
	// returns a letter index based on a given number (a, b, c, ... aa, bb, cc, etc)
	
	string $alpha = "abcdefghijklmnopqrstuvwxyz";
	string $alphaId, $cAlpha;
	int $ind, $int, $i;
	
	// get alpha id
	$ind = $num%26;
	$int = floor(float($num)/26)+1;
	$cAlpha = substring($alpha, ($ind+1), ($ind+1));
	$alphaId = "";
	for ($i=0;$i<$int;$i++) $alphaId = $alphaId + $cAlpha;
	// done
	
	return $alphaId;
	
}


global proc abRTMakeIKStretchy(string $aJnts[], string $aIkJnts[], string $aFkJnts[], string $aRefJnts[], string $ikCtrl, string $statCtrl, string $stretchTarget, string $grp, string $limbName){
	/* 
	$aIkJnts {firstJnt, secondJnt, thirdJnt}, $aIkJnts {firstRefJnt, secondRefJnt, thirdRefJnt}
	$ikCtrl is the ikCtrl that will have stretchy+$name attribute added to it
	$statCtrl is the static control that will have $name+stretch attribute added to it
	$stretchTarget is what the chain should be stretching to -- should be in same position as last joint in chain -- reverse ankle jnt or wrist control
	$limbName is used to name nodes and add nodes to correct attribute of charVars.
	*/
	
	string $name;
	
	$name = $limbName;
	if (startsWith($limbName, "left")) $name = tolower(`substitute "left" $limbName ""`);
	else if (startsWith($limbName, "right")) $name = tolower(`substitute "right" $limbName ""`);
	
	string $prefix = abRTGetObjSide($aIkJnts[0]);
	int $mirroredBehavior = abRTJointMirroredBehavior($aJnts[1]);
	
	// create up stretch and low stretch attribute names (for leg you can break stretch into kneeStretch and ankleStretch)
	string $upStretchAmtAtt, $lowStretchAmtAtt;
	if ($name == "leg"){
		$upStretchAmtAtt = "kneeStretch";
		$lowStretchAmtAtt = "ankleStretch";
	}else if ($name == "arm"){
		$upStretchAmtAtt = "elbowStretch";
		$lowStretchAmtAtt = "wristStretch";
	}else{
		$upStretchAmtAtt = "upStretch";
		$lowStretchAmtAtt = "lowStretch";
	}
	
	string $refStrMultDiv = abRTCreateNode("multiplyDivide", ($name+"RefStr"), $prefix, $limbName);
	string $strAttPlsMns = abRTCreateNode("plusMinusAverage", ($name+"TotStrAmt"), $prefix, $limbName);
	string $lowJntStrPlsMns = abRTCreateNode("plusMinusAverage", ($name+"LowStr"), $prefix, $limbName);
	string $upJntStrPlsMns = abRTCreateNode("plusMinusAverage", ($name+"UpStr"), $prefix, $limbName);
	string $strDenomPlsMns = abRTCreateNode("plusMinusAverage", ($name+"StrDenom"), $prefix, $limbName);
	string $strNumMultDiv = abRTCreateNode("multiplyDivide", ($name+"StrNum"), $prefix, $limbName);
	string $strScalarMultDiv = abRTCreateNode("multiplyDivide", ($name+"StrScalar"), $prefix, $limbName);
	string $strClmp = abRTCreateNode("clamp", ($name+"Str"), $prefix, $limbName);
	string $strMultDiv = abRTCreateNode("multiplyDivide", ($name+"Str"), $prefix, $limbName);
	
	setAttr ($strScalarMultDiv+".operation") 2; // divide
	setAttr ($strClmp+".minR") 1;
	
	// make distance node
	string $aDist[] = abRTMakeDistanceDim({(abRTRigNamer(($name+"StrDist"),$prefix,"dist",true)),(abRTRigNamer(($name+"StrDist"),$prefix,"dist_sp",true)),(abRTRigNamer(($name+"StrDist"),$prefix,"dist_ep",true))}, $aIkJnts[0], $aIkJnts[2], $grp);
	string $distShape = $aDist[3];
	abRTParent($aDist[1], $grp);
	abRTParent($aDist[2], $grp);
	pointConstraint $aIkJnts[0] $aDist[1];
	pointConstraint $stretchTarget $aDist[2];
	
	// adjust distance to current scale
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	string $distanceNodeAtt;
	if ($rootCtrl == ""){
		$distanceNodeAtt = $distShape+".distance";
	}else{
		string $scaleDistMltDiv = abRTCreateNode("multiplyDivide", ($name+"DistScaleAdjust"), $prefix, $limbName);
		setAttr ($scaleDistMltDiv+".operation") 2;
		connectAttr ($distShape+".distance") ($scaleDistMltDiv+".input1X");
		connectAttr ($rootCtrl+".masterScale") ($scaleDistMltDiv+".input2X");
		$distanceNodeAtt = $scaleDistMltDiv+".outputX";
	}
	
	
	// create stretch attributes
	string $stretchyAtt = "stretchy"+capitalizeString($name);
	string $stretchAmtAtt = $name+"Stretch";
	addAttr -ln $stretchyAtt -at double -min 0 -max 1 -dv 0 -keyable true $ikCtrl;
	
	// make the stretch attr a bit less sensitive
	$stretchAttMultDiv  = abRTCreateNode("multiplyDivide", ($name+"StrAtt"), $prefix, $limbName);
	setAttr ($stretchAttMultDiv+".operation") 2; // divide
	setAttr ($stretchAttMultDiv+".input2") 10 10 10;
	addAttr -ln $stretchAmtAtt -at double -min -9.9 -max 20 -dv 0 -keyable true $statCtrl;
	
	addAttr -ln $upStretchAmtAtt -at double -min -9.9 -max 20 -dv 0 -keyable true $statCtrl;
	addAttr -ln $lowStretchAmtAtt -at double -min -9.9 -max 20 -dv 0 -keyable true $statCtrl;
	
	// create max stretch attribute
	addAttr -ln "maxStretch" -at double -min 1 -max 10 -dv 3 -keyable true $ikCtrl;
	connectAttr ($ikCtrl+".maxStretch") ($strClmp+".maxR");
	
	// start connecting
	// stretchAttMultDiv 
	connectAttr ($statCtrl+"."+$stretchAmtAtt) ($stretchAttMultDiv+".input1X");
	connectAttr ($statCtrl+"."+$upStretchAmtAtt) ($stretchAttMultDiv+".input1Y");
	connectAttr ($statCtrl+"."+$lowStretchAmtAtt) ($stretchAttMultDiv+".input1Z");
	
	// strAttPlsMns -- add full limb stretch and individual limb stretches together
	connectAttr ($stretchAttMultDiv+".outputX") ($strAttPlsMns+".input2D[0].input2Dx");
	connectAttr ($stretchAttMultDiv+".outputX") ($strAttPlsMns+".input2D[0].input2Dy");
	connectAttr ($stretchAttMultDiv+".outputY") ($strAttPlsMns+".input2D[1].input2Dx");
	connectAttr ($stretchAttMultDiv+".outputZ") ($strAttPlsMns+".input2D[1].input2Dy");
	
	// refStrMultDiv 
	connectAttr ($strAttPlsMns+".output2D.output2Dx") ($refStrMultDiv+".input1X");
	connectAttr ($strAttPlsMns+".output2D.output2Dy") ($refStrMultDiv+".input1Y");
	connectAttr ($aRefJnts[1]+".tx") ($refStrMultDiv+".input2X"); // knee, elbow
	connectAttr ($aRefJnts[2]+".tx") ($refStrMultDiv+".input2Y"); // ankle, wrist
	connectAttr ($refStrMultDiv+".outputX") ($upJntStrPlsMns+".input1D[0]");
	connectAttr ($refStrMultDiv+".outputY") ($lowJntStrPlsMns+".input1D[0]");
	
	// lowJntStrPlsMns 
	connectAttr ($aRefJnts[2]+".tx") ($lowJntStrPlsMns+".input1D[1]");
	connectAttr ($lowJntStrPlsMns+".output1D") ($aFkJnts[2]+".tx");
	connectAttr ($lowJntStrPlsMns+".output1D") ($strDenomPlsMns+".input1D[0]");
	connectAttr ($lowJntStrPlsMns+".output1D") ($strMultDiv+".input1Y");
	
	// upJntStrPlsMns 
	connectAttr ($aRefJnts[1]+".tx") ($upJntStrPlsMns+".input1D[1]");
	connectAttr ($upJntStrPlsMns+".output1D") ($aFkJnts[1]+".tx");
	connectAttr ($upJntStrPlsMns+".output1D") ($strDenomPlsMns+".input1D[1]");
	connectAttr ($upJntStrPlsMns+".output1D") ($strMultDiv+".input1X");
	
	// strNumMultDiv 
	connectAttr $distanceNodeAtt ($strNumMultDiv+".input1X");
	connectAttr ($ikCtrl+"."+$stretchyAtt) ($strNumMultDiv+".input2X");
	connectAttr ($strNumMultDiv+".outputX") ($strScalarMultDiv+".input1X");
	
	// strDenomPlsMns
	connectAttr ($strDenomPlsMns+".output1D") ($strScalarMultDiv+".input2X");
	
	// strScalarMultDiv
	if ($mirroredBehavior && $prefix == "r"){
		// if behavior has been mirrored on the skeleton and this limb is on the right side, then the tx translations have to be reversed
		
		string $negateTxMltDiv = abRTCreateNode("multiplyDivide", ($name+"NegateTx"), $prefix, $limbName);
		setAttr ($negateTxMltDiv+".input2X") -1;
		connectAttr ($strScalarMultDiv+".outputX") ($negateTxMltDiv+".input1X");
		connectAttr ($negateTxMltDiv+".outputX") ($strClmp+".inputR");
	}else{
		connectAttr ($strScalarMultDiv+".outputX") ($strClmp+".inputR");
	}
	
	// strClmp
	connectAttr ($strClmp+".outputR") ($strMultDiv+".input2X");
	connectAttr ($strClmp+".outputR") ($strMultDiv+".input2Y");
	
	// strMultDiv
	connectAttr ($strMultDiv+".outputX") ($aIkJnts[1]+".tx");
	connectAttr ($strMultDiv+".outputY") ($aIkJnts[2]+".tx");
	
	
	// expose stretch percentage for attaching volume blendshapes or other deformers
	// create and connect stretchValue attribute
	
	addAttr -ln "stretchValue" -at double -keyable false $ikCtrl;
	setAttr -cb true ($ikCtrl+".stretchValue");
	
	connectAttr ($strClmp+".outputR") ($ikCtrl+".stretchValue");
	
}


global proc string[] abRTMakeDistanceDim(string $aNames[], string $spObj, string $epObj, string $grp){
	/*
	Creates a distanceDim node named $aNames[1], with startpoint named $aNames[1], and endpoint named $aName[2]
	startPoint is located at $spPob, endPoint is located at $epObj
	locs and distanceDim are placed in $grp
	returns {distanceDimName, startPointLocName, endPointLocName, distanceDimShapeName} 
	*/
	
	string $aRet[], $aStr[];
	
	string $distanceDimShape = `distanceDimension -sp 12 -24 -40 -ep 13 -20 -40`; // distanceDimension seems not to create a new loc if there's an existing loc at the same point in space -- strange.
	
	// get sp and ep locs
	string $attStr = `connectionInfo -sourceFromDestination ($distanceDimShape+".startPoint")`;
	string $spLocShape = `match "[A-Za-z0-9_]+" $attStr`;
	$attStr = `connectionInfo -sourceFromDestination ($distanceDimShape+".endPoint")`;
	string $epLocShape = `match "[A-Za-z0-9_]+" $attStr`;
	
	$aStr = `listRelatives -p -fullPath -type transform $distanceDimShape`;
	string $distanceDim = $aStr[0];
	$aStr = `listRelatives -p -fullPath -type transform $spLocShape`;
	string $spLoc = $aStr[0];
	$aStr = `listRelatives -p -fullPath -type transform $epLocShape`;
	string $epLoc = $aStr[0];
	
	// snap the locs to the appropriate location
	select -r $spObj $spLoc;
	abRTPointOrient(1);
	select -r $epObj $epLoc;
	abRTPointOrient(1);
	
	if ($aNames[0] != ""){
		$aStr = abRTRename($distanceDim, $aNames[0]);
		$distanceDim = $aStr[1];
	}
	if ($aNames[1] != ""){
		$aStr = abRTRename($spLoc, $aNames[1]);
		$spLoc = $aStr[1];
	}
	if ($aNames[2] != ""){
		$aStr = abRTRename($epLoc, $aNames[2]);
		$epLoc = $aStr[1];
	}
	if ($grp != "" && `objExists $grp`){
		$distanceDim = abRTParent($distanceDim, $grp);
		$spLoc = abRTParent($spLoc, $grp);
		$epLoc = abRTParent($epLoc, $grp);
	}
	
	$aStr = `listRelatives -type shape $distanceDim`;
	$distanceDimShape = $aStr[0];
	
	// make it invisible
	setAttr ($distanceDim+".v") 0;
	setAttr ($spLoc+".v") 0;
	setAttr ($epLoc+".v") 0;
	
	$aRet[size($aRet)] = $distanceDim; 
	$aRet[size($aRet)] = $spLoc;
	$aRet[size($aRet)] = $epLoc;
	$aRet[size($aRet)] = $distanceDimShape;
	
	return $aRet;
}


global proc string[] abRTAddFkControls(string $aJnts[], string $aRootNames[], int $aJntsToAlign[], string $fkChainUpJnt, string $wireType, string $ctrlGrp, string $limbName){
	/*
	adds controls to a joints (in a chain) specified in $aJnts, names them using $aRootNames, and places them in $ctrlGrp 
	$aJntsToAlign is joints (by index in $aJnts) to add the align attribute to
	$fkChainUpJnt is joint to parent $aJnts[0] to
	$wireType is wire to use for controls ("circle", "sphere") -- it must be a valid type	
	$limbName is name of attribute in charVars to record newly created nodes (for rig removal)
	first control in $aJnts will have align attribute
	returns array {joint1, ctrlCurve1, joint2, ctrlCurve2}
	*/
	
	int $i;
	float $ctrlSize, $jntRadius, $aFlt[];
	string $aRet[], $aRel[], $ctrl, $jnt, $parFrzGrp, $ptFrzGrp, $upJnt, $prefix, $ptCons, $parCons, $orCons, $parConsWeightAttr, $orConsWeightAttr, $plsMnsAvg, $aStr[];
	string $str, $alignOffsetGrp, $armAutoAlignBlnd;
	string $rootCtrl = abRTGetFromUI("rootCtrl");
	
	if (size($aJnts) > 0){
		
		$prefix = abRTGetObjSide($aJnts[0]);
		
		for ($i=(size($aJnts)-1);$i>=0;$i--){
			
			// work backwards down the chain
			$jnt = $aJnts[$i];
			
			// create curve
			$jntRadius = `getAttr ($jnt+".radius")`;
			$ctrlSize = 6 * $jntRadius + 5;
			
			$ctrl = abRTWireContoller($wireType, 0, {}, $ctrlSize, false);
			
			// put in ctrlGrp
			if ($ctrlGrp != "" && `objExists $ctrlGrp`) $ctrl = abRTParent($ctrl, $ctrlGrp);
			
			// rename it
			$aStr = abRTRename($ctrl, abRTRigNamer($aRootNames[$i], $prefix, "fkCtrl", true));
			$ctrl = $aStr[1];
			
			// snap to joint
			select -r $jnt $ctrl;
			abRTPointOrient(1);
			select -clear;
			
			$aRel = `listRelatives -p -fullPath -type joint $jnt`;
			$upJnt =  (size($aRel) == 1) ? $aRel[0] : "";
			
			// add attribute to change rotate order
			setAttr -lock false -channelBox true ($ctrl+".rotateOrder");
			
			if ($i == 0 && $fkChainUpJnt != ""){
				
				// fkChainUpJnt is not a direct parent of the first joint of the chain so we have to do something a bit different to make it work
				
				$upJnt = $fkChainUpJnt;
				string $upJntNull = `group -em -w -n (abRTRigNamer(($aRootNames[$i]+"upJntFkCtrl"), $prefix, "grp", true))`;
				
				select -r $jnt $upJntNull;
				abRTPointOrient(1);
				select -clear;
				
				if ($ctrlGrp != "" && `objExists $ctrlGrp`) $upJntNull = abRTParent($upJntNull, $ctrlGrp);
				
				parentConstraint -mo $upJnt $upJntNull;
				
				$ptFrzGrp = abRTGroupFreeze($ctrl, 1);
				$ctrl = $ptFrzGrp+"|"+abRTStripPath($ctrl);
				
				$aStr = `parentConstraint $ctrl $jnt`;
				$parCons = $aStr[0];
				
				$aStr = `pointConstraint $upJntNull $ptFrzGrp`;
				$ptCons = $aStr[0];
				
				$aStr = `orientConstraint $upJntNull $ptFrzGrp`;
				$orCons = $aStr[0];
				
				$aStr = `orientConstraint -q -wal $orCons`;
				$orConsWeightAttr = $orCons+"."+$aStr[0];
				
				// add align attribute
				addAttr -ln "align" -at bool -dv false -keyable true $ctrl;
				
				// create plusMins to reverse align which is plugged into parent constraint
				$plsMnsAvg  = abRTCreateNode("plusMinusAverage", $aRootNames[$i], $prefix, $limbName);
				
				setAttr ($plsMnsAvg+".input1D[0]") 1;
				setAttr ($plsMnsAvg+".operation") 2;
				connectAttr ($ctrl+".align") ($plsMnsAvg+".input1D[1]");
				connectAttr ($plsMnsAvg+".output1D") $orConsWeightAttr;
				
			}else{
				
				$parFrzGrp = abRTGroupFreeze($ctrl, 1);
				$ctrl = $parFrzGrp+"|"+abRTStripPath($ctrl);
				
				$ptFrzGrp = abRTGroupFreeze($ctrl, 1);
				$ctrl = $ptFrzGrp+"|"+abRTStripPath($ctrl);
				
				if ($upJnt != ""){
					
					$aStr = `parentConstraint -mo $upJnt $parFrzGrp`;
					$parCons = $aStr[0];
					
					$aStr = `parentConstraint -q -wal $parCons`;
					$parConsWeightAttr = $parCons+"."+$aStr[0];
					
				}else{
					$parCons = $parConsWeightAttr = "";
					
				}
				
				$aStr = `pointConstraint $jnt $ptFrzGrp`;
				$ptCons = $aStr[0];
				
				if (abRTGetPosInIntArray($i, $aJntsToAlign) != -1 && $upJnt != ""){
					
					// add align attribute
					addAttr -ln "align" -at bool -keyable true $ctrl;
					
					// create plusMins to reverse align which is plugged into parent constraint
					$plsMnsAvg  = abRTCreateNode("plusMinusAverage", $aRootNames[$i], $prefix, $limbName);
					
					setAttr ($plsMnsAvg+".input1D[0]") 1;
					setAttr ($plsMnsAvg+".operation") 2;
					connectAttr ($ctrl+".align") ($plsMnsAvg+".input1D[1]");
					connectAttr ($plsMnsAvg+".output1D") $parConsWeightAttr;
					
				}
				
				// orient joint to ctrl;
				$aStr = `orientConstraint -mo -n (abRTRigNamer($aRootNames[$i]+"Ctrl", $prefix, "fkOrCons", true)) $ctrl $jnt`;
				
			}
			
			// if the ctrl has an align attribute, then set up auto align
			if (attributeExists("align", $ctrl)){
				
				// Auto Align
				if ($rootCtrl != ""){
					
					// if rootCtrl is present, group uparm fkCtrl so it will auto align with root con when align is on
					$alignOffsetGrp = `group -em -name (abRTRigNamer(($aRootNames[$i]+"AlignOffset"), $prefix, "rigGrp", true))`;
					
					// snap group to first fkJnt
					$aStr = `pointConstraint -offset 0 0 0 -weight 1 $jnt $alignOffsetGrp`;
					if (size($aStr) > 0) delete $aStr[0];
					
					// parent alignOffsetGrp (AOG) under fkCtrl parent
					$str = firstParentOf($ctrl);
					$alignOffsetGrp = abRTParent($alignOffsetGrp, $str);
					
					$alignOffsetGrp = abRTGroupFreezeReturnObj($alignOffsetGrp, true);
					
					// put fkCtrl in AOG
					$ctrl = abRTParent($ctrl, $alignOffsetGrp);
					$ctrl = abRTGroupFreezeReturnObj($ctrl, true);
					
					// connect rootCtrl.r to AOG.r with a blender (only want AOG to rotate with root when fkCtrls[0].align is true
					$autoAlignBlnd = abRTCreateNode("blendColors", ($aRootNames[$i]+"AutoAlign"), $prefix, $limbName);
					
					setAttr ($autoAlignBlnd+".color2") 0 0 0;
					connectAttr ($ctrl+".align") ($autoAlignBlnd+".blender");
					connectAttr ($rootCtrl+".r") ($autoAlignBlnd+".color1");
					connectAttr ($autoAlignBlnd+".output") ($alignOffsetGrp+".r");
				}
				// /Auto Align
				
			}
			
			abRTHideAttr($ctrl, {"tx","ty","tz","sx","sy","sz","v"});
			
			$aRet[$i*2] = $jnt;
			$aRet[$i*2+1] = $ctrl;
			
		}
	}
	
	return $aRet;
	
}


global proc string abRTMakeIkHandle(string $startJnt, string $endJnt, string $name, string $parent, string $grp){
	// creates an IK handle 
	
	string $aStr[], $ikHandle;
	
	$aStr = `ikHandle -n $name -solver "ikRPsolver" -startJoint $startJnt -endEffector $endJnt`;
	$ikHandle = $aStr[0];
	
	if ($grp != "") $ikHandle = abRTParent($ikHandle, $grp);
	
	if ($parent != "") parentConstraint -mo $parent $ikHandle;
	
	setAttr ($ikHandle+".v") 0;
	
	return $ikHandle;
}


global proc string abRTMakeLocator(string $name){
	// creates a locator named $name.  returns full path to locator
	
	string $ret;
	string $aStr[] = `spaceLocator`;
	$aStr = abRTRename($aStr[0], $name);
	$ret = $aStr[1];
	return $ret;
	
}


global proc abRTShowAttr(string $obj, string $aAttr[]){
	// unlocks and makes keyable $obj's attributes in $aAttr
	
	string $attr, $objAttr;
	     
	for ($attr in $aAttr){
		$objAttr = $obj+"."+$attr;
		setAttr -keyable true -lock false $objAttr;
		setAttr -channelBox true $objAttr;
	}
	
}


global proc abRTHideAttr(string $obj, string $aAttr[]){
	// hides $obj's attributes in $aAttr
	
	string $attr, $objAttr;
	string $aLock[] = {"tx","ty","tz","rx","ry","rz","sx","sy","sz"}; // these atts are locked if encountered in $aAttr
	
	for ($attr in $aAttr){
		$objAttr = $obj+"."+$attr;
		setAttr -keyable false $objAttr;
		setAttr -channelBox false $objAttr;
		if (abRTGetPosInStrArray($attr, $aLock) != -1) setAttr -lock true $objAttr; // only need to lock t, r, and s
	}
}


global proc string[] abRTMakePvControl(string $aIkJnts[], string $ikHandle, string $bindJnt, int $offsetDir, string $nameRoot, string $ctrlGrp){
	/*
	makes a pv control for joint chain where $aIkJnts[1] is the joint in the middle of the ik chain, $ikHandle is the ikHandle
	$offsetDir is direction to offset ==> +x,+y,+z,-x,-y,-z == 0,1,2,3,4,5
	$bindJnt is the joint connected to the pv control with a line
	$nameRoot is desired rootname of newly created pv -- "elbow", "arm", "knee", whatever -- will be combined with prefix and charname to make a unique name
	$ctrlGrp is group to place pv and pv group in
	returns string[] {pvControlPath, pvConstraintName, pvControlPathGrp, pvLine(annotation)}
	*/
	
	string $aRet[], $aStr[], $placeInGrp, $jnt;
	string $prefix = abRTGetObjSide($aIkJnts[0]);
	float $aTrans[], $aTrans2[], $aJntTrans[];
	int $facingAxis;
	
	if (size($aIkJnts) < 3) return $aRet;
	
	float $aIKUpLegTrans[] = `joint -q -p -a $aIkJnts[0]`;
	float $aIKKneeTrans[] =`joint -q -p -a $aIkJnts[1]`;
	float $pvOffset = sqrt(pow(($aIKUpLegTrans[0] - $aIKKneeTrans[0]), 2) + pow(($aIKUpLegTrans[1] - $aIKKneeTrans[1]), 2) + pow(($aIKUpLegTrans[2] - $aIKKneeTrans[2]), 2));
	
	// get bind joint orientation
	$facingAxis = $offsetDir;
	
	// make pv control
	string $pvCtrl = abRTWireContoller("sphere", $facingAxis, {}, 4, false);
	$aStr = abRTRename($pvCtrl, abRTRigNamer($nameRoot, $prefix, "pvCtrl", true));
	$pvCtrl = $aStr[1];
	
	$pvCtrl = abRTParent($pvCtrl, $ctrlGrp);
	
	// align with startJnt
	select -r $aIkJnts[0] $pvCtrl;
	abRTPointOrient(1);
	select -clear;
		
	float $scale = float(abRTGetGlobal("globalScale"));
	
	// make 1 degree curve snapped to joints to determine pv location
	string $curveCmd = "curve -d 1";
	
	for ($i=0;$i<3;$i++){
		$aJntTrans = `joint -q -p $aIkJnts[$i]`;
		$curveCmd += " -p "+$aJntTrans[0]+" "+$aJntTrans[1]+" "+$aJntTrans[2];
	}
	
	string $curve = eval($curveCmd);
	
	select -r ($curve+".cv[1]");
	moveVertexAlongDirection -n $pvOffset;
	select -clear;
	
	$aTrans = `xform -q -ws -t ($curve+".cv[1]")`;
	xform -ws -t $aTrans[0] $aTrans[1] $aTrans[2] $pvCtrl;
	
	delete $curve;
	
	// freeze pvCtrl transforms
	makeIdentity -apply true -t 1 -r 1 -s 1 $pvCtrl;
	
	string $pvGrp = abRTGroupFreeze($pvCtrl, 1);
	$pvCtrl = $pvGrp+"|"+abRTStripPath($pvCtrl);
	
	$aStr = `poleVectorConstraint -name (abRTRigNamer($nameRoot, $prefix, "pvCons", true)) $pvCtrl $ikHandle`;
	string $pvCons = $aStr[0];
	
	string $bindJntLoc = abRTMakeLocator(abRTRigNamer($nameRoot, $prefix, "lineLoc", true));
	$bindJntLoc = abRTParent($bindJntLoc, $pvGrp);
	pointConstraint $bindJnt $bindJntLoc;
	string $line = abRTConnectWithLine($bindJntLoc, $pvCtrl);
	
	// hide undesired attributes
	abRTHideAttr($pvCtrl, {"rx","ry","rz","sx","sy","sz","v"});
	
	// fill aRet[]
	$aRet[size($aRet)] = $pvCtrl;
	$aRet[size($aRet)] = $pvCons;
	$aRet[size($aRet)] = $pvGrp;
	$aRet[size($aRet)] = $line;
	$aRet[size($aRet)] = $bindJntLoc;
	
	return $aRet;
	
}


global proc string[] abRTGetRigGrpCtrlCurves(string $rigGrp){
	// returns all control curves in $rigGrp 
	
	if (!objExists($rigGrp) || `nodeType $rigGrp` != "transform") return {};
	
	string $aRigGrpContents[] = `listRelatives -ad -path -type transform $rigGrp`;
	string $curvesNameFilter = `itemFilter -byName "*_ctrl"`;
	
	select -r $aRigGrpContents;
	string $aCurves[] = `lsThroughFilter -selection $curvesNameFilter`;
	select -clear;
	
	delete $curvesNameFilter;
	
	return $aCurves;
}


global proc abRTMakeCharSetFromSel(){
	// returns animatable nurbsCurve attributes of all children of selected transform
	
	string $rigGrpSuffix = "_rig_grp";
	string $rigGrp = abRTGetRigGrpFromSelCtrl();
	
	if ($rigGrp != ""){
		
		string $aCSel[] = `ls -sl`;
		
		string $aCurves[] = abRTGetRigGrpCtrlCurves($rigGrp);
		string $aStr[], $curve;
		
		select -r $aCSel;
		
		if (size($aCurves) == 0){
			warning "Unable to find any valid control curves.  You didn't rename anything, did you?";
			return;
		}
		
		string $name = "abAutoRigChar";
		
		if (endsWith($rigGrp, $rigGrpSuffix) && size($rigGrp) > size($rigGrpSuffix)){
			$name = shortNameOf($rigGrp);
			$name = `substitute $rigGrpSuffix $rigGrp ""`;
		}
		
		// strip out spineSplitRot (doesn't need to be keyed)
		for ($curve in $aCurves){
			if (`match "_spineSplitRot_" $curve` == "_spineSplitRot_") continue;
			$aStr[size($aStr)] = $curve;
		}
		$aCurves = $aStr;
		
		$name += "_cs";
		
		$name = `character -n $name $aCurves`;
		
		if ($name != "") print ("Created character set "+$name);
	}
	
}
