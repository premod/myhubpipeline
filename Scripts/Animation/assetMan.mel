proc poseLibInitializeVariables()
{
	// --------------------------
	// Initializing variables.
	// --------------------------
	global string $poseLibVersion;
	$poseLibVersion = "1.1 - Sanraa Media Solutions.";
	global string $poseLibCurrentProject;
	//$poseLibCurrentProject = `internalVar -userWorkspaceDir`;
	$poseLibCurrentProject = `workspace -q -fn`;
	global string $poseLibDefaultPath;
	global string $poseLibCharacterList[];
	//$poseLibCharacterList = { "default" };
	global string $poseLibCategoryList[];
	//$poseLibCategoryList =	{ "default" };
	global int $poseLibIconsSize[];
	$poseLibIconsSize = { 50, 50 };
	global float $poseLibIconsBGColor[];
	$poseLibIconsBGColor = { 1.0, 1.0, 1.0 };
	global float $poseLibCaptureCameraBGColor[];
	$poseLibCaptureCameraBGColor = { .75, .75, .75 };
	global float $poseLibApplyIncrement;
	$poseLibApplyIncrement = 0.75;
	global string $poseLibPathsBookmarks[];
	global string $poseLibTextEditor;
	//$poseLibTextEditor = "C:/Program Files/EditPlus 2/editplus.exe";
	global int $poseLibUseTexturesForIconPreview;
	global string $poseLibIconFormat = "";
	global string $poseLibCancelIsolateCmd;

	// Identify the os.
	if ( `about -os` == "linux" )
		{
		$poseLibIconFormat = ".xpm";
		print "Operating system: Linux\n";
		}
	else if ( `about -macOS` )
		{
		$poseLibIconFormat = ".xpm";
		print "Operating system: MAC OS\n";
		}
	else if ( `about -windows` )
		$poseLibIconFormat = ".bmp";

	// Check if the default path option var exists and set the poseLib default path accordingly.
	if ( `optionVar -exists poseLibDefaultPathStatus` )
		$poseLibDefaultPath = `optionVar -q poseLibDefaultPathStatus`;
	else
		$poseLibDefaultPath = $poseLibCurrentProject + "/AssetManager"; //print ("\n$defaultPath=" + $poseLibDefaultPath );

	if ( `optionVar -exists poseLibTextEditorStatus` )
		$poseLibTextEditor = `optionVar -q poseLibTextEditorStatus`;
	else
		$poseLibTextEditor = "C:/Program Files/Windows NT/Accessories/wordpad.exe"; //print ("\n$defaultPath=" + $poseLibDefaultPath );

	// Recall the icons size preferences.
	if ( `optionVar -exists iconsSizeWidthStatus` )
		$poseLibIconsSize[0] = `optionVar -q iconsSizeWidthStatus`;

	if ( `optionVar -exists iconsSizeHeightStatus` )
		$poseLibIconsSize[1] = `optionVar -q iconsSizeHeightStatus`;

	// Recall the icons BG color preferences.
	if ( `optionVar -exists iconsBackgroundColorStatus` )
		{
		string $tmp = `optionVar -q iconsBackgroundColorStatus`;
		$arrayTmp = `stringToStringArray $tmp " "`;
		$poseLibIconsBGColor[0] = $arrayTmp[0];
		$poseLibIconsBGColor[1] = $arrayTmp[1];
		$poseLibIconsBGColor[2] = $arrayTmp[2];
		}

	if ( `optionVar -exists useTexturesForIconPreviewStatus` )
		$poseLibUseTexturesForIconPreview = `optionVar -q useTexturesForIconPreviewStatus`;
	else
		$poseLibUseTexturesForIconPreview = 1;

	// Recall the capture camera BG color preferences.
	if ( `optionVar -exists captureCameraBackgroundColorStatus` )
		{
		string $tmp = `optionVar -q captureCameraBackgroundColorStatus`;
		$arrayTmp = `stringToStringArray $tmp " "`;
		$poseLibCaptureCameraBGColor[0] = $arrayTmp[0];
		$poseLibCaptureCameraBGColor[1] = $arrayTmp[1];
		$poseLibCaptureCameraBGColor[2] = $arrayTmp[2];
		}
}

// ---------------------------------------------------------------------------
// For Maya 6.0 backward compatibility.
// ---------------------------------------------------------------------------
global proc int stringArrayContains(string $item, string $list[])
{
	int $result = false;

	string $listItem;

	for ($listItem in $list)
		{
		if ($item == $listItem)
			{
			$result = true;
			break;
			}
		}

	return $result;
}

global proc int stringArrayInsertAtIndex( int $index, string $list[], string $item )
{
	int     $i;
	string  $result[];
	int     $len = size( $list );

	// Check for a valid index and simple case of appending to end.
	//
	if ( $index < 0 ) {
		return( false );
	} else if ( $index >= $len ) {
		$list[$len] = $item;
		return( true );
	}

	// Copy any entries prior to $index.
	//
	for ( $i = 0; $i < $index; $i++ ) {
		$result[$i] = $list[$i];
	}

	// Add the new item.
	//
	$result[$i] = $item;

	// Copy any items which come after $index.
	//
	for ( ; $i < $len; $i++ ) {
		$result[$i + 1] = $list[$i];
	}

	// Copy the result to the list argument.
	//
	$list = $result;

	return( true );
}

global proc int stringArrayContains(string $item, string $list[])
{
	int $result = false;

	string $listItem;

	for ($listItem in $list) {
		if ($item == $listItem) {
			$result = true;
			break;
			}
		}

	return $result;
}

// ---------------------------------------------------------------------------

/*global proc poseLibSavePrefs()
{
	global string $poseLibDefaultPath;
	global int $poseLibIconsSize[];
	global float $poseLibIconsBGColor[];
	global float $poseLibCaptureCameraBGColor[];
	global string $poseLibPathsBookmarks[];
	global string $poseLibTextEditor;
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;

	// Store all the option choices in option variables.
	optionVar -stringValue poseLibDefaultPathStatus $poseLibDefaultPath;
	optionVar -stringValue poseLibTextEditorStatus $poseLibTextEditor;
	optionVar -intValue useCurrentCharacterStatus `checkBox -q -v useCurrentCharacterCB`;
	optionVar -intValue useCustomNamespaceStatus `checkBox -q -v useCustomNamespaceCB`;
	optionVar -stringValue namespaceTextFieldStatus `textField -q -tx namespaceTextFieldTF`;
	optionVar -stringValue characterChoiceStatus `optionMenu -q -v characterChoiceOM`;
	optionVar -stringValue categoryChoiceStatus `optionMenu -q -v categoryChoiceOM`;
	optionVar -intValue iconsSizeWidthStatus $poseLibIconsSize[0];
	optionVar -intValue iconsSizeHeightStatus $poseLibIconsSize[1];
	// We save the color as a string, but we change them to float[] when we recall them.
	optionVar -stringValue iconsBackgroundColorStatus ($poseLibIconsBGColor[0] + " " + $poseLibIconsBGColor[1] + " " + $poseLibIconsBGColor[2]);
	optionVar -stringValue captureCameraBackgroundColorStatus ($poseLibCaptureCameraBGColor[0] + " " + $poseLibCaptureCameraBGColor[1] + " " + $poseLibCaptureCameraBGColor[2]);
	string $pathsBookmarksStatusTmp = stringArrayToString($poseLibPathsBookmarks, ",");
	optionVar -stringValue pathsBookmarksStatus $pathsBookmarksStatusTmp; //print ("\nSaved $pathsBookmarksStatusTmp: " + $pathsBookmarksStatusTmp + "\n");

	if ( `objExists "poseLibCaptureCamera"` )
		{
		optionVar -intValue captureCameraFocalLengthStatus `getAttr "poseLibCaptureCameraShape.focalLength"`;
		optionVar -floatValue captureCameraNearClipStatus `getAttr "poseLibCaptureCameraShape.nearClipPlane"`;
		optionVar -floatValue captureCameraFarClipStatus `getAttr "poseLibCaptureCameraShape.farClipPlane"`;
		}

	// what we need to do is to embed the poses index order in the pose files
	// Get the list of poses currently displayed and their index.
	string $posesUINames[] = `shelfLayout -q -ca plPosesSL`;
	string $poseNames[] = {};
	for ($i=0;$i<`size $posesUINames`;$i++)
		{
		$poseNames[$i] = `shelfButton -q -l $posesUINames[$i]`;
		}
	//print ("$poseNames:\n"); print $poseNames; print "\n";

	// Open each pose file.
	for ($i=0;$i<`size $poseNames`;$i++)
		{
		if (`filetest -w ($poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseNames[$i])`)
			{
			//print ("\nAssigning index order " + $i + " to image \"" + $poseNames[$i] + "\"");
			string $allLines[] = {};
			int $fileId = `fopen ($poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseNames[$i]) "r"`;

			// Store the file's content.
			while ( !`feof $fileId` )
				{
				$allLines[`size $allLines`] = `fgetline $fileId`;
				}
			fclose $fileId;
			//print ("image = " + $poseNames[$i] + "\n");

			// Rewrite the file starting with the new index number.
			int $fileId = `fopen ($poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseNames[$i]) "w"`;
			fprint $fileId ("\nposeLibIndexOrder " + $i);

			int $start = 1;
			string $buffer[];
			int $numTokens = `tokenize $allLines[1] " " $buffer`; //print ($buffer[`size $buffer`-1]);
			if ( $buffer[0] == "poseLibIndexOrder" )
				$start = 2;

			for ($j=$start;$j<`size $allLines`;$j++)
				{
				$allLines[$j] = strip($allLines[$j]);
				if ( $allLines[$j] != "" )
					fprint $fileId ("\n" + $allLines[$j]);
				}
			fclose $fileId;
			}
		}

	evalDeferred("poseLibRefreshPoseList(\"\")");
	print "Asset Manager: Saved preferences!\n";
}*/

global proc string poseLibCheckIfIndexExists( int $fileId )
{
	// check if the index order keyword exists
	string $checkForIndex = `fgetword $fileId`;
	string $result = "";
	// if it does, then read one more word (the index itself), so that
	// the next word will be the attribute name
	if ( $checkForIndex == "poseLibIndexOrder" )
		$result = `fgetword $fileId`;
	// if not, then rewind the file and skip the first line (empty)
	else
		{
		frewind $fileId;
		string $controlName = `fgetline $fileId`; // This is because the first line is empty.
		}
	return $result;
}

global proc poseLibChooseTextEditor()
{
	// get the text-editor program
	global string $poseLibTextEditor;
	string $result = `fileDialog -dm "*.exe"`;

	if ( $result != "" )
		{
		text -e -ann $result -l $result poseLibTextEditorOptionText;
		$poseLibTextEditor = $result;
		}
	else
		text -e -ann $poseLibTextEditor -l $poseLibTextEditor poseLibTextEditorOptionText;

	// save the prefs
	//poseLibSavePrefs;
}

global proc poseLibGetNamepaceFromSelection()
{
	// Set the namespace based on the current selection.
	string $selection[] = `ls -sl`;
	string $buffer[];
	int $numTokens = `tokenize $selection[0] ":" $buffer`; //print ($buffer[`size $buffer`-1]);
	string $namespace = $buffer[0];

	textField -e -text $namespace namespaceTextFieldTF;
}

global proc poseLibBrowseForFolder( string $startFolder )
{
	global string $poseLibDefaultPath;

	workspace -dir $startFolder;

	fileBrowserDialog -mode 4
		-fileCommand ( "poseLibBrowseForFolderCallback \"" + $poseLibDefaultPath + "\"" )
		-actionName "Choose New Asset Folder:";
}

global proc poseLibBrowseForFolderCallback( string $poseLibBookmarkDoubleClicked, string $poseLibFolderResult, string $type )
{
	global string $poseLibDefaultPath;
	global string $poseLibPathsBookmarks[];

	string $checkName = `match "[$%\\#@.;?!\"\'\`]" $poseLibFolderResult`;

	if ( `size $checkName` )
		error "AssetMan: The AssetManager path can NOT include any space (\" \") nor either of these: \" $ % \\ # @ . ; ? ! \' \`";

	if ( $poseLibFolderResult != $poseLibDefaultPath )
		{
		string $askToCopyOldPoseLibFolder = `confirmDialog
			-title "New poseLib Folder"
			-message ( "Do you want to copy any existing character(s) and categories to the new directory?\n\n(Note: You will have to manually delete the old poseLib folder. This is a safety mesure!)" ) -ma "center"
			-button "Yes" -button "No, just change the path" -button "Cancel"
			-defaultButton "Yes" -cancelButton "Cancel"
			-dismissString "No"`;

		string $oldPoseLibDefaultPath = $poseLibDefaultPath; //print ("\nChosen OS path = " + $poseLibFolderResult );

		if ( `checkBox -q -v poseLibFolderOptionCB` )
			{
			$poseLibDefaultPath = $poseLibFolderResult ; //print ("\nAdding \"/poseLib\" to OS path = " + $poseLibFolderResult + "/poseLib");
			}
		else
			$poseLibDefaultPath = $poseLibFolderResult;

		if ( $askToCopyOldPoseLibFolder == "Yes" )
			{
			text -e -l $poseLibDefaultPath poseLibFolderOptionText;

			string $tmp = toNativePath( $oldPoseLibDefaultPath );
			string $tmp2 = toNativePath( $poseLibDefaultPath );

			if ( `about -macOS` || `about -linux` )
				system( "cp -R " + $tmp + " " + $tmp2 );
			else
				system( "xcopy " + $tmp + " " + $tmp2 + "/s /e /i" );
			}

		else if ( $askToCopyOldPoseLibFolder == "No, just change the path" )
			text -e -l $poseLibDefaultPath poseLibFolderOptionText;

		// If the user didn't simply double-click on a bookmark, then add the location to the bookmark list.
		if ( $poseLibBookmarkDoubleClicked != "yes" )
			{
			textScrollList -e -appendPosition 1 $poseLibDefaultPath poseLibDirectoriesBookmarksTSL;
			$poseLibPathsBookmarks = `textScrollList -q -ai poseLibDirectoriesBookmarksTSL`; //print ( "Updating $poseLibPathsBookmarks[zero] = " + $poseLibPathsBookmarks[0] + "\n");
			}

		if ( $askToCopyOldPoseLibFolder != "Cancel" )
			{
			//poseLibSavePrefs;
			evalDeferred("assetMan");
			}

		print ( "poseLib: Successfuly changed default path to \"" + $poseLibDefaultPath + "\"." );
		}
}

global proc poseLibOutputPoseInfo ( int $controlNumber )
{
	global string $poseLibDefaultPath;
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;
	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );

	string $poseFilePath = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseName; //print ("\n$poseFilePath="+$poseFilePath);

	// -------------------
	// Open the file
	// -------------------
	int $fileId=`fopen $poseFilePath "r"`;
	string $controlName = `fgetline $fileId`; // Because first line is empty

	poseLibCheckIfIndexExists($fileId);

	string $alreadyDone = "";
	string $consTmp = "";

	print ( "\n===================================\n" );
	print ( "Pose Control List for \"" + $poseName + "\":\n" );
	print ( "===================================\n" );
	int $count = 0;

	// Go through all the controls.
	while ( size( $controlName ) > 0 )
		{
		$controlName = `fgetword $fileId`; //print $controlName;
		string $attributeName = `fgetword $fileId`; //print $attributeName;
		string $attributeValue = `fgetword $fileId`; //print $attributeValue;
		string $checkTmp = $controlName;

		if ( ($checkTmp != $alreadyDone) && ($controlName != "") )
			{
			$count++;
			print ( $count + "- " + $controlName + "\n" );
			}

		$alreadyDone = $checkTmp;
		}
	fclose $fileId;

	print ( "--> " + $count + " control(s) in this image... (see script editor for details)" );
}

global proc poseLibResetView ()
{
	string $getTextfield = `textFieldGrp -q -tx setNameField`; //print ("\n$getTextfield = " + $getTextfield);
	poseLibCreateNewPose( $getTextfield );
}

global proc poseLibIsolateSelected ( int $cancel )
{
	string $currentSelection[] = `ls -l -sl`;
	string $allGeometries[] = `ls -l -type "mesh" -type "nurbsSurface"`;
	global string $poseLibCancelIsolateCmd;

	if ( `size $currentSelection` != 0 && $poseLibCancelIsolateCmd == "" && $cancel == 0 )
		{
		// Get list of every geometry in the scene and their visibility.
		select -cl;
		string $allGeometries[] = `ls -l -type "mesh" -type "nurbsSurface" -type "subdiv"`;

		// Hide the geometries.
		for ($i=0;$i<`size $allGeometries`;$i++)
			{
			for ($j=0;$j<`size $currentSelection`;$j++)
				{
				string $parent[] = `listRelatives -f -p $allGeometries[$i]`;
				if (!stringArrayContains($parent[0], $currentSelection))
					{
					if ( `getAttr ($allGeometries[$i] + ".visibility")` )
						{
						$poseLibCancelIsolateCmd = $poseLibCancelIsolateCmd + "; setAttr \"" + $allGeometries[$i] + ".visibility\" 1";
						setAttr ($allGeometries[$i] + ".visibility") 0;
						}
					}
				}
			}
		select -r $currentSelection;
		//poseLibResetView;
		}
	else
		{
		// Put back the visibilities the way they were.
		catchQuiet(`eval($poseLibCancelIsolateCmd)`);
		$poseLibCancelIsolateCmd = "";
		//poseLibResetView;
		}
}

global proc poseLibCreateNewPose ( string $ifTextfieldNotEmpty )
{
	global int $poseLibIconsSize[];
	global int $poseLibUseTexturesForIconPreview;
	global float $poseLibCaptureCameraBGColor[];

	// ------------------------------
	// 1- Create snapshot window UI
	// ------------------------------
	if ( `window -exists poseLibCreateNewPoseWindow` )
		deleteUI poseLibCreateNewPoseWindow;

	string $selection[] = `ls -sl`;
	//string $captureModelPanel = "";

	window -rtf true -menuBar false -title "Create Image" -w 10 -h 10 -te 300 -le 500 poseLibCreateNewPoseWindow;
		columnLayout -adjustableColumn true -h 50 poseLibMainColumn;
			// The way this works is we have 4 columns:
			// 1 is for the capture camera
			// 2 is for the glRender camera
			// 3 is for the icon image
			// 4 is for the buttons
			rowLayout -nc 4 -cw4 106 1 1 150 iconCaptureRL;

				// Frame for the capture camera.
				frameLayout -borderStyle "etchedOut" -cl false -cll false -m on -labelVisible false -width 104 -height 104 captureCamFrame;
					modelEditor -nc off -dim off -lc off -joints off -grid on -hud off -da "smoothShaded" -displayTextures on -dl "default" poseLibModelEditor;
				setParent ..;

				// Frame for the glRender camera.
				frameLayout -borderStyle "etchedOut" -cl false -cll false -m off -labelVisible false -width 104 -height 104 glRenderFrame;
					glRenderEditor hardwareRenderViewBis;
				setParent ..;

				// This is just a place holder for when we display the real preview icon.
				columnLayout -adjustableColumn false -w 1 iconCaptureColumn;
					image -m off -h 25 -image "sphere.xpm" capturedI;
				setParent ..;

				// Buttons.
				frameLayout -borderStyle "etchedOut" -labelVisible false -m on -mw 4 -width 164 -height 104 buttonsFrame;
					columnLayout -adjustableColumn true createNewPoseButtonsCL;
						separator -style "none" -h 2;

						// For Mac or Linux.
						if ( `about -macOS` || `about -linux` )
							{
							textFieldGrp -cw2 50 100 -l "Name:" -tx $ifTextfieldNotEmpty setNameField;
							separator -style "none" -h 2;
							button  -label "Preview Icon" -align "center" -c "button -e -en on createPoseButton; poseLibResetView; poseLibDoIconPreview; poseLibDoIconPreview; button -e -en on createPoseButton" -w 100 -h 23;
							separator -style "none" -h 2;
							button -label "Create Pose" -en off -h 23 -c "poseLibDoCreateNewPose" createPoseButton;
							}
						// For Windows.
						else
							{
							textFieldGrp -cw2 50 100 -l "Name:" -tx $ifTextfieldNotEmpty setNameField;
							separator -style "none" -h 2;
							rowColumnLayout -numberOfColumns 3 -columnWidth 1 80 -columnWidth 2 4 -columnWidth 3 68;
								button  -label "Preview Icon" -align "center" -c "button -e -en on createPoseButton; poseLibResetView; poseLibDoIconPreview; poseLibDoIconPreview; button -e -en on createPoseButton" -w 100 -h 23;
									popupMenu -button 3 snapShotPopup;
										menuItem -en on -label "Isolate Selected" -p snapShotPopup -c "poseLibIsolateSelected(0)";
										menuItem -en on -label "Frame Selected" -p snapShotPopup -c "viewFit -f 1.0 poseLibCaptureCamera";
								separator -style "none" -h 2;
								checkBox -l "Textures" -v $poseLibUseTexturesForIconPreview -onc "setAttr defaultHardwareRenderGlobals.texturing 1; $poseLibUseTexturesForIconPreview = 1; optionVar -intValue useTexturesForIconPreviewStatus `checkBox -q -v poseLibUseTexturesForIconPreviewCB`" -ofc "setAttr defaultHardwareRenderGlobals.texturing 0; $poseLibUseTexturesForIconPreview = 0; optionVar -intValue useTexturesForIconPreviewStatus `checkBox -q -v poseLibUseTexturesForIconPreviewCB`" poseLibUseTexturesForIconPreviewCB;
							setParent ..;
							separator -style "none" -h 2;
							button -label "Create Image" -en off -h 23 -c "poseLibDoCreateNewPose" createPoseButton;
							}

							separator -style "none" -h 2;

							rowColumnLayout -numberOfColumns 2 -columnWidth 1 90 -columnWidth 2 62;
								button -label "Reset View" -c "poseLibResetView" -h 23;
								button -label " Cancel " -c "deleteUI poseLibCreateNewPoseWindow; poseLibIsolateSelected(1)" -h 23;
							setParent ..;
						setParent ..;
					setParent ..;
				setParent ..;
			setParent ..;

	// -------------------------------------------------
	// 2- Generate a unique camera using current view.
	// -------------------------------------------------
	if ( !`objExists poseLibCaptureCamera` )
		{
		string $CurrentPanel  = `getPanel -withFocus`;

		if (`getPanel -to $CurrentPanel` != "modelPanel")	// make sure we've got a camera
			{
			string $visPanel[] = `getPanel -vis`;	// get all visible Panels

			string $n;
			for ($n in $visPanel)
				{
				string $modelPanels[] = `getPanel -type modelPanel`;	// get all modelPanels

				if ( (`getPanel -to $n`) == "modelPanel")
					{
					setFocus($n);
					$CurrentPanel = $n;
					break;
					}
				}
			}

		string $CurrentCamera = `modelPanel -q -cam  $CurrentPanel`;
		float $campos[] = `camera -q -position $CurrentCamera`;
		float $camrot[] = `camera -q -rotation $CurrentCamera`;
		float $camwup[] = `camera -q -worldUp  $CurrentCamera`;
		float $camcoi   = `camera -q -coi      $CurrentCamera`;
		float $focal    = `camera -q -fl       $CurrentCamera`;

		string $camShapeNode = `createNode "camera"`;
		string $camTopNode[] = `listRelatives -p $camShapeNode`;
		rename $camTopNode[0] "poseLibCaptureCamera";
		hide "poseLibCaptureCamera";

		int $focalLengthTmp = 35;
		float $nearClipTmp = .1;
		float $farClipTmp = 1000000;

		if ( `optionVar -exists captureCameraFocalLengthStatus` )
			$focalLengthTmp = `optionVar -q captureCameraFocalLengthStatus`;

		if ( `optionVar -exists captureCameraNearClipStatus` )
			$nearClipTmp = `optionVar -q captureCameraNearClipStatus`;

		if ( `optionVar -exists captureCameraFarClipStatus` )
			$farClipTmp = `optionVar -q captureCameraFarClipStatus`;

		camera -edit
			-centerOfInterest $camcoi
			-position $campos[0] $campos[1] $campos[2]
			-rotation $camrot[0] $camrot[1] $camrot[2]
			-worldUp  $camwup[0] $camwup[1] $camwup[2]
			-fl $focalLengthTmp
			-nearClipPlane $nearClipTmp
			-farClipPlane $farClipTmp
		poseLibCaptureCamera;
		}

	// Look through the poseLib camera.
	modelEditor -e -camera "assetManCaptureCamera" poseLibModelEditor;

	// ---------------------------------------------
	// 3- Hardware render looks thru snapshot camera.
	// ---------------------------------------------
	glRenderEditor -e -lt poseLibCaptureCamera hardwareRenderViewBis;

	if ( !`about -macOS` && !`about -linux` )
		{
		// ---------------------------------------------
		// 4- Setup hardware render options.
		// ---------------------------------------------
		// Make sure we're not on a negative frame number.
		int $frame = `currentTime -q`;

		if ( $frame < 0 )
			{
			currentTime 1;
			$frame = 1;
			warning "==> AssetMan doesn't work with negative frame numbers (e.g.: Current time frame has to be 1 or higher). Sorry...";
			}

		// Unlock start and end frame first (as sometimes they get locked (!?) ).
		setAttr -l false "defaultHardwareRenderGlobals.startFrame";
		setAttr -l false "defaultHardwareRenderGlobals.endFrame";
		setAttr -l false "defaultHardwareRenderGlobals.byFrame";

		setAttr "defaultHardwareRenderGlobals.startFrame"  $frame;
		setAttr "defaultHardwareRenderGlobals.endFrame"    $frame;
		setAttr "defaultHardwareRenderGlobals.extension"   1;		// 1=xxx.#.ext
		setAttr "defaultHardwareRenderGlobals.backgroundColor" -type double3 0.75 0.75 0.75;

		// Use textures or not?
		if ( $poseLibUseTexturesForIconPreview == 1 )
			setAttr "defaultHardwareRenderGlobals.texturing" 1;
		else
			setAttr "defaultHardwareRenderGlobals.texturing" 0;

		setAttr "defaultHardwareRenderGlobals.imageFormat" 20;	// bmp=20; jpg=8; tiff=3
		//setAttr "defaultHardwareRenderGlobals.resolution" -type "string" "50x50 50 50 1.0";
		}

	// This is because the first time the window appears, everything gets deselected (?!!).
	select -r $selection;
	showWindow poseLibCreateNewPoseWindow;
	window -e -w 272 -h 134 poseLibCreateNewPoseWindow;
	print "Ready to capture icon...";
}

global proc poseLibDoIconPreview ()
{
	global int $poseLibIconsSize[];
	global float $poseLibCaptureCameraBGColor[];
	global string $poseLibIconFormat;

	print ( "\n\n$poseLibIconFormat = " + $poseLibIconFormat );

	string $iconTmp = "";

	// Get the tmp icon path.
	string $ws = `workspace -q -fullName`; print ( "\nProject = " + $ws );
	string $imagesDir = `workspace -q -renderTypeEntry "images"`; print ( "\nImages directory = " + $imagesDir);
	string $currentImagePath = "";

	// This is in the case the "images" directory path is an absolute path (e.g.: C:/blah...).
	string $buffer[];
	int $numTokens = `tokenize $imagesDir ":" $buffer`; //print ($buffer[`size $buffer`-1]);

	// The path is absolute...
	if ( $buffer[1] == "" )
		{
		$currentImagePath = $ws + "/" + $imagesDir + "/"; //print ( "\n$currentImagePath = " + $currentImagePath );
		}
	else
		{
		// The path is relative...
		$currentImagePath = $imagesDir + "/"; //print ( "\n$currentImagePath = " + $currentImagePath );
		}

	if ( `about -macOS` || `about -linux` )
		{
		//print "\nOperating system is NOT Windows!";

		// Get current renderer.
		string $currentRenderer = `getAttr "defaultRenderGlobals.currentRenderer"`;

		string $currentSceneName = `file -q -sceneName`;
		string $iconNameTmp = basenameEx( $currentSceneName );

		// Switch to software renderer.
		if ( $currentRenderer != "mayaSoftware" )
			setCurrentRenderer mayaSoftware;

		// Set image format render to xpm.
		int $previousImageFormat = `getAttr "defaultRenderGlobals.imageFormat"`; //print ("Previous format = " + $previousImageFormat);
		setAttr defaultRenderGlobals.imageFormat 50;
		setAttr defaultRenderGlobals.imfkey -type "string" "xpm";

		// On OSX, the name of the temp icon is the scene name.
		setAttr -type "string" defaultRenderGlobals.imageFilePrefix $iconNameTmp;

		// Set the BG color.
		setAttr "poseLibCaptureCameraShape.backgroundColor" -type double3 $poseLibCaptureCameraBGColor[0] $poseLibCaptureCameraBGColor[1] $poseLibCaptureCameraBGColor[2];

		// Render the icon.
		render -x $poseLibIconsSize[0] -y $poseLibIconsSize[1] poseLibCaptureCamera;

		// Put back the previous renderer.
		setCurrentRenderer $currentRenderer;

		// Put back the previous image format (if it was not xpm).
		if ( $previousImageFormat != 50 )
			setAttr "defaultRenderGlobals.imageFormat" $previousImageFormat;

		$iconTmp = $currentImagePath + "tmp/poseLibCaptureCamera/" + $iconNameTmp + $poseLibIconFormat; print ( "\n$iconTmp = " + $iconTmp );
		
		// Display the temp icon.
		rowLayout -e -cw 1 $poseLibIconsSize[0] iconCaptureRL; //print ("$poseLibIconsSize[0] = " + $poseLibIconsSize[0] + "\n");
		frameLayout -e -width ($poseLibIconsSize[0] + 4) - height ($poseLibIconsSize[1] + 4) -cl false -cll false -m on captureCamFrame;
		rowLayout -e -cw 1 1 iconCaptureRL; //print ("$poseLibIconsSize[0] = " + $poseLibIconsSize[0] + "\n");
		rowLayout -e -cw 2 1 iconCaptureRL; //print ("$poseLibIconsSize[0] = " + $poseLibIconsSize[0] + "\n");
		rowLayout -e -cw 3 ($poseLibIconsSize[0] + 2) iconCaptureRL;
		frameLayout -e -m off captureCamFrame;
		columnLayout -e -w ($poseLibIconsSize[0] + 4) iconCaptureColumn;
		image -e -m on -w $poseLibIconsSize[0] -h $poseLibIconsSize[1] -image $iconTmp capturedI;
		}
	// On Windows...
	else
		{
		//print "\nOperating system is Windows!";

		// Set the BG color.
		float $currentBGColor[] = `displayRGBColor -q background`;
		displayRGBColor "background" $poseLibCaptureCameraBGColor[0] $poseLibCaptureCameraBGColor[1] $poseLibCaptureCameraBGColor[2];

		setAttr -type "string" defaultHardwareRenderGlobals.filename "iconTmp";
		setAttr -type "string" defaultHardwareRenderGlobals.resolution ( $poseLibIconsSize[0] + "x" + $poseLibIconsSize[1] + " " + $poseLibIconsSize[0] + " " + $poseLibIconsSize[1] + " 1.0");

		frameLayout -e -m on -width ($poseLibIconsSize[0] + 4) -height ($poseLibIconsSize[1] + 4) glRenderFrame;

		// Do the render.
		glRender -e -fs `currentTime -q`;
		glRender -e -ti 0 -abp 2 -is $poseLibIconsSize[0] $poseLibIconsSize[1] 1.0 -es 1 -accumBufferPasses 4 -transformIcons 0 -edgeSmoothness 1.0 -aam "gaussian" -rs hardwareRenderViewBis;

		// Resize the UI to accommodate icon size.
		rowLayout -e -cw 1 $poseLibIconsSize[0] iconCaptureRL; //print ("$poseLibIconsSize[0] = " + $poseLibIconsSize[0] + "\n");
		frameLayout -e -width ($poseLibIconsSize[0] + 4) - height ($poseLibIconsSize[1] + 4) -cl false -cll false -m on captureCamFrame;
		rowLayout -e -cw 1 1 iconCaptureRL; //print ("$poseLibIconsSize[0] = " + $poseLibIconsSize[0] + "\n");
		rowLayout -e -cw 2 1 iconCaptureRL; //print ("$poseLibIconsSize[0] = " + $poseLibIconsSize[0] + "\n");
		rowLayout -e -cw 3 ($poseLibIconsSize[0] + 2) iconCaptureRL;

		// Display the temp icon.
		$iconTmp = $currentImagePath + "iconTmp." + `currentTime -q` + $poseLibIconFormat; print ( "\n$iconTmp = " + $iconTmp );
		evalDeferred ("image -e -m on -w $poseLibIconsSize[0] -h $poseLibIconsSize[1] -image \"" + $iconTmp + "\" capturedI");
		evalDeferred ("frameLayout -e -m off captureCamFrame");
		evalDeferred ("frameLayout -e -m off glRenderFrame");

		// Put back the background color the way it was.
		displayRGBColor "background" $currentBGColor[0] $currentBGColor[1] $currentBGColor[2];
		}

	// Finally, resize the capture window.
	window -e -w ($poseLibIconsSize[0] + `frameLayout -q -width buttonsFrame` + 10) poseLibCreateNewPoseWindow;
}

global proc poseLibDoCreateNewPose ()
{
	global string $poseLibDefaultPath;
	global string $poseLibIconFormat;
	global int $poseLibIconsSize[];
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;
	string $selection[] = `ls -l -sl`;
	string $theAttributes[] = {};

	if ( size($selection) == 0 )
		{
		warning " ---> Please select the character's first!\n";
		return;
		}

	string $iconNameTmp;

	if ( `about -macOS` )
		{
		string $currentSceneName = `file -q -sceneName`;
		$iconNameTmp = basenameEx( $currentSceneName );
		}

	//----------------------
	// 1- Get pose name.
	//----------------------
	string $nameTmp = `textFieldGrp -q -tx setNameField`;
	string $name = `strip $nameTmp`;
	string $checkName = `match "[$%\\/#@.:;?!\"\'\`]" $name`;

	if ( (`size $checkName` > 0) || (`size $name` == 0) )
		{
		error "You must enter a valid name, without any of these: \" $ % \\ / # @ . :; ? ! \' \`";
		return;
		}

	//---------------------------------
	// 2- Check if file already exists.
	//---------------------------------
	string $newPoseFile = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $name;

	if ( `file -q -ex $newPoseFile` )
		{
		string $result = `confirmDialog
			-parent poseLibWindow
			-title "Confirm Save Pose"
			-message ( "Overwrite the existing image: " + $newPoseFile + " ?" ) -ma "center"
			-button "Yes" -button "No"
			-defaultButton "Yes" -cancelButton "No"
			-dismissString "No"`;

		if ($result == "No")
			{
			error "---> The pose has NOT been saved!!!";
			return;
			}
		}

	//---------------------------------
	// 3- Write down pose file.
	//---------------------------------
	int $fileId=`fopen $newPoseFile "w"`;
	int $i, $k;

	for ($i=0;$i<`size $selection`;$i++)
		{
		// Get the list of attributes to save.
		select -r $selection[$i];
		$theAttributes = `listAttr -k -s`;//print ($selection[$i] + "\n");

		// Get the short name of the control.
		string $selection[] = `ls -l -sl`;
		string $buffer1[];
		int $numTokens = `tokenize $selection[0] "|" $buffer1`; //print ($buffer1[`size $buffer1`-1]);
		string $controlName = $buffer1[`size $buffer1`-1]; //print ("\n$controlName = " + $controlName);

		// Check which type of selection we got.
		string $showType[] = `ls -st -sl`; //print ( $selection[$i] + "is of type:" + $showType[1] + "\n");

		// Are we dealing with a blendshape?
		if ( $showType[1] == "blendShape" )
			{
			// Write down the lines in the pose file.
			fprint $fileId ( "\n" + $controlName + " envelope " + `blendShape -q -envelope` );
			string $listOfTargets[] = `aliasAttr -q $selection[0]`;
			fprint $fileId ( "\n" + $controlName + " " + $listOfTargets[0] + " " + (`getAttr ($selection[0] + "." + $listOfTargets[0])`) );
			}

		// Are we dealing with a character set?
		else if ( $showType[1] == "character" )
			{
			string $objectsPlusAttributes[] = `sets -q`;
			//print $objectsPlusAttributes;

			for ($attribute in $objectsPlusAttributes)
				{
				string $bufferTmp[];
				$numTokens = `tokenize $attribute "." $bufferTmp`; //print ($buffer2[`size $buffer2`-1]);

				// Remove the namespace if it exists.
				string $bufferNameTmp[];
				$numTokens = `tokenize $bufferTmp[0] ":" $bufferNameTmp`; //print ($buffer2[`size $buffer2`-1]);

				fprint $fileId ( "\n" + $bufferNameTmp[1] + " " + $bufferTmp[1] + " " + (`getAttr ($bufferTmp[0]+"."+$bufferTmp[1])`) );//print ( "\n" + $selection[$i] + "." + $theAttributes[$k] );
				}
			}
		else
			{
			// Write down the line in the pose file.
			for ($k=0;$k<`size $theAttributes`;$k++)
				{
				fprint $fileId ( "\n" + $controlName + " " + $theAttributes[$k] + " " + (`getAttr ($selection[0]+"."+$theAttributes[$k])`) );//print ( "\n" + $selection[$i] + "." + $theAttributes[$k] );
				}
			}
		}
	fclose $fileId;

	//--------------------------------------------------------------------
	// 4- Copy icon file from maya default "image" dir to the poselib dir.
	//--------------------------------------------------------------------
	//string $currentImagePath = `workspace -q -rd` + "images/"; print ( "\n$currentImagePath = " + $currentImagePath );
	string $ws = `workspace -q -fullName`; //print ( "\n$ws = " + $ws );
	string $imagesDir = `workspace -q -renderTypeEntry "images"`; //print ( "\n$imagesDir = " + $imagesDir );
	string $currentImagePath = "";
	string $newPoseIconFileTmp = "";

	// This is in the case the "images" directory path is an absolute path (e.g.: C:/blah...).
	string $buffer[];
	int $numTokens = `tokenize $imagesDir ":" $buffer`; //print ($buffer[`size $buffer`-1]);

	if ( $buffer[1] == "" )
		{
		$currentImagePath = $ws + "/" + $imagesDir + "/"; //print ( "\n$currentImagePath = " + $currentImagePath );
		}
	else
		{
		$currentImagePath = $imagesDir + "/"; //print ( "\n$currentImagePath = " + $currentImagePath );
		}
	// Temp icon created by Maya
	string $iconTmp = "";

	if ( `about -macOS` || `about -linux` )
		{
		$iconTmp = $currentImagePath + "/tmp/poseLibCaptureCamera/" + $iconNameTmp + ".xpm"; //print ( "\n$newPoseIconFileTmp = " + $newPoseIconFileTmp );
		}
	else
		{
		$iconTmp = $currentImagePath + "iconTmp." + `currentTime -q` + $poseLibIconFormat; //print ( "\n$newPoseIconFileTmp = " + $newPoseIconFileTmp );
		}

	string $newPoseIconFile = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $name + $poseLibIconFormat; //print ("\n$newPoseIconFile = " + $newPoseIconFile );

	// Copy the icon file to its destination.
	sysFile -copy $newPoseIconFile $iconTmp;
	
	// On Linux, give the ownership to the user; without this, the icon won't show up.
	if (`about -os` == "linux")
		{
		string $userTmp = system("whoami");
		evalDeferred(`system( "chown " + $userTmp + " " + $newPoseIconFile)`);
		}

	//---------------------------------
	// 5- Clean-up behind us.
	//---------------------------------
	clear $theAttributes;
	//sysFile -delete $iconTmp;

	// Update the poses.
	poseLibRefreshPoseList("");

	deleteUI poseLibCreateNewPoseWindow;
	//delete poseLibCaptureCamera;
	select -r $selection;
	print ( "AssetMan: Created new iamge \"" + $name + "\"\n" );
}

global proc poseLibMoveCopyUpdateMenu( string $defaultPathTmp )
{
	string $characterName = `optionMenu -q -v characterChoiceOMtmp`;
	string $categoryName = `optionMenu -q -v categoryChoiceOMtmp`;
	string $allCategoryDirsTmp[] = `getFileList -folder ($defaultPathTmp + $characterName + "/")`; //print ("\n$allPoseFiles="+$allPoseFiles[0]);
	string $allCategoryDirs[] = {};
	int $numberOfCategoriesTmp = `optionMenu -q -ni categoryChoiceOMtmp`;

	int $i;
	for ($i=0;$i<`size $allCategoryDirsTmp`;$i++)
		{
		if ( (`match ".deleted" $allCategoryDirsTmp[$i]` != ".deleted") && (`match ".DS_Store" $allCategoryDirsTmp[$i]` != ".DS_Store") )
			$allCategoryDirs = stringArrayCatenate ( $allCategoryDirs, { $allCategoryDirsTmp[$i] } );
		}

	for ($i=0;$i<$numberOfCategoriesTmp;$i++)
		{
		deleteUI ("categoryMItmp_" + $i + "_");
		}

	optionMenu -e categoryChoiceOMtmp;
		for ($i=0;$i<`size $allCategoryDirs`;$i++)
			{
			menuItem -label $allCategoryDirs[$i] -p categoryChoiceOMtmp categoryMItmp[$i]; //print ("\nlabel = " + $poseLibCategoryList[$i] + " control = categoryMI_" + $i + "_" );
			}

	if ( `optionMenu -q -ni categoryChoiceOMtmp` > 1 )
		{
		optionMenu -e -sl 2 categoryChoiceOMtmp;
		optionMenu -e -sl 1 categoryChoiceOMtmp;
		}
}

global proc poseLibRenamePose ( int $controlNumber )
{
	if (`window -exists poseLibRenamePoseWindow` )
		deleteUI poseLibRenamePoseWindow;

	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );

	window -tlb off -rtf on -w 300 -h 85 -title "Rename Pose" poseLibRenamePoseWindow;
		columnLayout -adj true;
			textFieldGrp -cw2 50 150 -l "Name" -cc ("poseLibDoRenamePose ( \"" + $poseName + "\" )") -tx $poseName setNameField;
			button -w 100 -l "Cancel" -al "center" -c "deleteUI poseLibRenamePoseWindow";

	if ( $poseName != "" )
		{
		showWindow poseLibRenamePoseWindow;
		int $poseLibWindowPos[] = `window -q -topLeftCorner poseLibWindow`; //print ("\nleft=" + $poseLibWindowPos[1] );
		window -e -tlc ($poseLibWindowPos[0]+50) ($poseLibWindowPos[1]+50) poseLibRenamePoseWindow;
		}
	else
		warning " ---> Please select a image first!\n";
}

global proc poseLibDoRenamePose ( string $nameTmp )
{
	global string $poseLibDefaultPath;
	global string $poseLibIconFormat;
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;

	string $softPoseToRename = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $nameTmp;
	string $newName = `textFieldGrp -q -tx setNameField`;
	string $newPoseFile = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $newName;

	string $result = "";

	if ( `file -q -exists $newPoseFile` )
		{
		setFocus plMainFL;

		$result = `confirmDialog
			-parent poseLibWindow
			-title "Confirm Rename Pose"
			-message "There is already a image with this name!" -ma "center"
			-button "Overwrite It" -button "Cancel"
			-defaultButton "Overwrite It" -cancelButton "Cancel"
			-dismissString "Cancel"`;
		}

	if ($result == "Overwrite It" || $result == "" )
		{
		sysFile -rename ($poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $newName) $softPoseToRename; //print ( "\noldName= " + $nameTmp + "\nnewName= " + $newName );

		string $softPoseIconToRename = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $nameTmp + $poseLibIconFormat;
		sysFile -rename ($poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $newName + $poseLibIconFormat) $softPoseIconToRename;
		evalDeferred("poseLibRefreshPoseList(\"\")");
		print ( "AssetMan: Renamed image \"" + $nameTmp + "\" to \"" + $newName + "\"\n" );
		}

	deleteUI poseLibRenamePoseWindow;
}

global proc poseLibMovePose ( int $controlNumber )
{
	int $controlNumber;
	global string $poseLibDefaultPath;
	global string $poseLibCharacterList[];
	global string $poseLibCategoryList[];

	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );

	if ( $poseName != "" )
		{
		if (`window -exists poseLibMovePoseWindow` )
			deleteUI poseLibMovePoseWindow;

		window -tlb off -w 300 -h 85 -title ("Move Pose -> " + $poseName) poseLibMovePoseWindow;
			columnLayout;
			text -al "center" "         Where do you want to move this image?";
			separator -style "in" -w 305 -h 10;
			setParent..;
			rowLayout -nc 2 -cw2 150 160;

			optionMenu -h 29 -w 150 -label "MainCategory:" -cc "poseLibMoveCopyUpdateMenu ( ($poseLibDefaultPath + \"/\") )" characterChoiceOMtmp;
			
			string $c;
			for ( $c in $poseLibCharacterList )
				{
				menuItem -label $c;
				}
			
			optionMenu -h 29 -w 160 -label " SubCategory" categoryChoiceOMtmp;

			int $i;
			for ($i=0;$i<`size $poseLibCategoryList`;$i++)
				{
				menuItem -label $poseLibCategoryList[$i] -p categoryChoiceOMtmp categoryMItmp[$i];
				}
			setParent..	;

			optionMenu -e -v (`optionMenu -q -v characterChoiceOM`) characterChoiceOMtmp;
			optionMenu -e -v (`optionMenu -q -v categoryChoiceOM`) categoryChoiceOMtmp;

			rowLayout -nc 2 -cw2 150 163;
				button -w 147 -l "                 Apply" -al "left" -c ("poseLibDoMovePose ( \"" + $poseName + "\" )");
				button -w 154 -l "                  Cancel" -al "left" -c "deleteUI poseLibMovePoseWindow";

		showWindow poseLibMovePoseWindow;
		int $poseLibWindowPos[] = `window -q -topLeftCorner poseLibWindow`; //print ("\nleft=" + $poseLibWindowPos[1] );
		window -e -tlc ($poseLibWindowPos[0]+50) ($poseLibWindowPos[1]+50) poseLibMovePoseWindow;
		}
	else
		warning " ---> Please select a image first!\n";
}

global proc poseLibDoMovePose ( string $poseName )
{
	global string $poseLibDefaultPath;
	global string $poseLibIconFormat;
	string $originCharacterName = `optionMenu -q -v characterChoiceOM`; //print ( "\n $originCharacterName = " + $originCharacterName );
	string $originCategoryName = `optionMenu -q -v categoryChoiceOM`; //print ( "\n $originCategoryName = " + $originCategoryName );
	string $destinationCharacterName = `optionMenu -q -v characterChoiceOMtmp`; //print ( "\n $destinationCharacterName = " + $destinationCharacterName );
	string $destinationCategoryName = `optionMenu -q -v categoryChoiceOMtmp`; //print ( "\n $destinationCategoryName = " + $destinationCategoryName );

	if ( (($destinationCharacterName == $originCharacterName) && ($destinationCategoryName != $originCategoryName))
		|| ($destinationCharacterName != $originCharacterName) )
		{
		string $softPoseOrigin = $poseLibDefaultPath + "/" + $originCharacterName + "/" + $originCategoryName + "/" + $poseName;
		string $softPoseDestination = $poseLibDefaultPath + "/" + $destinationCharacterName + "/" + $destinationCategoryName + "/" + $poseName;

		string $softPoseIconOrigin = $poseLibDefaultPath + "/" + $originCharacterName + "/" + $originCategoryName + "/" + $poseName + $poseLibIconFormat;
		string $softPoseIconDestination = $poseLibDefaultPath + "/" + $destinationCharacterName + "/" + $destinationCategoryName + "/" + $poseName + $poseLibIconFormat;

		sysFile -move $softPoseDestination $softPoseOrigin; //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );
		sysFile -move $softPoseIconDestination $softPoseIconOrigin; //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );

		deleteUI poseLibMovePoseWindow;
		poseLibRefreshPoseList("");
		print ( "AssetMan: Moved selected image to: " + $destinationCharacterName + "/" + $destinationCategoryName +"\n");
		}
	else
		warning " ---> The selected image already belongs to this character AND category!\n";
}

global proc poseLibDeletePose ( int $controlNumber )
{
	global string $poseLibDefaultPath;
	global string $poseLibIconFormat;

	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );
	string $confirmDeleteWindow = "";

	setFocus plMainFL;
	$confirmDeleteWindow = `confirmDialog -p poseLibWindow -title "Confirm Delete image" -message ("Are you sure you want to delete: \"" + $poseName + "\" ?") -button "Yes" -button "Cancel" -defaultButton "Yes" -cancelButton "Cancel"`;

	if ( $confirmDeleteWindow == "Yes" )
		{
		string $characterName = `optionMenu -q -v characterChoiceOM`;
		string $categoryName = `optionMenu -q -v categoryChoiceOM`;

		string $softPoseToDelete = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseName;
		string $softPoseIconToDelete = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseName + $poseLibIconFormat;

		// sysFile -delete $softPoseToDelete; print ("\n$Deleted pose: " + $softPoseToDelete);
		// --> Well, actually let's make a backup of the file rather than delete it.
		sysFile -rename ($softPoseToDelete + ".deleted") $softPoseToDelete; print ("poseLib: Deleted pose: " + $softPoseToDelete +"\n");

		if ( `filetest -r $softPoseIconToDelete` )
			sysFile -delete $softPoseIconToDelete; //print ("\n$Deleted image: " + $softPoseToDelete);

		poseLibRefreshPoseList("");
		}

	else
		print "AssetMan: Did nothing...";
}

global proc poseLibReplacePose ( int $controlNumber )
{
	global string $poseLibDefaultPath;

	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );
	string $confirmDeleteWindow = "";
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;
	string $selection[] = `ls -l -sl`;
	string $theAttributes[] = {};

	if ( size($selection) == 0 )
		{
		warning " ---> Please select the character first!\n";
		return;
		}

	//----------------------
	// 1- Get pose name.
	//----------------------
	setFocus plMainFL;
	string $confirmReplaceWindow = `confirmDialog -p poseLibWindow -title "Confirm Replace image" -message ("Are you sure you want to replace: \"" + $poseName + "\" ?") -button "Yes" -button "Cancel" -defaultButton "Yes" -cancelButton "Cancel"`;

	if ( $confirmReplaceWindow == "Yes" )
		{
		//------------------------------------------------------
		// 2- Write down pose file (no need to change the icon).
		//------------------------------------------------------
		string $newPoseFile = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseName;

		// do a backup before messing with the pose (you never know)
		sysFile -copy ($newPoseFile + ".deleted") $newPoseFile; //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );

		// Get the existing index order.
		int $fileId=`fopen $newPoseFile "r"`;
		string $getIndex = poseLibCheckIfIndexExists($fileId); print ("$getIndex = " + $getIndex);
		// If there's no index order, set it to 100.
		if ( $getIndex == "" )
			$getIndex = 100;
		fclose $fileId;

		int $fileId=`fopen $newPoseFile "w"`;
		fprint $fileId ("\nposeLibIndexOrder " + $getIndex);

		int $i, $k;
		for ($i=0;$i<`size $selection`;$i++)
			{
			// Get the list of attributes to save.
			select -r $selection[$i];
			$theAttributes = `listAttr -k -s`;//print ($selection[$i] + "\n");

			// Get the short name of the control.
			string $selection[] = `ls -l -sl`;
			string $buffer1[];
			int $numTokens = `tokenize $selection[0] "|" $buffer1`; //print ($buffer1[`size $buffer1`-1]);
			string $shortNameTmp = $buffer1[`size $buffer1`-1];

			// Check if the control has a namespace...
			string $buffer2[];
			$numTokens = `tokenize $shortNameTmp ":" $buffer2`; //print ($buffer2[`size $buffer2`-1]);

			// ... And remove it if it does.
			string $controlName = ($buffer2[`size $buffer2`-1]); //print ("\n$controlName = " + $controlName);

			// Are we dealing with a blendshape?
			string $showType[] = `ls -st -sl`;

			if ( $showType[1] == "blendShape" )
				{
				// Write down the lines in the pose file.
				fprint $fileId ( "\n" + $controlName + " envelope " + `blendShape -q -envelope` );
				string $listOfTargets[] = `aliasAttr -q $selection[0]`;
				fprint $fileId ( "\n" + $controlName + " " + $listOfTargets[0] + " " + (`getAttr ($selection[0] + "." + $listOfTargets[0])`) );
				}

			else
				{
				// Write down the line in the pose file.
				for ($k=0;$k<`size $theAttributes`;$k++)
					{
					fprint $fileId ( "\n" + $controlName + " " + $theAttributes[$k] + " " + (`getAttr ($selection[0]+"."+$theAttributes[$k])`) );//print ( "\n" + $selection[$i] + "." + $theAttributes[$k] );
					}
				}
			}
		fclose $fileId;

		//-----------------------------
		// 3- Clean-up behind us.
		//-----------------------------
		clear $theAttributes;
		select -r $selection;

		poseLibRefreshPoseList("");
		print ( "AssetMan: Replaced image \"" + $poseName + "\"\n" );
		}

	else
		print "AssetMan: Did nothing -> Aborted by user.";
}

global proc poseLibSelectPoseControls ( int $controlNumber )
{
	global string $poseLibDefaultPath;
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;
	string $actualControlName[] = {};
	string $controlsToSelect[] = {};

	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );
	string $poseFilePath = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseName; //print ("\n$poseFilePath="+$poseFilePath);

	// ---------------------------------------------------
	// 1- Read the pose file to get all the control names
	// ---------------------------------------------------
	int $fileId=`fopen $poseFilePath "r"`;
	string $controlName = `fgetline $fileId`;

	poseLibCheckIfIndexExists($fileId);

	string $alreadyDone = "";
	string $consTmp = "";
	string $controlsToSelect[] = {};
	string $array[] = {};

	while ( size( $controlName ) > 0 )
		{
		$controlName = `fgetword $fileId`; //print $controlName;
		string $attributeName = `fgetword $fileId`; //print $attributeName;
		string $attributeValue = `fgetword $fileId`; //print $attributeValue;
		string $checkTmp = $controlName;

		if ( $checkTmp != $alreadyDone )
			$controlsToSelect = stringArrayCatenate ( $controlsToSelect, { $controlName } );

		$alreadyDone = $checkTmp;
		}
	fclose $fileId;

	// --------------------------
	// 2- Select the controls
	// --------------------------
	string $namespace = "";
	int $didSomething = 0;

	for ($i=0;$i<`size $controlsToSelect`;$i++)
		{
		// If we're in ref mode, add the namespace to the control name.
		if ( `checkBox -q -v useCurrentCharacterCB` )
			$namespace = $characterName + ":"; //print ($namespace + "\n");
		else if ( `checkBox -q -v useCustomNamespaceCB` )
			$namespace = `textField -q -tx namespaceTextFieldTF` + ":";

		$controlsToSelect[$i] = $namespace + $controlsToSelect[$i];

		if ( `objExists $controlsToSelect[$i]` )
			{
			select -add $controlsToSelect[$i];
			$didSomething = 1; //print ("\n$controlsToSelect[$i]=" + $controlsToSelect[$i] );
			}
		}

	if ( $didSomething == 0 )
		warning " ---> Could not find the controls! (check reference mode)\n";
	else
		print "AssetMan: Selected pose controls done!\n";
}

global proc poseLibEditPoseFile( int $controlNumber )
{
	global string $poseLibDefaultPath;
	global string $poseLibTextEditor;
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;

	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );
	string $poseFilePath = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseName; //print ("\n$poseFilePath="+$poseFilePath);

	system("start " + $poseLibTextEditor + " " + $poseFilePath);
}

global proc poseLibAddReplaceSelectedControls( int $controlNumber )
{
	global string $poseLibDefaultPath;
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;

	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );
	string $poseFilePath = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseName; //print ("\n$poseFilePath="+$poseFilePath);

	string $selection[] = `ls -l -sl`;
	string $controlsToAdd[] = `ls -l -sl`;
	string $array[] = {};

	setFocus plMainFL;
	string $confirmAddControlsWindow;
	if ( $controlsToAdd[0] != "" )
		$confirmAddControlsWindow = `confirmDialog -parent poseLibWindow -title "Confirm Add/Replace Control(s)" -message "Are you sure you want to Add/Replace the selected control(s) in this pose?" -button "Yes" -button "Cancel" -defaultButton "Yes" -cancelButton "Cancel"`;
	else
		warning " ---> Please select controls first!\n";

	// Get control short name and remove potential namespace.
	string $controlsToAdd[] = `ls -l -sl`;

	int $i;
	for ($i=0;$i<`size $controlsToAdd`;$i++)
		{
		string $buffer[];
		int $numTokens = `tokenize ($controlsToAdd[$i]) "|:" $buffer`; //print $buffer[`size $buffer` -1];

		$controlsToAdd[$i] = $buffer[`size $buffer` -1];
		}

	// The way this works is: We create a temporary new pose file, and fill-it up line after
	// line, while parsing through the original, in order to create the new file (without the undesirable controls)...
	string $softPoseToTweak = $poseFilePath;
	string $softNewPosePath = $poseFilePath + ".TMP";

	// First, remove the controls to add/replace (we'll add them at the end of the file)...
	if ( $confirmAddControlsWindow == "Yes" )
		{
		int $fileId1=`fopen $softPoseToTweak "r"`;
		int $fileId2=`fopen $softNewPosePath "w"`;

		// Do a backup of the pose file before messing with the controls (you never know)...
		sysFile -copy ($softPoseToTweak + ".deleted") $softPoseToTweak; //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );

		string $controlName = `fgetline $fileId1`; // because 1st line is empty

		// Get the existing index order.
		string $getIndex = poseLibCheckIfIndexExists($fileId1); print ("$getIndex = " + $getIndex);
		// If there's no index order, set it to 100.
		if ( $getIndex == "" )
			$getIndex = 100;
		fprint $fileId2 ("\nposeLibIndexOrder " + $getIndex);

		string $previouslyWritten = "";
		int $didSomething = 0;

		while ( !`feof $fileId1` )
			{
			$controlName = `fgetword $fileId1`; //print $controlName;
			string $attributeName = `fgetword $fileId1`; //print $attributeName;
			float $attributeValue = `fgetword $fileId1`; //print $attributeValue;

			int $check = 0;

			string $c;
			for ( $c in $controlsToAdd )
				{
				if ( $c == $controlName )
					{
					$check = 1;

					if ( $previouslyWritten != $c )
						{
						print ("poseLib: Added/Replaced \"" + $c + "\" in \"" + $poseName + "\"\n" );
						$previouslyWritten = $c;
						}
					}
				}

			if ( $check == 0 )
				fprint $fileId2 ( "\n" + $controlName + " " + $attributeName + " " + $attributeValue );
			}

		// ... Now, add the selected controls at the end of the file.
		for ($i=0;$i<`size $selection`;$i++)
			{
			select -r $selection[$i];
			string $theAttributes[] = `listAttr -k`;

			// Get the short name of the control.
			string $selection[] = `ls -l -sl`;
			string $buffer1[];
			int $numTokens = `tokenize $selection[0] "|" $buffer1`; //print ($buffer1[`size $buffer1`-1]);
			string $shortNameTmp = $buffer1[`size $buffer1`-1];

			// Check if the control has a namespace...
			string $buffer2[];
			$numTokens = `tokenize $shortNameTmp ":" $buffer2`; //print ($buffer2[`size $buffer2`-1]);

			// ... And remove it if it does.
			string $controlName = ($buffer2[`size $buffer2`-1]); //print ("\n$controlName = " + $controlName);

			// Are we dealing with a blendshape?
			string $showType[] = `ls -st -sl`; //print ( $selection[$i] + "is of type:" + $showType[1] + "\n");

			if ( $showType[1] == "blendShape" )
				{
				// Write down the lines in the pose file.
				fprint $fileId2 ( "\n" + $controlName + " envelope " + `blendShape -q -envelope` );
				string $listOfTargets[] = `blendShape -q -t`;
				fprint $fileId2 ( "\n" + $controlName + " " + $listOfTargets[0] + " " + (`getAttr ($selection[$i] + "." + $listOfTargets[0])`) );
				$didSomething = 1;
				}

			else
				{
				int $j;
				for ($j=0;$j<`size $theAttributes`;$j++)
					{
					fprint $fileId2 ( "\n" + $controlsToAdd[$i] + " " + $theAttributes[$j] + " " + `getAttr ($selection[$i]+"."+$theAttributes[$j])`);
					$didSomething = 1;
					}
				}
			}

		fclose $fileId1;
		fclose $fileId2;

		// Now we delete the original file and rename the copy to take it's place.
		sysFile -delete $softPoseToTweak; //print ("\n$Deleted pose: " + $softPoseToDelete);
		sysFile -rename $softPoseToTweak $softNewPosePath; //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );

		select -r $selection;

		if ( $didSomething == 1 )
			print "AssetMan: Selected control(s) have been Added/Replaced in pose! (see script editor for details)\n";
		else
			warning "--> Did nothing!\n";
		}
}

global proc poseLibRemoveSelectedControls( int $controlNumber )
{
	global string $poseLibDefaultPath;
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;

	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );
	string $poseFilePath = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseName; //print ("\n$poseFilePath="+$poseFilePath);

	string $controlsToRemove[] = `ls -l -sl`;
	string $array[] = {};

	string $confirmRemoveControlsWindow;
	setFocus plMainFL;

	if ( $controlsToRemove[0] != "" )
		$confirmRemoveControlsWindow = `confirmDialog -parent poseLibWindow -title "Confirm" -message "Are you sure you want to Remove the selected control(s) from this pose?" -button "Yes" -button "Cancel" -defaultButton "Yes" -cancelButton "Cancel"`;
	else
		warning " ---> Please select controls first!\n";

	// Get control short name and remove potential namespace.
	string $controlsToRemove[] = `ls -l -sl`;

	int $i;
	for ($i=0;$i<`size $controlsToRemove`;$i++)
		{
		string $buffer[];
		int $numTokens = `tokenize ($controlsToRemove[$i]) "|:" $buffer`; //print $buffer[`size $buffer` -1];

		$controlsToRemove[$i] = $buffer[`size $buffer` -1];
		}

	// The way this works is: We create a temporary new pose file, and fill-it up line after
	// line, while parsing through the original, in order to create the new file (without the undesirable controls)...
	string $softPoseToTweak = $poseFilePath;
	string $softNewPosePath = $poseFilePath + ".TMP";

	if ( $confirmRemoveControlsWindow == "Yes" )
		{
		int $fileId1=`fopen $softPoseToTweak "r"`;
		int $fileId2=`fopen $softNewPosePath "w"`;

		// Do a backup of the pose file before messing with the controls (you never know)...
		sysFile -copy ($softPoseToTweak + ".deleted") $softPoseToTweak; //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );

		string $controlName = `fgetline $fileId1`;

		poseLibCheckIfIndexExists($fileId1);

		string $previouslyWritten = "";
		int $didSomething = 0;

		while ( !`feof $fileId1` )
			{
			$controlName = `fgetword $fileId1`; //print $controlName;
			string $attributeName = `fgetword $fileId1`; //print $attributeName;
			float $attributeValue = `fgetword $fileId1`; //print $attributeValue;

			int $check = 0;

			string $c;
			for ( $c in $controlsToRemove )
				{
				if ( $c == $controlName )
					{
					$check = 1;

					if ( $previouslyWritten != $c )
						{
						print ("AssetMan: Removed \"" + $c + "\" from \"" + $poseName + "\"\n" );
						$previouslyWritten = $c;
						$didSomething = 1;
						}
					}
				}

			if ( $check == 0 )
				fprint $fileId2 ( "\n" + $controlName + " " + $attributeName + " " + $attributeValue );
			}
		fclose $fileId1;
		fclose $fileId2;

		// Now we delete the original file and rename the copy to take it's place.
		sysFile -delete $softPoseToTweak; //print ("\n$Deleted image: " + $softPoseToDelete);
		sysFile -rename $softPoseToTweak $softNewPosePath; //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );

		if ( $didSomething == 1 )
			print "Assetman: Selected control(s) have been removed from pose! (see script editor for details)\n";
		else
			warning "--> The selected controls were NOT a part of this pose!\n";
		}
}

global proc poseLibApplyPose ( int $controlNumber )
{
	// Is the ALT or CTRL key pressed?
	int $altKeyDown = 0;
	int $getModifiers = `getModifiers`;

	if ( ($getModifiers == 8) || ($getModifiers == 4) )
		{
		//print ("mod down and we have an inverse increment val of "+ $poseLibApplyIncrement +"\n");  // ALT key down x%
		$altKeyDown = 1; // to pass into the value mult operation
		}

	string $poseNameTmp = `shelfButton -q -l ("poseButton_" + $controlNumber + "_")`;
	string $poseName = `strip $poseNameTmp`; //print ("\n$poseName=" + $poseName );

	poseLibDoApplyPose ( $poseName, $altKeyDown );
}

global proc poseLibDoApplyPose( string $poseName, int $altKeyDown )
{
	global string $poseLibDefaultPath;
	global float $poseLibApplyIncrement; // KDL hack for alt key

	string $characterName = `optionMenu -q -v characterChoiceOM`;
	string $categoryName = `optionMenu -q -v categoryChoiceOM`;
	string $selection[] = `ls -l -sl`;
	string $poseFilePath = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $poseName;  //print ("\n$poseFilePath="+$poseFilePath);
	string $namespace = "";
	string $array[] = {};
	string $sel[] = `ls -sl`;

	// Are we dealing with a character set?
	for ($object in $sel)
		{
		string $checkTmp[] = `ls -type "character" $object`;
		// Deselect the set itself.
		if ( $checkTmp[0] != "" )
			{
			select -d $object;
			// Select instead its members.
			string $membersTmp[] = `sets -q -no $object`;
			select -add $membersTmp;
			}
		}

	// This is here for backward compatibility with previous poseLib versions (where attribute names were saved as "long names" e.g.:|toto|tutu...).
	string $selectedChannels[] = `channelBox -q -sma "mainChannelBox"`; //print $selectedChannels;

	for ($i=0;$i<`size $selectedChannels`;$i++)
		{
		string $defaultObjectPlusAttribute = $selection[0] + "." + $selectedChannels[$i];
		string $longObjectPlusAttribute = `longNameOf($defaultObjectPlusAttribute)`;// print ( $longObjectPlusAttribute + "\n" );

		string $buffer[];
		int $numTokens = `tokenize $longObjectPlusAttribute "." $buffer`; //print $buffer[1];

		$selectedChannels[$i] = $buffer[1];
		}

	// Parse through the pose file.
	if ( `filetest -r $poseFilePath` )
		{
		// Open pose file.
		int $fileId=`fopen $poseFilePath "r"`;
		string $controlName = `fgetline $fileId`; // This is because the first line is empty.

		poseLibCheckIfIndexExists($fileId);

		// In order to know what's selected when the user clicks on the button.
		string $poseLibApplyPoseCommand = "string $poseName = \"" + $poseName + "\"; int $didSomething = 0; ";
		string $currentSelection[] = `ls -l -sl`;

		// Get a list of all the namespaces in the current selection.
		string $allNamespaces[] = {""};

		if ( $sel[0] != "" )
			{
			for ($i=0;$i<`size $sel`;$i++)
				{
				string $checkForNameSpace[];
				int $numTokens = `tokenize $sel[$i] ":" $checkForNameSpace`; //print ("$checkForNameSpace[0] = " + $checkForNameSpace[1] + "\n");
				int $alreadyThere = stringArrayContains($checkForNameSpace[0], $allNamespaces); //print ("$alreadyThere = " + $alreadyThere + "\n");

				// If there is a valid namespace and it's not already stored.
				if ( `size $checkForNameSpace` >= 2 && $alreadyThere == 0 )
					{
					$allNamespaces[`size $allNamespaces`] = $checkForNameSpace[0];
					}
				}
			}

		for ($j=0;$j<`size $allNamespaces`;$j++)
			{
			$allNamespaces[$j] = $allNamespaces[$j] + ":";
			}

		// If the user precises a namespace to use, then nuke the existing namespaces and set the official one.
		if ( `checkBox -q -v useCurrentCharacterCB` )
			{
			clear $allNamespaces;
			$allNamespaces[0] = $characterName + ":"; //print ($namespace + "\n");
			}
		else if ( `checkBox -q -v useCustomNamespaceCB` )
			{
			clear $allNamespaces;
			$allNamespaces[0] = `textField -q -tx namespaceTextFieldTF` + ":";
			}

		//print $allNamespaces;

		waitCursor -state on;

		// For every line in the pose file:
		while ( !`feof $fileId` )
			{
			string $controlName = `fgetword $fileId`;
			string $attributeName = `fgetword $fileId`; //print ($attributeName + "\n");
			string $attributeValue = `fgetword $fileId`; //print ($attributeValue + "\n");

			// Here for simplicity purpose we use the $allNamespaces variable even if there's no namespace
			// since $allNamespaces[0] is "", meaning that by default there is no namespace.
			for ($i=0;$i<`size $allNamespaces`;$i++)
				{
				string $newControlName = $allNamespaces[$i] + $controlName; //print ("\n$newControlName = " + $newControlName);
				string $parsing[] = `ls -sl $newControlName`;
				string $multiple[] = `ls $newControlName`;

				// Match the selected channel(s) with the one in the pose.
				if ( stringArrayContains($attributeName, $selectedChannels) || $selectedChannels[0] == "" )
					{
					// If the ALT key is pressed, then set a fraction of the pose.
					if ( $altKeyDown )
						{
						// First get the attribute name.
						string $currentAttributeValueAsString;

						if ( ($parsing[0] != "" && $currentSelection[0] != "") && (`objExists ($parsing[0] + "." + $attributeName)`) && (`getAttr -se ($newControlName + "." + $attributeName)`) )
							$currentAttributeValueAsString = `getAttr ($parsing[0] + "." + $attributeName)`;

						else if ( ($currentSelection[0] == "") && (`objExists ($newControlName + "." + $attributeName)`) && ($multiple[1] == "") && (`getAttr -se ($newControlName + "." + $attributeName)`) )
							$currentAttributeValueAsString = `getAttr ($newControlName + "." + $attributeName)`;

						float $currentAttrFloat = $currentAttributeValueAsString; // turns the string into a float if possible
						string $gPassOnVal = $attributeValue; // capture pose val string for later if it can't float
						float $valFloat = $attributeValue; // convert the pose doc val string to a float if you can

						if (($currentAttrFloat >= 0) || ($currentAttrFloat <= 0)) // if the string is a number of some kind and not just a 0
							{
							float $valDifference = ($currentAttrFloat - $valFloat); //get the difference in values between what is current and what is in the pose
							float $modAttrVal = ($valDifference * $poseLibApplyIncrement); // multiply the value difference by the increment
							float $currValPlusModVal = ($valFloat + $modAttrVal); // add the current value plus the incremented value to get the modified value to pass along
							string $gPassOnVal = $currValPlusModVal; // get the modified value into a string form
							$attributeValue = $gPassOnVal; //  pass on the results
							}
						}

					// Add to the existing command to be executed later all at once.
					if ( ($parsing[0] != "" && $currentSelection[0] != "") && (`objExists ($parsing[0] + "." + $attributeName)`) && (`getAttr -se ($parsing[0] + "." + $attributeName)`) )
						$poseLibApplyPoseCommand = $poseLibApplyPoseCommand + " setAttr " + $parsing[0] + "." + $attributeName + " " + $attributeValue + "; $didSomething = 1;";

					else if ( ($currentSelection[0] == "") && (`objExists ($newControlName + "." + $attributeName)`) && ($multiple[1] == "") && (`getAttr -se ($newControlName + "." + $attributeName)`) )
						$poseLibApplyPoseCommand = $poseLibApplyPoseCommand + " setAttr " + $newControlName + "." + $attributeName + " " + $attributeValue + "; $didSomething = 1;";
					}
				}
			}

		string $findImagePath =  $poseFilePath;		
		string $buffer0[];
		$numTokens = `tokenize $findImagePath  "/" $buffer0`;
		string $inputDirectory="//mayaserver/T99/04_PRODUCTION/REFERENCES/"+$buffer0[3]+"/"+$buffer0[4]+"/";
		string $files[] = `getFileList -folder $inputDirectory -filespec "*.ma"`;
		for($i=0; $i<size($files); $i++)
		{	
			string $buffer1[];
			$numTokens = `tokenize $files[$i] "." $buffer1`;
			if( $poseName == $buffer1[0] )
			{
				string $propFind="//mayaserver/T99/04_PRODUCTION/REFERENCES/"+$buffer0[3]+"/"+$buffer0[4]+"/"+$poseName+".ma";
				file -rdi 1 -ns $buffer1[0] -rfn ($buffer1[0] + "RN") $propFind;
				file -r  -ns $buffer1[0] -rfn ($buffer1[0] + "RN") $propFind;
			} 
	
		}

		fclose $fileId;

	/*	This is to warn the user in the case nothing was accomplished.
		string $amountTmp = "100% of";
		string $mentionTheChannels = "";

		if ( $selectedChannels[0] != "" )
			$mentionTheChannels = "of selected channel(s) for ";

		if ( $altKeyDown == 1)
			$amountTmp = "Increment";

		$poseLibApplyPoseCommand = $poseLibApplyPoseCommand + "if ($didSomething == 0) warning \"poseLib: ==> Nothing happened! <==  (please refer to script editor for possible reasons)\\n\\n1) Your current selection might not part of this pose.\\n2) Maybe the Ref/Unref choice is wrong: Try unchecking the Use Namespace checkbox.\\n3) There might be two or more controls with the exact same name in your scene. (in this case, just select the one you want to pose)\"; else print (\"poseLib: " + $amountTmp + " " + $mentionTheChannels + "pose '\" + $poseName + \"' done!\")";

		catch( `eval( $poseLibApplyPoseCommand )` );
		}
	else
		error ( "poseLib: The file " + $poseFilePath + " can not be found!");

	This is in case we deselected a character set before applying the pose.
	select -r $sel;
	setFocus `getPanel -wf`;   */

	waitCursor -state off;
	}
}

global proc poseLibRefreshPoseList( string $categoryName )
{
	global string $poseLibDefaultPath;
	global string $poseLibCategoryList[];
	global int $realNumber;
	global int $poseLibIconsSize[];
	global float $poseLibIconsBGColor[];
	global string $poseLibIconFormat;
	string $characterName = `optionMenu -q -v characterChoiceOM`;
	if ($categoryName == "" )
		$categoryName = `optionMenu -q -v categoryChoiceOM`; //print ("poseLib: $categoryName = " + $categoryName +"\n");
	string $allCategoryDirsTmp[] = `getFileList -folder ($poseLibDefaultPath + "/" + $characterName + "/")`; //print ("\n$allPoseFiles="+$allPoseFiles[0]);
	string $allCategoryDirs[] = {};

	// Enforce 50 pixels as the smallest icon size.
	if ( $poseLibIconsSize[0] < 32 )
		{
		$poseLibIconsSize[0] = 50;
		$poseLibIconsSize[1] = 50;
		}

	// ---------------------------------
	// 1- Filter out what can be shown
	// ---------------------------------
	int $i;
	for ($i=0;$i<`size $allCategoryDirsTmp`;$i++)
		{
		if ( (`match ".deleted" $allCategoryDirsTmp[$i]` != ".deleted") && (`match ".DS_Store" $allCategoryDirsTmp[$i]` != ".DS_Store") )
			$allCategoryDirs = stringArrayCatenate ( $allCategoryDirs, { $allCategoryDirsTmp[$i] } );
		}

	// ---------------------------------------
	// 2- Update the category option menus
	// ---------------------------------------
	for ($i=0;$i<`size $poseLibCategoryList`;$i++)
		{
		deleteUI ("categoryMI_" + $i + "_");
		}

	$poseLibCategoryList = $allCategoryDirs;

	optionMenu -e -h 28 -w 180 -label "Sub Category:" -cc "poseLibRefreshPoseList(\"\")" -p optionMenusRow categoryChoiceOM;
	for ($i=0;$i<`size $poseLibCategoryList`;$i++)
		{
		menuItem -label $poseLibCategoryList[$i] -p categoryChoiceOM categoryMI[$i]; //print ("\nlabel = " + $poseLibCategoryList[$i] + " control = categoryMI_" + $i + "_" );
		}

	string $myIntersector = `stringArrayIntersector`;
	stringArrayIntersector -edit -intersect $poseLibCategoryList $myIntersector;
	stringArrayIntersector -edit -intersect $categoryName $myIntersector;
	string $isItIncluded[] = `stringArrayIntersector -query $myIntersector`;

	if ( $isItIncluded[0] != "" )
		optionMenu -e -h 28 -w 180 -v $categoryName -cc "poseLibRefreshPoseList(\"\")" -p optionMenusRow categoryChoiceOM;
	else
		{
		if ( $poseLibCategoryList[0] != "" )
			{
			optionMenu -e -h 28 -w 180 -v $poseLibCategoryList[0] -cc "poseLibRefreshPoseList(\"\")" -p optionMenusRow categoryChoiceOM; //		print ("poseLib: \"" + $categoryName + "\" category doesn't exist for this character!\n" );
			$categoryName = $poseLibCategoryList[0]; //print ("poseLib: $poseLibCategoryList[0] = " + $poseLibCategoryList[0] +"\n");
			}
		}

	if ( (`optionMenu -q -sl categoryChoiceOM` == 1) && (`optionMenu -q -ni categoryChoiceOM` > 1) )
		{
		optionMenu -e -m off -sl 2 -p optionMenusRow categoryChoiceOM; // absolutely absurd: if not, first item is shown as last!
		optionMenu -e -m on -sl 1 -p optionMenusRow categoryChoiceOM;
		}

	//print ("poseLib: character/category = " + $characterName + "/" + $categoryName +"\n");
	string $poseFilesPath = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/"; //print ("\n$poseFilesPath="+$poseFilesPath);
	string $allPoseFiles[] = `getFileList -folder $poseFilesPath`; //print "\n$allPoseFiles:\n"; print $allPoseFiles; print "\n";
	string $iconsPath = $poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/"; //print ("\n$iconsPath="+$iconsPath);

	// ------------------------------
	// 3- Clear previous poses icons.
	// ------------------------------
	frameLayout -e -m off plPosesFL;
	shelfLayout -e -m off -st "iconAndTextVertical" -cw ($poseLibIconsSize[0] + 5) -ch ($poseLibIconsSize[1] + 23) plPosesSL;
	string $iconsToDelete[] = `shelfLayout -q -ca plPosesSL`;

	for ($icon in $iconsToDelete)
		deleteUI $icon;

	// --------------------------------------------
	// 4- Get the indices for the pose orders
	// --------------------------------------------
	$realNumber = 0;
	string $listOfPoses[] = {};
	int $listOfIndexes[] = {};
	int $count = 0;

	for ($i=0;$i<`size $allPoseFiles`;$i++)
		{
		if ( (`match ".bmp" $allPoseFiles[$i]` != ".bmp") &&
			(`match ".xpm" $allPoseFiles[$i]` != ".xpm") &&
			(`match ".deleted" $allPoseFiles[$i]` != ".deleted") &&
			(`match ".DS_Store" $allPoseFiles[$i]` != ".DS_Store") &&
			(`match ".bak" $allPoseFiles[$i]` != ".bak") )
			{
			// Open pose file.
			int $fileId = `fopen ($poseLibDefaultPath + "/" + $characterName + "/" + $categoryName + "/" + $allPoseFiles[$i]) "r"`;
			string $firstWord = `fgetword $fileId`; // This is because the first line is empty.

			// Get the pose index number.
			if ( $firstWord == "poseLibIndexOrder")
				{
				//print ("\n$firstWord of \"" + $allPoseFiles[$i] + "\" is \"" + $firstWord + "\"");
				int $indexOrder = `fgetword $fileId`; //print ("$indexOrder = " + $indexOrder + "\n");
				$listOfIndexes[`size $listOfIndexes`] = $indexOrder;
				$listOfPoses[`size $listOfPoses`] = $allPoseFiles[$i];
				//stringArrayInsertAtIndex($indexOrder, $listOfPosesByIndex, $allPoseFiles[$count]);
				$count ++;
				}
			else
				{
				//print ("\n$firstWord of \"" + $allPoseFiles[$i] + "\" is \"" + $firstWord + "\"");
				//stringArrayInsertAtIndex(100+$count, $listOfPosesByIndex, $allPoseFiles[$count]);
				$listOfIndexes[`size $listOfIndexes`] = 100 + $count;
				$listOfPoses[`size $listOfPoses`] = $allPoseFiles[$i];
				$count ++;
				}
			fclose $fileId;
			}
		}

	//print "\n\n$listOfIndexes:\n"; print $listOfIndexes;
	//print "\n\n$listOfPoses:\n"; print $listOfPoses;

	string $listOfPosesByIndex[] = {};
	for ($i=0;$i<`size $listOfIndexes`;$i++)
		{
		$listOfPosesByIndex[$listOfIndexes[$i]] = $listOfPoses[$i];
		//print ("\n$listOfPosesByIndex[" + $listOfIndexes[$i] + "] = " + $listOfPosesByIndex[$listOfIndexes[$i]]);
		}
	//$listOfPosesByIndex = stringArrayRemoveExact({""}, $listOfPosesByIndex);
	//print "\n\n$listOfPoses = "; print $listOfPoses;
	//print "\n\n$listOfPosesByIndex = "; print $listOfPosesByIndex; print "<-end";

	// ------------------------------
	// 5- Create new poses buttons.
	// ------------------------------
	for ($i=0;$i<`size $listOfPosesByIndex`;$i++)
		{
		if ( $listOfPosesByIndex[$i] != "" )
			{
			shelfButton
				//-style "iconOnly"
				-style "iconAndTextVertical"
				-bgc $poseLibIconsBGColor[0] $poseLibIconsBGColor[1] $poseLibIconsBGColor[2]
				-parent plPosesSL
				//-iol $listOfPosesByIndex[$i]
				-label $listOfPosesByIndex[$i]
				-c ("poseLibApplyPose (" + $realNumber + ")") poseButton[$realNumber];

			//Add a popup to each shelfButton so we can edit its parameters, or delete it.
			popupMenu -button 3 posePopupMenu[$realNumber];

				menuItem -en on -label "Select Pose Controls" -c ("poseLibSelectPoseControls (" + $realNumber + ")") poseLibSelectPoseControlsPUM[$realNumber];
				menuItem -divider true;
				menuItem -en on -label "Rename Pose" -c ("poseLibRenamePose (" + $realNumber + ")") poseLibRenamePosePUM[$realNumber];
				menuItem -divider true;
				menuItem -en on -label "Move Pose" -c ("poseLibMovePose (" + $realNumber + ")") poseLibMovePosePUM[$realNumber];
				menuItem -divider true;
				menuItem -en on -label "Replace Pose" -c ("poseLibReplacePose (" + $realNumber + ")") poseLibReplacePosePUM[$realNumber];
				menuItem -divider true;
				menuItem -en on -label "Delete Pose" -c ("poseLibDeletePose (" + $realNumber + ")") poseLibDeletePosePUM[$realNumber];
				menuItem -divider true;
				menuItem -en on -label "Edit Pose" -subMenu true;
					menuItem -en on -label "Add/Replace Selected Control(s)" -c ("poseLibAddReplaceSelectedControls (" + $realNumber + ")") addReplaceControlsPUM[$realNumber];
					menuItem -divider true;
					menuItem -en on -label "Remove Selected Control(s)" -c ("poseLibRemoveSelectedControls (" + $realNumber + ")") removeControlsPUM[$realNumber];
					menuItem -divider true;
					menuItem -en on -label "Output Pose Info to Script Editor" -c ("poseLibOutputPoseInfo(" + $realNumber + ")") poseLibSelectPoseControlsPUM[$realNumber];
					menuItem -divider true;
					menuItem -en on -label "Edit Pose File" -c ("poseLibEditPoseFile(" + $realNumber + ")") poseLibSelectPoseControlsPUM[$realNumber];
				setParent ..;
			setParent ..;

			//print ($iconsPath + $listOfPosesByIndex[$i] + ".bmp\n");

			// Assign the icon if it exists.
			if ( `filetest -r ($iconsPath + $listOfPosesByIndex[$i] + ".xpm")` )
				{
				//print ("\nIcon file for \"" + $listOfPosesByIndex[$i] + "\" = " + $iconsPath + $listOfPosesByIndex[$i] + ".xpm");
				shelfButton -e -image1 ($iconsPath + $listOfPosesByIndex[$i] + ".xpm") ("poseButton_" + $realNumber + "_");
				}
			else if ( `filetest -r ($iconsPath + $listOfPosesByIndex[$i] + ".bmp")` )
				{
				//print ("\nIcon file for \"" + $listOfPosesByIndex[$i] + "\" = " + $iconsPath + $listOfPosesByIndex[$i] + ".bmp");
				shelfButton -e -image1 ($iconsPath + $listOfPosesByIndex[$i] + ".bmp") ("poseButton_" + $realNumber + "_");
				}
				// If there's no icon for the pose, just display a red background.
			else
				{
				shelfButton -e -bgc .9 .2 0 ("poseButton_" + $realNumber + "_");
				print ("\n-> Did not find an icon file (either .xpm or .bmp) for \"" + $listOfPosesByIndex[$i] + "\"");
				}

			$realNumber++;
			}
		}

	// --------------------------
	// 6- Update frame layouts.
	// --------------------------
	frameLayout -e -m on plPosesFL;
	shelfLayout -e -m on plPosesSL;
	int $tmp = `frameLayout -q -w plPosesFL` / 2.8;
	frameLayout -e -li $tmp -lw 75 -l ("Assets: " + $realNumber) -fn "smallFixedWidthFont" plPosesFL;
}

global proc poseLibEditOptions ()
{
	global string $poseLibDefaultPath;
	global string $poseLibCharacterList[];
	global string $poseLibCategoryList[];
	global string $poseLibTextEditor;
	global int $poseLibIconsSize[];
	global float $poseLibIconsBGColor[];
	global float $poseLibCaptureCameraBGColor[];
	global string $poseLibPathsBookmarks[];

	print "\nOption window: ";
	print $poseLibPathsBookmarks;
	print "\n";

	// ---------------------
	// Check directories.
	// ---------------------
	string $allCharDirsTmp[] = `getFileList -folder ($poseLibDefaultPath + "/")`; //print ("\n$allCharDirs="+$allCharDirs[0]);
	string $allCharDirs[] = {};

	int $i;
	for ($i=0;$i<`size $allCharDirsTmp`;$i++)
		{
		if ( (`match ".deleted" $allCharDirsTmp[$i]` != ".deleted") && (`match ".DS_Store" $allCharDirsTmp[$i]` != ".DS_Store") )
			$allCharDirs = stringArrayCatenate ( $allCharDirs, { $allCharDirsTmp[$i] } );
		}

	$poseLibCharacterList = $allCharDirs;

	// ------------------
	// Build UI layout
	// ------------------
	if (`window -exists poseLibEditOptionsWindow` )
		deleteUI poseLibEditOptionsWindow;

	//if (`window -exists poseLibCreateNewPoseWindow` )
	//	deleteUI poseLibCreateNewPoseWindow;

	window -tlb off -rtf on -sizeable true -width 200 -height 350  -title "AssetMan - Edit Options" poseLibEditOptionsWindow;

	string $form = `formLayout`;
	string $tabs = `tabLayout -cc "window -e -h 378 poseLibEditOptionsWindow" -innerMarginWidth 1 -innerMarginHeight 1 poseLibOptionsWindowTL`;

	formLayout -edit
		-attachForm $tabs "top"    0
		-attachForm $tabs "left"   0
		-attachForm $tabs "bottom" 0
		-attachForm $tabs "right"  0
		$form;

	// Characters/Categories:
	string $characterCategoriesUI = `frameLayout -mw 2 -lv off -collapsable false -borderVisible off -w 322 -p $tabs charactersCategoriesOptionsFL`;

		columnLayout -adjustableColumn false -width 500 -p charactersCategoriesOptionsFL mainColumn;

			frameLayout -mw 5 -h 31 -bv on -lv off -collapsable false -borderStyle "etchedOut" -w 322 -p mainColumn newCharFrame;
				columnLayout -adjustableColumn false newCharColumn;

					separator -style "none" -h 2;
					textFieldButtonGrp -label "Main Category:" -bc "poseLibCreateNewCharacterMenu" -text "" -buttonLabel "     Add     " -cw3 98 120 50 newCharacterTFG;
					separator -style "none" -h 2;

					setParent..;
				setParent..;

			separator -style "none" -h 4;

			frameLayout -mw 5 -h 57 -bv on -lv off -collapsable false -p mainColumn -borderStyle "etchedOut" -w 322 newCatFrame;
				columnLayout -adjustableColumn false -w 172 -p newCatFrame newCatColumn;

					separator -style "none" -h 2;
					textFieldButtonGrp -label "Sub Category:" -bc "poseLibCreateNewCategoryMenu" -text "" -buttonLabel "     Add     " -cw3 98 120 50 newCategoryTFG;
					separator -style "none" -h 6;

					rowLayout -nc 2 -cw2 175 160 -p newCatColumn;

						radioCollection forCurrentOrAllCharRB;
							radioButton -ann "" -label "To selected category only" -al "left" forCurrentChar;
							radioButton -ann "" -label "To every category" -al "left" forAllChar;
						radioCollection -e -sl forCurrentChar forCurrentOrAllCharRB;

						setParent..;

					separator -style "none" -h 2;
				setParent..;
			setParent..;

			separator -style "none" -h 4;

			frameLayout -mw 5 -h 225 -bv on -lv off -collapsable false -borderStyle "etchedOut" -w 322 tweakFrame;

				columnLayout -adjustableColumn false tweakColumn;
					rowLayout -nc 2 -cw2 158 158 ;
						columnLayout -adjustableColumn true;
							text -al "center" -l "Main Category:";
							textScrollList -fn "boldLabelFont" -ams false -w 150 -h 120 listCharacters;
						setParent..;
						columnLayout -adjustableColumn true;
							text -al "center" -l "SubCategory:";
							textScrollList -fn "boldLabelFont" -ams false -w 150 -h 120 listCategories;
						setParent..;
					setParent..;

			separator -style "none" -h 4;

			rowLayout -nc 2 -cw2 158 158;
				columnLayout -adjustableColumn true;
					button -w 150 -al "center" -l "Rename" -c poseLibRenameCharacterMenu;
					button -w 150 -l "Delete" -c poseLibDeleteCharacterMenu;
				setParent..;

				columnLayout -adjustableColumn true;
					button -w 150 -l "Rename" -c poseLibRenameCategoryMenu;
					button -w 150 -l "Delete" -c poseLibDeleteCategoryMenu;
				setParent..;
			setParent..;

			columnLayout -adj true;

				separator -style "none" -h 4;
				button -w 308 -c "deleteUI poseLibEditOptionsWindow" -al "center" -l "Close";
				separator -style "none" -h 4;
			setParent..;
		setParent..;

	// Display:
	string $displayUI = `frameLayout -lv off -collapsable false -borderVisible off -w 322 -p $tabs displayIconsOptionsFL`;

		columnLayout -adjustableColumn true -width 500 -p displayIconsOptionsFL mainColumn2;

			separator -style "none" -h 2;
			frameLayout -mw 5 -bv on -lv on -li 8 -l "Icons Size:" -collapsable false -borderStyle "etchedOut" -w 322 -p mainColumn2 iconsDisplayFrame;
				columnLayout -adjustableColumn true -w 320 iconsDisplayColumn;

					separator -style "none" -h 8;
					radioButtonGrp -numberOfRadioButtons 4 -cw4 70 70 90 80 -sl 1
						-labelArray4 "50x50" "64x64" "100x100" "128x128" iconsSizeRB;

					separator -style "in" -h 10;

					rowColumnLayout -numberOfColumns 5
						-columnWidth 1 90
						-columnWidth 2 30
						-columnWidth 3 20
						-columnWidth 4 30
						-columnWidth 5 150;

						checkBox -l "Custom Size:" -onc "intField -e -en on iconsWidthIF; intField -e -en on iconsHeightIF; radioButtonGrp -e -en off iconsSizeRB"
							-ofc "intField -e -en off iconsWidthIF; intField -e -en off iconsHeightIF; radioButtonGrp -e -en on iconsSizeRB" customSizeCB;

						intField -v 256 -en off -min 32 -max 512 iconsWidthIF;
						text "  x";
						intField -v 256 -en off -min 32 -max 512 iconsHeightIF;

						text -bgc .75 .75 .75 " (Min= 32*32   Max=512*512)";
						separator -style "none" -h 4;

					setParent..;
				setParent..;
			setParent..;

			separator -style "none" -h 4;
			frameLayout -mw 5 -bv on -lv on -li 8 -l "Colors:" -collapsable false -borderStyle "etchedOut" -w 322 -p mainColumn2 iconsBackgroundColorFrame;
				columnLayout -adjustableColumn true -w 320;
					separator -style "none" -h 8;
					colorSliderGrp -label "Icons Background Color" -cw3 140 80 90 -rgb $poseLibIconsBGColor[0] $poseLibIconsBGColor[1] $poseLibIconsBGColor[2] iconsBGColorCSG;
					colorSliderGrp -label "Capture Camera BG Color" -cw3 140 80 90 -rgb $poseLibCaptureCameraBGColor[0] $poseLibCaptureCameraBGColor[1] $poseLibCaptureCameraBGColor[2] captureCameraBGColorCSG;
					separator -style "none" -h 4;
				setParent..;
			setParent..;

			separator -style "none" -h 4;
			frameLayout -mw 5 -bv on -lv on -li 8 -l "Capture Camera:" -collapsable false -borderStyle "etchedOut" -w 322 -p mainColumn2 captureCameraOptionsFrame;
				columnLayout -adjustableColumn true -w 320;
					separator -style "none" -h 8;
					intSliderGrp -label "Focal Length" -cw 1 90 -cw 2 60 -field true
						-minValue 15 -maxValue 300
						-fieldMinValue 15 -fieldMaxValue 300
						-value 35 captureCameraFocalLengthISG;
					connectControl captureCameraFocalLengthISG "poseLibCaptureCameraShape.focalLength";

					floatSliderGrp -label "Near Clip Plane" -cw 1 90 -cw 2 60 -field true
						-minValue 0.01 -maxValue 10000.0
						-fieldMinValue 0.01 -fieldMaxValue 10000.0
						-value 0.1 captureCameraNearClipFSG;
					connectControl captureCameraNearClipFSG "poseLibCaptureCameraShape.nearClipPlane";

					floatSliderGrp -label "Far Clip Plane" -cw 1 90 -cw 2 60 -field true
						-minValue 1.0 -maxValue 100000.0
						-fieldMinValue 1.0 -fieldMaxValue 100000.0
						-value 1000000.0 captureCameraFarClipFSG;
					connectControl captureCameraFarClipFSG "poseLibCaptureCameraShape.farClipPlane";

					separator -style "none" -h 4;
				setParent..;
			setParent..;

			separator -style "none" -h 8;

			button -l "Apply and Close" -command "poseLibChangeIconsDisplay";
			separator -style "none" -h 4;

		setParent..;

	// Directory:
	string $poseLibFolderUI = `frameLayout -lv off -collapsable false -borderVisible off -w 322 -p $tabs poseLibFolderOptionsFL`;

		columnLayout -adjustableColumn true -width 500 -p poseLibFolderOptionsFL mainColumn3;

			separator -style "none" -h 2;

			frameLayout -mw 5 -h 280 -bv on -lv on -li 8 -l "Directories Bookmarks:" -collapsable false -borderStyle "etchedOut" -w 322 -p mainColumn3 poseLibFolderFrame;
				columnLayout -adjustableColumn true poseLibFolderColumn;

					separator -style "none" -h 2;

					text -l "(Double-click to set path)        (DEL key to delete)";
					paneLayout -w 308 -h 110;
						textScrollList -numberOfRows 8
						-allowMultiSelection false
						-dkc "string $toto[] = `textScrollList -q -si poseLibDirectoriesBookmarksTSL`; textScrollList -e -ri $toto[0] poseLibDirectoriesBookmarksTSL; string $tmpList[] = $poseLibPathsBookmarks; string $tmpItems[] = $toto; $poseLibPathsBookmarks = stringArrayRemove($tmpItems, $tmpList); poseLibSavePrefs;"
						-sc "textScrollList -e -ann `textScrollList -q -si poseLibDirectoriesBookmarksTSL` poseLibDirectoriesBookmarksTSL"
						-dcc "string $pathTmp[] = `textScrollList -q -si poseLibDirectoriesBookmarksTSL`; poseLibBrowseForFolderCallback( \"yes\", $pathTmp[0], \"typeNothing\" )"
						poseLibDirectoriesBookmarksTSL;
					setParent..;

					for ($i=0;$i<`size $poseLibPathsBookmarks`;$i++)
						{
						textScrollList -e -appendPosition 1 $poseLibPathsBookmarks[$i] -si $poseLibDefaultPath poseLibDirectoriesBookmarksTSL;
						print ( "Loaded poseLib bookmark: " + $poseLibPathsBookmarks[$i] + "\n");
						}

					text -w 210 -fn "boldLabelFont" -l "Current AssetManager Directory:";
					text -bgc .8 .8 .8 -ann ($poseLibDefaultPath + "/") -l ($poseLibDefaultPath + "/") poseLibFolderOptionText;
					separator -style "none" -h 2;

					textField -cc "poseLibBrowseForFolderCallback( \"\", `textField -q -tx poseLibFolderOptionTF`, \"\")" -ann ($poseLibDefaultPath + "/") -tx ($poseLibDefaultPath + "/") poseLibFolderOptionTF;
					checkBox -v 1 -en on -al "left" -l "Add \"/AssetManager/\" at the end of the chosen path." poseLibFolderOptionCB;
					separator -style "none" -h 2;
					button -w 308 -l "Choose Location of AssetManager Directory" -c ("poseLibBrowseForFolder( \"" + $poseLibDefaultPath + "\" )");

					separator -style "none" -h 4;
					button -w 308 -l "Open Windows Explorer Here" -c ("string $lastPlaceTmp = `text -q -label poseLibFolderOptionText`; string $lastPlace = toNativePath( $lastPlaceTmp ); system (\"start explorer /n,/e, \" + $lastPlace)");
					separator -style "none" -h 4;

				setParent..;
			setParent..;

			separator -style "none" -h 4;
			button -w 320 -c "deleteUI poseLibEditOptionsWindow" -al "center" -l "Close";
		setParent..;


	// Text editor:
	string $poseLibTextEditorUI = `frameLayout -lv off -collapsable false -borderVisible off -w 322 -p $tabs poseLibTextEditorOptionsFL`;

		columnLayout -adjustableColumn false -width 500 -p poseLibTextEditorOptionsFL mainColumn3;
			separator -style "none" -h 2;
			frameLayout -mw 5 -bv on -lv on -li 8 -l "Current Text Editor:" -collapsable false -borderStyle "etchedOut" -w 322 -p mainColumn3 poseLibTextEditorFrame;
				columnLayout -adjustableColumn false poseLibTextEditorColumn;
					separator -style "none" -h 2;
					text -l "(This is the program used when editing files)";
					text -bgc .8 .8 .8 -ann $poseLibTextEditor -l $poseLibTextEditor poseLibTextEditorOptionText;
					separator -style "none" -h 2;
					button -w 308 -l "Choose Text Editor" -c "poseLibChooseTextEditor";
					separator -style "none" -h 4;

				setParent..;
			setParent..;

			separator -style "none" -h 4;
			button -w 320 -c "deleteUI poseLibEditOptionsWindow" -al "left" -l "                                             Close";
		setParent..;


	// ------------------
	// Organize tabs
	// ------------------
	tabLayout -edit
		-tabLabel $characterCategoriesUI "Categories"
		-tabLabel $displayUI "Display"
		-tabLabel $poseLibFolderUI "Directory"
		-tabLabel $poseLibTextEditorUI "Text Editor"
		-st $characterCategoriesUI
		$tabs;

	if ( ($poseLibIconsSize[0] == 50) && ($poseLibIconsSize[1] == 50) )
		{
		radioButtonGrp -e -sl 1 iconsSizeRB;
		checkBox -e -v 0 customSizeCB;
		}

	else if ( ($poseLibIconsSize[0] == 64) && ($poseLibIconsSize[1] == 64) )
		{
		radioButtonGrp -e -sl 2 iconsSizeRB;
		checkBox -e -v 0 customSizeCB;
		}

	else if ( ($poseLibIconsSize[0] == 100) && ($poseLibIconsSize[1] == 100) )
		{
		radioButtonGrp -e -sl 3 iconsSizeRB;
		checkBox -e -v 0 customSizeCB;
		}

	else if ( ($poseLibIconsSize[0] == 128) && ($poseLibIconsSize[1] == 128) )
		{
		radioButtonGrp -e -sl 4 iconsSizeRB;
		checkBox -e -v 0 customSizeCB;
		}

	else
		{
		radioButtonGrp -e -en off iconsSizeRB;
		checkBox -e -en on -v 1 customSizeCB;
		intField -e -en on -v $poseLibIconsSize[0] iconsWidthIF;
		intField -e -en on -v $poseLibIconsSize[1] iconsHeightIF;
		}

	colorSliderGrp -e -rgb $poseLibIconsBGColor[0] $poseLibIconsBGColor[1] $poseLibIconsBGColor[2] iconsBGColorCSG;
	colorSliderGrp -e -rgb $poseLibCaptureCameraBGColor[0] $poseLibCaptureCameraBGColor[1] $poseLibCaptureCameraBGColor[2] captureCameraBGColorCSG;

	// ------------------
	// Populate lists
	// ------------------
	string $characterName = `optionMenu -q -v characterChoiceOM`;

	textScrollList -e -ra listCharacters;

	string $c;
	for ( $c in $poseLibCharacterList )
		{
		textScrollList -e -m off -w 150 -h 120 -append $c -sc "poseLibRefreshCategoryList" listCharacters;
		}
	textScrollList -e -si $characterName -m on listCharacters;
	poseLibRefreshCategoryList;
	showWindow poseLibEditOptionsWindow;
	window -e -h 378 poseLibEditOptionsWindow;
}

global proc poseLibChangeIconsDisplay ()
{
	global int $poseLibIconsSize[];
	global float $poseLibIconsBGColor[];
	global float $poseLibCaptureCameraBGColor[];

	// Set icons sizes.
	if ( `radioButtonGrp -q -sl iconsSizeRB` == 1 && `radioButtonGrp -q -en iconsSizeRB` )
		{
		$poseLibIconsSize[0] = 50;
		$poseLibIconsSize[1] = 50;
		}

	else if ( `radioButtonGrp -q -sl -en iconsSizeRB` == 2 && `radioButtonGrp -q -en iconsSizeRB` )
		{
		$poseLibIconsSize[0] = 64;
		$poseLibIconsSize[1] = 64;
		}

	else if ( `radioButtonGrp -q -sl -en iconsSizeRB` == 3 && `radioButtonGrp -q -en iconsSizeRB` )
		{
		$poseLibIconsSize[0] = 100;
		$poseLibIconsSize[1] = 100;
		}

	else if ( `radioButtonGrp -q -sl -en iconsSizeRB` == 4 && `radioButtonGrp -q -en iconsSizeRB` )
		{
		$poseLibIconsSize[0] = 128;
		$poseLibIconsSize[1] = 128;
		}

	else
		{
		$poseLibIconsSize[0] = `intField -q -v iconsWidthIF`;
		$poseLibIconsSize[1] = `intField -q -v iconsHeightIF`;
		}

	// Set colors to reflect current preferences.
	$poseLibIconsBGColor = `colorSliderGrp -q -rgb iconsBGColorCSG`; //print "\n$poseLibIconsBGColor = "; print $poseLibIconsBGColor; print "\n";
	$poseLibCaptureCameraBGColor = `colorSliderGrp -q -rgb captureCameraBGColorCSG`; //print "\n$poseLibCaptureCameraBGColor = "; print $poseLibCaptureCameraBGColor; print "\n";

	//poseLibSavePrefs;
	assetMan;
	print ("Icons size set to: " + $poseLibIconsSize[0] + " x " + $poseLibIconsSize[1] + "\n");
}

global proc poseLibRefreshCategoryList ()
{
	global string $poseLibDefaultPath;
	string $characterName[0] = `textScrollList -q -si listCharacters`;
	string $allCatDirsTmp[] = `getFileList -folder ($poseLibDefaultPath + "/" + $characterName[0] + "/")`; //print ("\n$allPoseFiles="+$allPoseFiles[0]);
	string $allCatDirs[] = {};

	int $i;
	for ($i=0;$i<`size $allCatDirsTmp`;$i++)
		{
		if ( (`match ".deleted" $allCatDirsTmp[$i]` != ".deleted") && (`match ".DS_Store" $allCatDirsTmp[$i]` != ".DS_Store") )
			$allCatDirs = stringArrayCatenate ( $allCatDirs, { $allCatDirsTmp[$i] } );
		}

	textScrollList -e -ra listCategories;

	string $g;
	for ( $g in $allCatDirs )
		{
		textScrollList -e -m off -w 150 -h 120 -append $g listCategories;
		}
	textScrollList -e -m on listCategories;
}

global proc poseLibCreateNewCharacterMenu ()
{
	global string $poseLibDefaultPath;
	string $character = `textFieldButtonGrp -q -text newCharacterTFG`;
	string $checkName = `match " [$%\\/#@.:;?!\"\'\`]" $character`;
	string $allCharDirs[] = `getFileList -folder ($poseLibDefaultPath + "/")`; //print ("\n$allPoseFiles="+$allPoseFiles[0]);

	if ( (`size $checkName` > 0) || (`size $character` == 0) )
		{
		error "You must enter a valid name, without any of these: \" $ % \\ / # @ . :; ? ! \' \`";
		return;
		}
	else
		{
		sysFile -makeDir ( $poseLibDefaultPath + "/" + $character );
		sysFile -makeDir ( $poseLibDefaultPath + "/" + $character + "/default" );
		poseLib;
		poseLibEditOptions;
		textScrollList -e -si $character listCharacters;
		poseLibRefreshCategoryList;

		print ( "AssetMan: Created new image: " + $character + "\n" );

		string $c;
		for ( $c in $allCharDirs )
			{
			string $checkTmp = `match $c $character`;

			if ( `size $checkTmp` > 0 )
				warning "There is already a image with this name!";
			}
		}
}

global proc poseLibRenameCharacterMenu ()
{
	if (`window -exists renameCharacterWindow` )
		deleteUI renameCharacterWindow;

	string $nameTmp[0] = `textScrollList -q -si listCharacters`;

	window -tlb off -rtf true -w 10 -h 10 -title "Rename Image" renameCharacterWindow;
		columnLayout -adj true;
			frameLayout -mw 2 -lv false -collapsable false -borderStyle "etchedOut";
				columnLayout -adj true;
					textFieldGrp -cw2 50 150 -l "Name" -cc "poseLibDoRenameCharacterMenu" -tx (`textScrollList -q -si listCharacters`) setNameField;
					button -l "Cancel" -al "center" -c "deleteUI renameCharacterWindow";

	if ( $nameTmp[0] != "" )
		showWindow renameCharacterWindow;
	else
		warning " ---> Please select a character first!\n";
}

global proc poseLibDoRenameCharacterMenu ()
{
	global string $poseLibDefaultPath;
	string $nameTmp[0] = `textScrollList -q -si listCharacters`;
	string $softCharacterToRename = ( $poseLibDefaultPath + "/" + $nameTmp[0] );

	string $newName = `textFieldGrp -q -tx setNameField`;

	sysFile -rename ($poseLibDefaultPath + "/" + $newName) $softCharacterToRename; //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );

	evalDeferred("poseLib");
	poseLibEditOptions;
	textScrollList -e -si $newName listCharacters;
	poseLibRefreshCategoryList;
	print ("AssetMan: Renamed image: " + $poseLibDefaultPath + "/" + $nameTmp[0] + " to: " + $newName + "\n" );
}

global proc poseLibDeleteCharacterMenu ()
{
	global string $poseLibDefaultPath;
	string $nameTmp[0] = `textScrollList -q -si listCharacters`;
	string $confirmDeleteWindow = "";

	if ( $nameTmp[0] != "" )
		$confirmDeleteWindow = `confirmDialog -title "Confirm" -message "Are you sure you want to delete this character\nwith all the poses and categories inside?" -button "Yes" -button "No" -button "Cancel" -defaultButton "Yes" -cancelButton "Cancel" -dismissString "No"`;
	else
		warning " ---> Please select a character in the list first!\n";

	if ( $confirmDeleteWindow == "Yes" )
		{
		string $solidPath = "";
		string $buffer[];
		int $numTokens = `tokenize ($poseLibDefaultPath + "/" + $nameTmp[0]) "\/" $buffer`;

		int $i;
		for ($i=0;$i<`size $buffer`;$i++)
			{
			if ( $i < (`size $buffer`-1) )
				$solidPath = $solidPath + $buffer[$i] + "\\";
			else
				$solidPath = $solidPath + $buffer[$i];
			}

		if ( `filetest -d ($poseLibDefaultPath + "/" + $nameTmp[0] + ".deleted")` )
			system ("rmdir " + $solidPath + ".deleted /s /q" ); //print ("\nrmdir " + $solidPath + ".deleted");

		sysFile -rename (($poseLibDefaultPath + "/" + $nameTmp[0]) + ".deleted") ($poseLibDefaultPath + "/" + $nameTmp[0]); //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );

		poseLib;
		poseLibEditOptions;
		print ("poseLib: Deleted character: " + $poseLibDefaultPath + "/" + $nameTmp[0] + "\n" );
		}
}

global proc poseLibCreateNewCategoryMenu ()
{
	global string $poseLibDefaultPath;
	string $character[0] = `textScrollList -q -si listCharacters`;
	string $category = `textFieldButtonGrp -q -text newCategoryTFG`;
	string $checkName = `match " [$%\\/#@.:;?!\"\'\`]" $category`;
	string $allCharDirs[] = `getFileList -folder ($poseLibDefaultPath + "/")`; //print ("\n$allPoseFiles="+$allPoseFiles[0]);
	string $allCatDirs[] = `getFileList -folder ($poseLibDefaultPath + "/" + $character[0])`; //print ("\n$allPoseFiles="+$allPoseFiles[0]);

	if ( (`size $checkName` > 0) || (`size $category` == 0) )
		{
		error "You must enter a valid name, without any of these: \" $ % \\ / # @ . :; ? ! \' \`";
		return;
		}

	if ( `radioCollection -q -sl forCurrentOrAllCharRB` == "forCurrentChar" )
		{
		sysFile -makeDir ( $poseLibDefaultPath + "/" + $character[0] + "/" + $category );
		poseLib;
		poseLibEditOptions;
		textScrollList -e -si $character[0] listCharacters;
		radioCollection -e -sl forCurrentChar forCurrentOrAllCharRB;
		poseLibRefreshCategoryList;

		print ( "AssetMan: Created new category: " + $category + "\n" );

		string $c;
		for ( $c in $allCatDirs )
			{
			string $checkTmp = `match $c $category`;

			if ( `size $checkTmp` > 0 )
				warning "There is already a category with this name!";
			}
		}
	else
		{
		string $g;
		for ( $g in $allCharDirs )
			{
			sysFile -makeDir ( $poseLibDefaultPath + "/" + $g + "/" + $category );
			}
		assetMan;
		poseLibEditOptions;
		textScrollList -e -si $character[0] listCharacters;
		radioCollection -e -sl forAllChar forCurrentOrAllCharRB;
		poseLibRefreshCategoryList;

		print ( "AssetMan: Created new category: " + $category + " for all characters\n" );
		}
}

global proc poseLibRenameCategoryMenu ()
{
	if (`window -exists renameCategoryWindow` )
		deleteUI renameCategoryWindow;

	string $nameTmp[0] = `textScrollList -q -si listCategories`;

	window -tlb off -rtf true -w 10 -h 10 -title "Rename Category" renameCategoryWindow;
		columnLayout -adj true;
			frameLayout -mw 2 -lv false -collapsable false -borderStyle "etchedOut";
				columnLayout -adj true;
					textFieldGrp -cw2 50 150 -l "Name" -cc "poseLibDoRenameCategoryMenu" -tx (`textScrollList -q -si listCategories`) setNameField;
					button -w 100 -l "Cancel" -al "center" -c "deleteUI renameCategoryWindow";

	if ( $nameTmp[0] != "" )
		showWindow renameCategoryWindow;
	else
		warning " ---> Please select a category in the list first!\n";
}

global proc poseLibDoRenameCategoryMenu ()
{
	global string $poseLibDefaultPath;
	string $charTmp[0] = `textScrollList -q -si listCharacters`;
	string $nameTmp[0] = `textScrollList -q -si listCategories`;
	string $softCategoryToRename = ( $poseLibDefaultPath + "/" + $charTmp[0] + "/" + $nameTmp[0] );

	string $newName = `textFieldGrp -q -tx setNameField`;

	sysFile -rename ($poseLibDefaultPath + "/" + $charTmp[0] + "/" + $newName) $softCategoryToRename; //print ( "\noldName= " + $currentName + "\nnewName= " + $newName );

	evalDeferred("assetMan");
	poseLibEditOptions;
	textScrollList -e -si $charTmp[0] listCharacters;
	poseLibRefreshCategoryList;
	textScrollList -e -si $newName listCategories;
	print ("AssetManager: Renamed category: " + $poseLibDefaultPath + "/" + $nameTmp[0] + " to: " + $newName + "\n");
}

global proc poseLibDeleteCategoryMenu ()
{
	global string $poseLibDefaultPath;
	string $charTmp[0] = `textScrollList -q -si listCharacters`;
	string $nameTmp[0] = `textScrollList -q -si listCategories`;
	string $confirmDeleteWindow = "";

	if ( $nameTmp[0] != "" )
		$confirmDeleteWindow = `confirmDialog -title "Confirm" -message "Are you sure you want to delete\nthis category with all the poses inside?" -button "Yes" -button "No" -button "Cancel" -defaultButton "Yes" -cancelButton "Cancel" -dismissString "No"`;
	else
		warning " ---> Please select a category in the list first!\n";

	if ( $confirmDeleteWindow == "Yes" )
		{
		string $solidPath = "";
		string $buffer[];
		int $numTokens = `tokenize ($poseLibDefaultPath + "/" + $charTmp[0] + "/" + $nameTmp[0]) "\/" $buffer`;

		int $i;
		for ($i=0;$i<`size $buffer`;$i++)
			{
			if ( $i < (`size $buffer`-1) )
				$solidPath = $solidPath + $buffer[$i] + "\\";
			else
				$solidPath = $solidPath + $buffer[$i];
			}

		if ( `filetest -d ($poseLibDefaultPath + "/" + $charTmp[0] + "/" + $nameTmp[0] + ".deleted")` )
			{
			system ("rmdir " + $solidPath + ".deleted /s /q" ); //print ("\nrmdir " + $solidPath + ".deleted");
			}

		sysFile -rename ($poseLibDefaultPath + "/" + $charTmp[0] + "/" + $nameTmp[0] + ".deleted") ($poseLibDefaultPath + "/" + $charTmp[0] + "/" + $nameTmp[0]);

		assetMan;
		poseLibEditOptions;
		textScrollList -e -si $charTmp[0] listCharacters;
		poseLibRefreshCategoryList;
		print ("AssetManager: Deleted category: " + $poseLibDefaultPath + "/" + $nameTmp[0] + "\n");
		}
}

global proc assetMan()
{
	global string $poseLibVersion;
	global string $poseLibDefaultPath;
	global string $poseLibCharacterList[];
	global string $poseLibCategoryList[];
	global string $poseLibCurrentProject = "";
	global string $poseLibPathsBookmarks[];
	global int $poseLibIconsSize[];
	global float $poseLibIconsBGColor[];
	global float $poseLibCaptureCameraBGColor[];
	string $c;

	// Run the proc to initialize all the global variable at the start.
	// This is in case poseLib is launched without being sourced first.
	poseLibInitializeVariables;

	// -------------------------------
	// Create characters directories.
	// -------------------------------
	string $allCharDirsTmp[] = `getFileList -folder ($poseLibDefaultPath + "/")`; //print ("\n$allCharDirs="+$allCharDirs[0]);
	string $allCharDirs[];

	for ($i=0;$i<`size $allCharDirsTmp`;$i++)
		{
		if ( (`match ".deleted" $allCharDirsTmp[$i]` != ".deleted") && (`match ".DS_Store" $allCharDirsTmp[$i]` != ".DS_Store") )
			$allCharDirs = stringArrayCatenate ( $allCharDirs, { $allCharDirsTmp[$i] } );
		}

	if ( $allCharDirs[0] == "" )
		{
		string $softPosesPathTmp;
		for ( $c in $poseLibCharacterList )
			{
			$softPosesPathTmp = $poseLibDefaultPath + "/" + $c; //print ( "\ncreated " + $softPosesPathTmp );
			sysFile -makeDir $softPosesPathTmp;
			}

		$softPosesPathTmp = $poseLibDefaultPath + "/" + $c;

		string $g;
		for ( $g in $poseLibCategoryList )
			{
			string $softCategoriesPathTmp = $softPosesPathTmp + "/" + $g; //print ( "\ncreated =" + $softCategoriesPathTmp );
			sysFile -makeDir $softCategoriesPathTmp;
			}
		}
	else
		$poseLibCharacterList = $allCharDirs;

	// Delete any existing poseLib-related window.
	if (`window -exists poseLibWindow` )
		deleteUI poseLibWindow;

	if (`window -exists poseLibEditOptionsWindow` )
		deleteUI poseLibEditOptionsWindow;

	if (`window -exists poseLibCreateNewPoseWindow` )
		deleteUI poseLibCreateNewPoseWindow;

	if (`window -exists renameCharacterWindow` )
		deleteUI renameCharacterWindow;

	if (`window -exists renameCategoryWindow` )
		deleteUI renameCategoryWindow;

	if (`window -exists poseLibRenamePoseWindow` )
		deleteUI poseLibRenamePoseWindow;

	// ----------------
	// Build main UI.
	// ----------------
	window -tlb off -rtf off -sizeable true -menuBar true -w 450 -title ("Asset Manager v" + $poseLibVersion ) poseLibWindow;

	int $h = 20;

	// --------------
	// Poses frame.
	// --------------
	string $form = `formLayout -numberOfDivisions 100 plMainFL`;
	string $posesFrameLayout = `frameLayout -m off -mw 2 -mh 2 -p plMainFL -l "Assets: " -fn "smallFixedWidthFont" -collapsable false -borderStyle "etchedOut" plPosesFL`;
	string $posesShelfLayout = `shelfLayout -p $posesFrameLayout -st "iconAndTextVertical" plPosesSL`;
	string $optionsFrameLayout = `frameLayout -lv off -p plMainFL -collapsable false -borderVisible off plOptionsFL`;
	string $optionsColumn = `columnLayout -p $optionsFrameLayout -adjustableColumn true plOptionsColumn`;

	// ---------------
	// Options frame.
	// ---------------
	frameLayout -mw 5 -bv on -lv off -collapsable false -borderStyle "etchedOut" -w 190 -p plOptionsColumn namespaceFrameLayoutFL;
		columnLayout -adjustableColumn true -p namespaceFrameLayoutFL;
			separator -st none -h 4 -w 150;
			checkBox -al "left" -l "Use Current Namespace" -en 0 -value 0 -onc "checkBox -e -v 0 -en off useCustomNamespaceCB; textField -e -en off namespaceTextFieldTF" -ofc "checkBox -e -en on useCustomNamespaceCB" useCurrentCharacterCB;
			checkBox -al "left" -l "Use Custom Namespace" -en 0 -value 0 -onc "textField -e -en on namespaceTextFieldTF" -ofc "textField -e -en off namespaceTextFieldTF" useCustomNamespaceCB;
			textField -w 150 -en off -text "myNamespace" namespaceTextFieldTF;
			separator -st none -h 4 -w 150;
		setParent ..;
	setParent ..;

	separator -st none -h 4 -w 150;

	frameLayout -mw 5 -bv on -lv off -collapsable false -borderStyle "etchedOut" -w 190 -p plOptionsColumn characterCategoryFL;
		columnLayout -adjustableColumn true -p characterCategoryFL;
			separator -st none -h 2 -w 150;
			optionMenu -h ($h+2) -label "Main Category: " -cc "poseLibRefreshPoseList(\"\")" characterChoiceOM;
				for ( $c in $poseLibCharacterList )
					{
					menuItem -label $c;
					}

			separator -st none -h 4 -w 150;
			text -l "";	
			optionMenu -h ($h+2) -label "Category:" -cc "poseLibRefreshPoseList(\"\")" categoryChoiceOM;
				for ($i=0;$i<`size $poseLibCategoryList`;$i++)
					{
					menuItem -label $poseLibCategoryList[$i] -p categoryChoiceOM categoryMI[$i];
					}
		setParent ..;
	setParent ..;

	separator -st "none" -h 4;

	// --------------------
	// Create pose frame.
	// --------------------
	frameLayout -mw 5 -bv on -lv off -collapsable false -borderStyle "etchedOut" -p plOptionsColumn frameCreate;
		columnLayout -adjustableColumn true -p frameCreate setPosesColumn;

			separator -st none -h 4;

			button //-bgc .8 .8 .8
				-label "Create New Image!" -h 32 -w 156  -c ("poseLibCreateNewPose( \"\" )") newPoseButton;

			separator -st none -h 4;

		setParent ..;
	setParent ..;

	separator -st "none" -h 4;

	// --------------------
	// Settings frame.
	// --------------------
	frameLayout -mw 5 -bv on -lv off -collapsable false -borderStyle "etchedOut" -p plOptionsColumn frameSettings;
		columnLayout -adjustableColumn true -p frameSettings setPosesColumn;

			separator -st none -h 4;

			button -label "Edit Options" -h $h //-bgc .85 .85 .85
				-ann "Edit/Create characters and categories" -c "poseLibEditOptions" editSettingsButton;

			separator -st none -h 2;

			button -label "Save Preferences" -h $h //-bgc .85 .85 .85
				-ann "Create a new pose based on the current selection" -c "poseLibSavePrefs" savePrefsButton;

			separator -st none -h 4;

			setParent ..;
	setParent ..;

		separator -st none -h 2;
		text -l "";
		button -label "Search" -h $h //-bgc .85 .85 .85
			-c "displayTags" tagsButton;

		text -l "";
		button -label "Close" -h $h //-bgc .85 .85 .85
			-c "deleteUI poseLibWindow" closeButton;

		image -h 90 -image "Q:\\Scripts\\AssetManager\\Common\\CHARACTERS\\assetMan.bmp";
		
		setParent ..;
	setParent ..;

	formLayout -edit
		-attachForm     $posesFrameLayout     "top"    2
		-attachForm     $posesFrameLayout     "left"   2
		-attachForm     $posesFrameLayout     "bottom" 2
		-attachControl  $posesFrameLayout     "right"  2 $optionsFrameLayout

		-attachForm     $optionsFrameLayout "top"    2
		-attachNone     $optionsFrameLayout "left"
		-attachForm     $optionsFrameLayout "bottom" 2
		-attachForm     $optionsFrameLayout "right"  2
	$form;

	// ---------------------------------------------------------------------
	// Update poses list to populate the menus and icons.
	if ( `optionVar -exists characterChoiceStatus` )
		{
		string $characterTmp = `optionVar -q characterChoiceStatus`;
		catchQuiet ( `optionMenu -e -v $characterTmp characterChoiceOM` );
		}

	if ( `optionVar -exists categoryChoiceStatus` )
		{
		string $categoryTmp = `optionVar -q categoryChoiceStatus`;
		poseLibRefreshPoseList($categoryTmp);
		catchQuiet( `optionMenu -e -v $categoryTmp categoryChoiceOM` );
		}
	// ---------------------------------------------------------------------

	// Finally show the window.
	showWindow poseLibWindow;

	// If we're on Linux, the first frame appears by default with 0 height!!!
	if ( `about -os` == "linux" )
		frameLayout -e -h 78 namespaceFrameLayoutFL;

	// Update the number of poses readout at the top of the icons shelf layout.
	string $numberOfIconsTmp[] = `shelfLayout -q -ca plPosesSL`;
	int $tmp = `frameLayout -q -w plPosesFL` / 2.8;
	frameLayout -e -m on -li $tmp -lw 75 -l ("Assets: " + `size $numberOfIconsTmp`) -fn "smallFixedWidthFont" plPosesFL;

	// ---------------------
	// Recall preferences.
	// ---------------------
	if ( `optionVar -exists useCurrentCharacterStatus` )
		{
		checkBox -e -v `optionVar -q useCurrentCharacterStatus` useCurrentCharacterCB;
		checkBox -e -en (!`optionVar -q useCurrentCharacterStatus`) useCustomNamespaceCB;
		}

	if ( `optionVar -exists useCustomNamespaceStatus` )
		{
		checkBox -e -v `optionVar -q useCustomNamespaceStatus` useCustomNamespaceCB;
		textField -e -en `checkBox -q -v useCustomNamespaceCB` namespaceTextFieldTF;
		}

	if ( `optionVar -exists pathsBookmarksStatus` )
		{
		string $pathsBookmarksStatusTmp = `optionVar -q pathsBookmarksStatus`;
		$poseLibPathsBookmarks = stringToStringArray($pathsBookmarksStatusTmp, ","); //print "\n$poseLibPathsBookmarks = "; print $poseLibPathsBookmarks; print "\n";
		}

	print ( "Asset Manager path = " + $poseLibDefaultPath + "/\n" );

	// -----------------------
	// First time run!
	// -----------------------
	if ( !`optionVar -exists poseLibDefaultPathStatus` )
		{
		poseLibEditOptions;
		tabLayout -edit -selectTabIndex 3 poseLibOptionsWindowTL;

		if (`window -exists poseLibFirstTimeWindow` )
			deleteUI poseLibFirstTimeWindow;

		window -rtf true -t "First Time Run!" poseLibFirstTimeWindow;
		columnLayout -adj true columnTmp;
		text -bgc .7 .6 .9 "!Warning!";
		text "AssetMan detects it's the first time it's being launched!";
		text -bgc .5 .6 .9 "   ";
		text "  Please set the chosen path for AssetMan before starting to use it  ";
		text "  by clicking on \"Choose Location of AssetMan Directory\"  ";
		text "  in the \"Edit Options\" window...  ";
		text " -------------------------------------------------";
		text "Note that the images and category lists reflect REAL directories";
		text "on your hard drive/network. There shouldnt be any real risk since";
		text "AssetMan will only add \".deleted\" at the end of the directorys";
		text "  (or imagess) name if you delete them, but that could be a problem in itself.  \n";
		text "In short, if you see a list of all your projects coming up in the images";
		text "list, it is NOT a good idea to delete them; It just means the AssetMan path";
		text "is not set correctly. That's why you should do it right now!\n";

		button -l "OK" -c "deleteUI poseLibFirstTimeWindow";
		showWindow poseLibFirstTimeWindow;
	}
}

global proc displayTags()
{
	if((`window -exists tagsWindow`) == true) {deleteUI tagsWindow;} 
	window -wh 223 337 -s 0 -t "Tags Window" tagsWindow;
	columnLayout -adj true;
	text -l "Character or Tag name";
	textField -h 25 tagName;
	text -l "";
	button -bgc 0.5 0.7 0.7 -l "Display" -c "readInputs";
	text -l "";
	textScrollList -h 200 propName;
	showWindow;
}

global proc readInputs()
{
	textScrollList -e -ra propName;
	string $tagText = `textField -q -tx tagName`;
	string $nsFileName="D:/ProjName/Sets.txt";
	$fileId=`fopen $nsFileName "r"`;
	string $nextLine = `fgetline $fileId`;
	int $count=0;
	while ( size( $nextLine ) > 0 ) 
	{	 
		string $buffer[];
		$numTokens = `tokenize $nextLine "\n" $buffer`;
		string $buffer1[];
		$numTokens1 = `tokenize $buffer[0] "-" $buffer1`;
		string $charsArray[] = stringToStringArray($buffer1[0]," ");
		for($i=0; $i<size($charsArray); $i++)
		{
			if($charsArray[$i] == $tagText)
			{
				textScrollList -e -append $nextLine propName;
			}
		}
		string $tagsArray[] = stringToStringArray($buffer1[1],",");
		for($j=0; $j<size($tagsArray); $j++)
		{
			if($tagsArray[$j] == $tagText)
			{
				string $onlyChar = $nextLine;
				string $buffer2[];
				$numTokens2 = `tokenize $onlyChar " - " $buffer2`;
				textScrollList -e -append $buffer2[0] propName;
			}
		}
		$nextLine = `fgetline $fileId`;
	}
	fclose $fileId; 
}

assetMan();

